<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">apop_data.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li><a class="anchor" id="a00f92dca5b99168cf3e80903ea0397a0"></a><!-- doxytag: member="apop_data.c::Set_gsl_handler" ref="a00f92dca5b99168cf3e80903ea0397a0" args="" -->
#define <b>Set_gsl_handler</b>&#160;&#160;&#160;gsl_error_handler_t *prior_handler = gsl_set_error_handler(apop_gsl_error);
<li><a class="anchor" id="acfbcbb797586564ad3a93dae058f43e1"></a><!-- doxytag: member="apop_data.c::Unset_gsl_handler" ref="acfbcbb797586564ad3a93dae058f43e1" args="" -->
#define <b>Unset_gsl_handler</b>&#160;&#160;&#160;gsl_set_error_handler(prior_handler);
</ul>
<h2><a name="typedef-members"></a>
Typedefs</h2>
<ul>
<li><a class="anchor" id="a905abe294d4c6f82f5817a479352601f"></a><!-- doxytag: member="apop_data.c::apop_fn_ir" ref="a905abe294d4c6f82f5817a479352601f" args=")(apop_data *, void *)" -->
typedef int(* <b>apop_fn_ir</b> )(<a class="el" href="structapop__data.html">apop_data</a> *, void *)
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> (const size_t size1, const size_t size2, const int size3)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> (const size_t size1, const size_t size2, const int size3)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> (gsl_matrix *m)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> (gsl_vector *v)
<li>void <a class="el" href="apop__data_8c.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> (char ***freeme, int rows, int cols)
<li>char <a class="el" href="apop__data_8c.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *freeme)
<li>void <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> (<a class="el" href="structapop__data.html">apop_data</a> *out, const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> (<a class="el" href="structapop__data.html">apop_data</a> *m1, <a class="el" href="structapop__data.html">apop_data</a> *m2, char posn, char inplace)
<li><a class="el" href="structapop__data.html">apop_data</a> ** <a class="el" href="apop__data_8c.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int splitpoint, char r_or_c)
<li>void <a class="el" href="apop__data_8c.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int *drop)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char **colnames)
<li>double * <a class="el" href="group__data__set__get.html#ga59d1c0299c7eb87224bc6c60555784fe">apop_data_ptr</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int row, int col, const char *rowname, const char *colname, const char *page)
<li>double <a class="el" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, size_t row, int col, const char *rowname, const char *colname, const char *page)
<li><a class="anchor" id="ga39d2e5893f1631a7a1ef2d06f3925fe6"></a><!-- doxytag: member="apop_data.c::apop_gsl_error_for_set" ref="ga39d2e5893f1631a7a1ef2d06f3925fe6" args="(const char *reason, const char *file, int line, int gsl_errno)" -->
void <b>apop_gsl_error_for_set</b> (const char *reason, const char *file, int line, int gsl_errno)
<li>int <a class="el" href="group__data__set__get.html#gaea55629952c595bc8211d3333077dc51">apop_data_set</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, size_t row, int col, const double val, const char *colname, const char *rowname, const char *page)
<li>int <a class="el" href="apop__data_8c.html#a5acc9328f9c043be4cd6c12f57509df1">apop_data_set_row</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__data.html">apop_data</a> *row, int row_number)
<li>void <a class="el" href="apop__data_8c.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char *name, double val)
<li><a class="anchor" id="a1b050ee3cfbb8858576bca6ae07571df"></a><!-- doxytag: member="apop_data.c::apop_data_add_names_base" ref="a1b050ee3cfbb8858576bca6ae07571df" args="(apop_data *d, const char type, char const **names)" -->
void <b>apop_data_add_names_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, const char type, char const **names)
<li>int <a class="el" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col, const char *fmt,...)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char transpose_text, char inplace)
<li>gsl_matrix * <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> (gsl_matrix *m, size_t newheight, size_t newwidth)
<li>gsl_vector * <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> (gsl_vector *v, size_t newheight)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char match)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *dataset, <a class="el" href="structapop__data.html">apop_data</a> *newpage, const char *title)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char free_p)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop__data_8c.html#ad6b6774d5ec4b12f0023e3afff7ccb65">apop_data_rm_rows</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int *drop, apop_fn_ir do_drop, void *drop_parameter)
</ul>
<h2><a name="var-members"></a>
Variables</h2>
<ul>
<li><a class="anchor" id="a201b1c20fa5fc477ace17b83e559cc7c"></a><!-- doxytag: member="apop_data.c::apop_nul_string" ref="a201b1c20fa5fc477ace17b83e559cc7c" args="" -->
char * <b>apop_nul_string</b> = &quot;&quot;
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="structapop__data.html">apop_data</a> structure joins together a gsl_matrix, <a class="el" href="structapop__name.html">apop_name</a>, and a table of strings. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a44b767b375fb18f61f939c6869955331"></a><!-- doxytag: member="apop_data.c::apop_data_add_named_elmt" ref="a44b767b375fb18f61f939c6869955331" args="(apop_data *d, char *name, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to add a named element to a data set. Many of Apophenia's testing procedures use this to easily produce a column of named parameters. It is public as a convenience.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure. Must not be <code>NULL</code>, but may be blank (as per allocation via <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> <code>( )</code> ). </td></tr>
    <tr><td class="paramname">name</td><td>The name to add </td></tr>
    <tr><td class="paramname">val</td><td>the value to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>I use the position of the last non-empty row name to know where to put the value. If there are two names in the data set, then I will put the new name in the third name slot and the data in the third slot in the vector. If you use this function from start to finish in building your list, then you'll be fine. </li>
<li>If the vector is too short (or <code>NULL</code>), I will call <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> internally to make space. </li>
<li>This fits well with the defaults for <a class="el" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>. An example:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *list = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>();
<a class="code" href="apop_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a>(list, <span class="stringliteral">&quot;height&quot;</span>, 165);
<a class="code" href="apop_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a>(list, <span class="stringliteral">&quot;weight&quot;</span>, 60);

<span class="keywordtype">double</span> height = <a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(list, .rowname=<span class="stringliteral">&quot;height&quot;</span>);
</pre></div> 
</div>
</div>
<a class="anchor" id="a7e7e530a692571a403e5837fda5e0f12"></a><!-- doxytag: member="apop_data.c::apop_data_add_page" ref="a7e7e530a692571a403e5837fda5e0f12" args="(apop_data *dataset, apop_data *newpage, const char *title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>newpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a page to a <a class="el" href="gentle.html#apop_data">apop_data</a> set. It gets a name so you can find it later.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>The input data set, to which a page will be added. </td></tr>
    <tr><td class="paramname">newpage</td><td>The page to append </td></tr>
    <tr><td class="paramname">title</td><td>The name of the new page. Remember, this is truncated at 100 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new page. I post a warning if I am appending or appending to a <code>NULL</code> data set and <code>apop_opts.verbose &gt;=1 </code>.</dd></dl>
<ul>
<li>Some data is fundamentally multi-page; an optimization search over multi-page parameters would search the space given by all pages, for example. Also, pages may be appended as output or auxiliary information, such as covariances---an MLE would not search over these elements. Generally, any page with a name in XML-ish brackets, such as <code>&lt;Covariance&gt;</code>, will be considered informational and ignored by search routines, missing data routines, et cetera. This is achieved by a rule in <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> and <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a>.</li>
</ul>
<p>Here is a toy example that establishes a baseline data set, adds a page, modifies it, and then later retrieves it. </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(10, 10, 10); <span class="comment">//the base data set.</span>
  <a class="code" href="structapop__data.html">apop_data</a> *a_new_page = <a class="code" href="apop_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a>(d, <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2), <span class="stringliteral">&quot;new 2 x 2 page&quot;</span>);
  gsl_vector_set_all(a_new_page-&gt;matrix, 3);

  <span class="comment">//later:</span>
  <a class="code" href="structapop__data.html">apop_data</a> *retrieved = <a class="code" href="apop_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(d, <span class="stringliteral">&quot;new&quot;</span>, <span class="charliteral">&#39;r&#39;</span>); <span class="comment">//use regexes, not literal match.</span>
  <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(retrieved); <span class="comment">//print a 2x2 grid of 3s.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ac39d6a56933b6f084328ec5ecd5090d8"></a><!-- doxytag: member="apop_data.c::apop_data_alloc" ref="ac39d6a56933b6f084328ec5ecd5090d8" args="(const size_t size1, const size_t size2, const int size3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data.</p>
<ul>
<li>The typical case is three arguments, like <code>apop_data_alloc(2,3,4)</code>: vector size, matrix rows, matrix cols. If the first argument is zero, you get a <code>NULL</code> vector. </li>
<li>Two arguments, <code>apop_data_alloc(2,3)</code>, would allocate just a matrix, leaving the vector <code>NULL</code>. </li>
<li>One argument, <code>apop_data_alloc(2)</code>, would allocate just a vector, leaving the matrix <code>NULL</code>. </li>
<li>Zero arguments, <code><a class="el" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, will produce a basically blank set, with <code>out-&gt;matrix==out-&gt;vector==NULL</code>.</li>
</ul>
<p>For allocating the text part, see <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>.</p>
<p>The <code>weights</code> vector is set to <code>NULL</code>. If you need it, allocate it via </p>
<div class="fragment"><pre class="fragment"> d-&gt;weights   = gsl_vector_alloc(row_ct); 
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__data_8c.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and ready. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. The matrix, vector, or names couldn't be <code>malloc</code>ed, which probably means that you requested a very large data set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An <a class="el" href="gentle.html#apop_data">apop_data</a> struct, by itself, is about 72 bytes. If I can't allocate that much memory, I return <code>NULL</code>. But if even this much fails, your computer may be on fire and you should go put it out.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0460790f2d21f03856ed4a212a4132ec"></a><!-- doxytag: member="apop_data.c::apop_data_calloc" ref="a0460790f2d21f03856ed4a212a4132ec" args="(const size_t size1, const size_t size2, const int size3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data; set everything in the allocated portion to zero. See <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> for details.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and zeroed out. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='m'</td><td>malloc error; probably out of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a></dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="add67e6838ce2521a1d756894dc9b5ccf"></a><!-- doxytag: member="apop_data.c::apop_data_copy" ref="add67e6838ce2521a1d756894dc9b5ccf" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data is duplicated.</p>
<p>Basically a front-end for <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> for those who prefer this sort of syntax.</p>
<p>Unlike <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>, I do follow the <code>more</code> pointer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill. If input is NULL, then this will be NULL.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out.error='c'</td><td>Cyclic link: <code>D-&gt;more == D</code> (may be later in the chain, e.g., <code>D-&gt;more-&gt;more = D-&gt;more</code>) You'll have only a partial copy. </td></tr>
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; should never happen. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Missing part error; should never happen. <ul>
<li>If the input data set has an error, then I will copy it anyway, including the error flag (which might be overwritten). I print a warning if the verbosity level is <code>&gt;=1</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8377359d46c9bd02ea57205e7968d3"></a><!-- doxytag: member="apop_data.c::apop_data_free_base" ref="a3e8377359d46c9bd02ea57205e7968d3" args="(apop_data *freeme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="apop__data_8c.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>freeme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free the elements of the given <a class="el" href="gentle.html#apop_data">apop_data</a> set and then the <a class="el" href="gentle.html#apop_data">apop_data</a> set itself. Intended to be used by <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>, a macro that calls this to free elements, then sets the value to <code>NULL</code>.</p>
<ul>
<li><a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> is a macro that calls this function and, on success, sets the input pointer to <code>NULL</code>. For typical cases, that's slightly more useful than this function.</li>
</ul>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">freeme.error='c'</td><td>Circular linking is against the rules. If <code>freeme-&gt;more == freeme</code>, then I set <code>freeme.error='c'</code> and return. If you send in a structure like A -&gt; B -&gt; B, then both data sets A and B will be marked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0</code> on OK, <code>'c'</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a044771db76f0afb410a8d4f05ac51ca3"></a><!-- doxytag: member="apop_data.c::apop_data_get_page" ref="a044771db76f0afb410a8d4f05ac51ca3" args="(const apop_data *data, const char *title, const char match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It's good form to get a page from your data set by name, because you may not know the order for the pages, and the stepping through makes for dull code anyway (<code><a class="el" href="structapop__data.html">apop_data</a> *page = dataset; while (page-&gt;more) page= page-&gt;more;</code>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set to use. No default; if <code>NULL</code>, gives a warning if <code>apop_opts.verbose &gt;=1</code> and returns <code>NULL</code>.</td></tr>
    <tr><td class="paramname">title</td><td>The name of the page to retrieve. Default=<code>"Info"</code>, which is the name of the page of additional estimation information returned by estimation routines (log likelihood, status, AIC, BIC, confidence intervals, ...).</td></tr>
    <tr><td class="paramname">match</td><td>If <code>'c'</code>, case-insensitive match (via <code>strcasecmp</code>); if <code>'e'</code>, exact match, if <code>'r'</code> regular expression substring search (via <a class="el" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>). Default=<code>'c'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The page whose title matches what you gave me. If I don't find a match, return <code>NULL</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa24d396c7fda38bc4ab03a3ba2db4943"></a><!-- doxytag: member="apop_data.c::apop_data_memcpy" ref="aa24d396c7fda38bc4ab03a3ba2db4943" args="(apop_data *out, const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another.</p>
<p>This function does not allocate the output structure or the vector, matrix, text, or weights elements---I assume you have already done this and got the dimensions right. I will assert that there is at least enough room in the destination for your data, and fail if the copy would write more elements than there are bins.</p>
<ul>
<li>If you want space allocated or are unsure about dimensions, use <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>. </li>
<li>If both <code>in</code> and <code>out</code> have a <code>more</code> pointer, also copy subsequent page(s). </li>
<li>You can use the subsetting macros, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> or <a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, to copy within a data set:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="comment">//Copy the contents of row i of mydata to row j.</span>
<a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(mydata, i, fromrow);
<a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(mydata, j, torow);
<a class="code" href="apop_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>(torow, fromrow);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A structure that this function will fill. Must be preallocated with the appropriate sizes. </td></tr>
    <tr><td class="paramname">in</td><td>The input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; couldn't copy. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Part missing; e.g., in-&gt;matrix exists but out-&gt;matrix doesn't; couldn't copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1efbe058d6ca85ece023eb471c66e58"></a><!-- doxytag: member="apop_data.c::apop_data_prune_columns_base" ref="ad1efbe058d6ca85ece023eb471c66e58" args="(apop_data *d, char **colnames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>colnames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep only the columns of a data set that you name. This is the function called internally by the <a class="el" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a> macro. In most cases, you'll want to use that macro. An example of the two uses demonstrating the difference:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(d, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);

    <span class="keywordtype">char</span> *list[] = {<span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>, NULL};
    <a class="code" href="apop_8h.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a>(d, list);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">colnames</td><td>A null-terminated list of names to retain (i.e. the columns that shouldn't be pruned out). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the input data set, now pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="a1312f6568cfe832f1e35f7f44482ffb4"></a><!-- doxytag: member="apop_data.c::apop_data_rm_columns" ref="a1312f6568cfe832f1e35f7f44482ffb4" args="(apop_data *d, int *drop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the columns set to one in the <code>drop</code> vector. The returned data structure looks like it was modified in place, but the data matrix and the names are duplicated before being pared down, so if your data is taking up more than half of your memory, this may not work.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down. </td></tr>
    <tr><td class="paramname">drop</td><td>an array of ints. If use[7]==1, then column seven will be cut from the output. A reminder: <code>calloc(in-&gt;size2 , sizeof(int))</code> will fill your array with zeros on allocation, and <code>memset(use, 1, in-&gt;size2 * sizeof(int))</code> will quickly fill an array of ints with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac434c9d08b6a8304107d9c93afb81914"></a><!-- doxytag: member="apop_data.c::apop_data_rm_page" ref="ac434c9d08b6a8304107d9c93afb81914" args="(apop_data *data, const char *title, const char free_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>free_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first page from an <a class="el" href="gentle.html#apop_data">apop_data</a> set that matches a given name.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data set, to which a page will be added. No default. If <code>NULL</code>, I return silently if <code> apop_opts.verbose &lt; 1 </code>; print an error otherwise. </td></tr>
    <tr><td class="paramname">title</td><td>The case-insensitive name of the page to remove. Default: <code>"Info"</code> </td></tr>
    <tr><td class="paramname">free_p</td><td>If <code>'y'</code>, then <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> the page. Default: <code>'y'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If not freed, a pointer to the <code><a class="el" href="structapop__data.html">apop_data</a></code> page that I just pulled out. Thus, you can use this to pull a single page from a data set. I set that page's <code>more</code> pointer to <code>NULL</code>, to minimize any confusion about more-than-linear linked list topologies. If <code>free_p=='y'</code> (the default) or the page is not found, return <code>NULL</code>.</dd></dl>
<ul>
<li>I don't check the first page, so there's no concern that the head of your list of pages will move. Again, the intent of the <code>-&gt;more</code> pointer in the <a class="el" href="gentle.html#apop_data">apop_data</a> set is not to fully implement a linked list, but primarily to allow you to staple auxiliary information to a main data set.</li>
</ul>
<ul>
<li>If I don't find the page you want, I return NULL, and print a message if <code>apop_opts.verbose &gt;= 1</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad6b6774d5ec4b12f0023e3afff7ccb65"></a><!-- doxytag: member="apop_data.c::apop_data_rm_rows" ref="ad6b6774d5ec4b12f0023e3afff7ccb65" args="(apop_data *in, int *drop, apop_fn_ir do_drop, void *drop_parameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ad6b6774d5ec4b12f0023e3afff7ccb65">apop_data_rm_rows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ir&#160;</td>
          <td class="paramname"><em>do_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drop_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the rows set to one in the <code>drop</code> vector or for which the <code>do_drop</code> function returns one. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down </td></tr>
    <tr><td class="paramname">drop</td><td>a vector with as many elements as the max of the vector, matrix, or text parts of <code>in</code>, with a one marking those columns to be removed. </td></tr>
    <tr><td class="paramname">do_drop</td><td>A function that returns one for rows to drop and zero for rows to not drop. A sample function: <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> your_drop_function(<a class="code" href="structapop__data.html">apop_data</a> *onerow, <span class="keywordtype">void</span> *extra_param){
    <span class="keywordflow">return</span> gsl_isnan(<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(onerow)) || !strcmp(onerow-&gt;text[0][0], <span class="stringliteral">&quot;Uninteresting data point&quot;</span>);
  }
</pre></div> <a class="el" href="apop__data_8c.html#ad6b6774d5ec4b12f0023e3afff7ccb65">apop_data_rm_rows</a> uses <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to get a subview of the input data set of height one (and since all the default arguments default to zero, you don't have to write out things like <a class="el" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a> <code>(onerow, .row=0, .col=0)</code>, which can help to keep things readable). </td></tr>
    <tr><td class="paramname">drop_parameter</td><td>If your <code>do_drop</code> function requires additional input, put it here and it will be passed through.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the input data set, now pruned.</dd></dl>
<ul>
<li>If all the rows are to be removed, then you will wind up with the same <a class="el" href="gentle.html#apop_data">apop_data</a> set, with <code>NULL</code> <code>vector</code>, <code>matrix</code>, <code>weight</code>, and text. Therefore, you may wish to check for <code>NULL</code> elements after use. I remove rownames, but leave the other names, in case you want to add new data rows.</li>
</ul>
<ul>
<li>The typical use is to provide only a list or only a function. If both are <code>NULL</code>, I return without doing anything, and print a warning if <code>apop_opts.verbose &gt;=1</code>. If you provide both, I will drop the row if either the vector has a one in that row's position, or if the function returns a nonzero value. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5acc9328f9c043be4cd6c12f57509df1"></a><!-- doxytag: member="apop_data.c::apop_data_set_row" ref="a5acc9328f9c043be4cd6c12f57509df1" args="(apop_data *d, apop_data *row, int row_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__data_8c.html#a5acc9328f9c043be4cd6c12f57509df1">apop_data_set_row</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Now that you've used <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to pull a row from an <a class="el" href="gentle.html#apop_data">apop_data</a> set, this function lets you write that row to another position in the same data set or a different data set entirely.</p>
<p>The set written to must have the same form as the original: </p>
<ul>
<li>a vector element has to be present if one existed in the original, </li>
<li>same for the weights vector, </li>
<li>the matrix in the destination has to have as many columns as in the original, and </li>
<li>the text has to have a row long enough to hold the original </li>
<li>If the row to be written to already has a rowname, it is overwritten. If <code>d-&gt;names-&gt;rowct == row_number</code> (all rows up to <code>row_number</code> have row names), then extend the list of row names by one to add the new name. Else, don't add the row name. </li>
<li>Column names (of all types) aren't touched. Maybe use <code>apop_data_copy</code> or <code>apop_name_copy</code> if you need to copy these names.</li>
</ul>
<p>If any of the source elements are <code>NULL</code>, I won't bother to check that element in the destination.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0=OK, -1=error (probably a source/destination size mismatch).</dd></dl>
<ul>
<li>The error codes for out-of-bounds errors are thread-safe iff you are have a C11-compliant compiler (thanks to the <code>_Thread_local</code> keyword) or a version of GCC with the <code>__thread</code> extension enabled. </li>
</ul>

</div>
</div>
<a class="anchor" id="aef0284036801cb75d465a1738f65397e"></a><!-- doxytag: member="apop_data.c::apop_data_split" ref="aef0284036801cb75d465a1738f65397e" args="(apop_data *in, int splitpoint, char r_or_c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>** <a class="el" href="apop__data_8c.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>r_or_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Split one input <a class="el" href="gentle.html#apop_data">apop_data</a> structure into two.</p>
<p>For the opposite operation, see <a class="el" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure to split </td></tr>
    <tr><td class="paramname">splitpoint</td><td>The index of what will be the first row/column of the second data set. E.g., if this is -1 and <code>r_or_c=='c'</code>, then the whole data set will be in the second data set; if this is the length of the matrix then the whole data set will be in the first data set. Another way to put it is that <code>splitpoint</code> will equal the number of rows/columns in the first matrix (unless it is -1, in which case the first matrix will have zero rows, or it is greater than the matrix's size, in which case it will have as many rows as the original). </td></tr>
    <tr><td class="paramname">r_or_c</td><td>If this is 'r' or 'R', then put some rows in the first data set and some in the second; of 'c' or 'C', split columns into first and second data sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of two <a class="el" href="gentle.html#apop_data">apop_data</a> sets. If one is empty then a <code>NULL</code> pointer will be returned in that position. For example, for a data set of 50 rows, <code><a class="el" href="structapop__data.html">apop_data</a> **out = apop_data_split(data, 100, 'r')</code> sets <code>out[0] = apop_data_copy(data)</code> and <code>out[1] = NULL</code>.</dd></dl>
<ul>
<li>When splitting at a row, the text is also split. </li>
<li><code>more</code> pointer is ignored. </li>
<li>The <code>apop_data-&gt;vector</code> is taken to be the -1st element of the matrix. </li>
<li>Weights will be preserved. If splitting by rows, then the top and bottom parts of the weights vector will be assigned to the top and bottom parts of the main data set. If splitting by columns, identical copies of the weights vector will be assigned to both parts. </li>
<li>Data is copied, so you may want to call <code><a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free(in)</a></code> after this. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2ffb5c5ba2bb240e930be08fc4fd56"></a><!-- doxytag: member="apop_data.c::apop_data_stack" ref="a0f2ffb5c5ba2bb240e930be08fc4fd56" args="(apop_data *m1, apop_data *m2, char posn, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first data set either on top of or to the left of the second data set.</p>
<p>The fn returns a new data set, meaning that at the end of this function, until you <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free()</a> the original data sets, you will be taking up twice as much memory. Plan accordingly.</p>
<p>For the opposite operation, see <a class="el" href="apop__data_8c.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">posn</td><td>If 'r', stack rows of m1's matrix above rows of m2's<br/>
 if 'c', stack columns of m1's matrix to left of m2's<br/>
 (default = 'r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, use <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> and <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>m1</code> in place; see the caveats on those function. Otherwise, allocate a new vector, leaving <code>m1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stacked data, either in a new <a class="el" href="gentle.html#apop_data">apop_data</a> set or <code>m1</code> </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Dimension error; couldn't make a complete copy.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If m1 or m2 are NULL, this returns a copy of the other element, and if both are NULL, you get NULL back (except if <code>m2</code> is <code>NULL</code> and <code>inplace</code> is <code>'y'</code>, where you'll get the original <code>m1</code> pointer back) </li>
<li>Text is handled as you'd expect: If 'r', one set of text is stacked on top of the other [number of columns must match]; if 'c', one set of text is set next to the other [number of rows must match]. </li>
<li><code>more</code> is ignored. </li>
<li>If stacking rows on rows, the output vector is the input vectors stacked accordingly. If stacking columns by columns, the output vector is just a copy of the vector of m1 and m2-&gt;vector doesn't appear in the output at all. </li>
<li>The same rules for dealing with the vector(s) hold for the vector(s) of weights. </li>
<li>Names are a copy of the names for <code>m1</code>, with the names for <code>m2</code> appended to the row or column list, as appropriate. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a82281b8673cda3645054d7e061bb1167"></a><!-- doxytag: member="apop_data.c::apop_data_transpose" ref="a82281b8673cda3645054d7e061bb1167" args="(apop_data *in, char transpose_text, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transpose_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transpose the matrix and text elements of the input data set, including the row/column names.</p>
<p>The vector and weights elements of the input data set are completely ignored (but see also <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>, which can convert a vector to a 1 X N matrix.) If copying, these other elements won't be present; if <code>.inplace='y'</code>, it is up to you to handle these not-transposed elements correctly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input <a class="el" href="gentle.html#apop_data">apop_data</a> set. If <code>NULL</code>, I return <code>NULL</code>. Default is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">transpose_text</td><td>If <code>'y'</code>, then also transpose the text element. Default is <code>'y'</code>. </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, transpose the input in place; if <code>'n'</code>, produce a transposed copy, leaving the original untouched. Due to how <code>gsl_matrix_transpose_memcpy</code> works, a copy will still be made, then copied to the original location. Default is <code>'y'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>inplace=='n'</code>, a newly alloced <a class="el" href="gentle.html#apop_data">apop_data</a> set, with the appropriately transposed matrix and/or text. The vector and weights elements will be <code>NULL</code>. If <code>transpose_text='n'</code>, then the text element of the output set will also be <code>NULL</code>.<br/>
 if <code>inplace=='y'</code>, a pointer to the original data set, with matrix and (if <code>transpose_text='y'</code>) text transposed and vector and weights left in place untouched.</dd></dl>
<ul>
<li>Row names are written to column names of the output matrix, text, or both (whichever is not empty in the input). </li>
<li>If only the matrix or only the text have names, then the one set of names is written to the row names of the output. </li>
<li>If both matrix column names and text column names are present, text column names are lost. </li>
<li>if you have a <code>gsl_matrix</code> with no names or text, you may prefer to use <code>gsl_matrix_transpose_memcpy</code>.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa06b6ab6ec9f78f305b1dacc8ec2efd3"></a><!-- doxytag: member="apop_data.c::apop_matrix_realloc" ref="aa06b6ab6ec9f78f305b1dacc8ec2efd3" args="(gsl_matrix *m, size_t newheight, size_t newwidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will resize a <code>gsl_matrix</code> to a new height or width.</p>
<p>Data in the matrix will be retained. If the new height or width is smaller than the old, then data in the later rows/columns will be cropped away (in a non--memory-leaking manner). If the new height or width is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill new rows/columns before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form---especially when used in a <code>for</code> loop that adds a column each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_matrix</code> is a versatile struct that can represent submatrices and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The already-allocated matrix to resize. If you give me <code>NULL</code>, this becomes equivalent to <code>gsl_matrix_alloc</code> </td></tr>
    <tr><td class="paramname">newheight,newwidth</td><td>The height and width you'd like the matrix to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>m, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="ac0674dcc81232e37c27f612499495bd4"></a><!-- doxytag: member="apop_data.c::apop_matrix_to_data" ref="ac0674dcc81232e37c27f612499495bd4" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deprecated; please do not use. Just use a compound literal:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Given:</span>
gsl_vector *v;
gsl_matrix *m;

<span class="comment">// Then this form wraps the elements into \ref apop_data structs. Note that</span>
<span class="comment">// these are not pointers: they&#39;re automatically allocated and therefore</span>
<span class="comment">// the extra memory use for the wrapper is cleaned up on exit from scope.</span>

<a class="code" href="structapop__data.html">apop_data</a> *dv = &amp;(<a class="code" href="apop_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.vector=v};
<a class="code" href="structapop__data.html">apop_data</a> *dm = &amp;(<a class="code" href="apop_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.matrix=m};

<a class="code" href="structapop__data.html">apop_data</a> *v_dot_m = <a class="code" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(dv, dm);

<span class="comment">//Here is a macro to hide C&#39;s ugliness:</span>
<span class="preprocessor">#define As_data(...) (&amp;(apop_data){__VA_ARGS__})</span>
<span class="preprocessor"></span>
<a class="code" href="structapop__data.html">apop_data</a> *v_dot_m2 = <a class="code" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(As_data(.vector=v), As_data(.matrix=m));

<span class="comment">//The wrapped object is an automatically-allocated structure pointing to the</span>
<span class="comment">//original data. If it needs to persist or be separate from the original,</span>
<span class="comment">//make a copy:</span>
<a class="code" href="structapop__data.html">apop_data</a> *dm_copy = <a class="code" href="apop_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(As_data(.vector=v, .matrix=m));
</pre></div> 
</div>
</div>
<a class="anchor" id="ac9c6f645acce82319fb85eb9d75112ba"></a><!-- doxytag: member="apop_data.c::apop_text_add" ref="ac9c6f645acce82319fb85eb9d75112ba" args="(apop_data *in, const size_t row, const size_t col, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a string to the text element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you send me a <code>NULL</code> string, I will write the value of <code>apop_opts.nan_string</code> in the given slot. If there is already something in that slot, that string is freed, preventing memory leaks.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set, that already has an allocated <code>text</code> element. </td></tr>
    <tr><td class="paramname">row</td><td>The row </td></tr>
    <tr><td class="paramname">col</td><td>The col </td></tr>
    <tr><td class="paramname">fmt</td><td>The text to write. </td></tr>
    <tr><td class="paramname">...</td><td>You can use a printf-style fmt and follow it with the usual variables to fill in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0=OK, -1=error (probably out-of-bounds)</dd></dl>
<ul>
<li>UTF-8 or ASCII text is correctly handled. </li>
<li>Apophenia follows a general rule of not reallocating behind your back: if your text matrix is currently of size (3,3) and you try to put an item in slot (4,4), then I display an error rather than reallocating the text matrix. </li>
<li>Resizing a text matrix is annoying in C, so note that <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> will reallocate to a new size if you need. For example, this code will fill the diagonals of the text array with a message, resizing as it goes: </li>
<li>The string added is a copy (via <code>asprintf</code>), not a pointer to the input(s). </li>
<li>If there had been a string at the grid point you are writing to, the old one is effectively lost when the new one is placed. So, I free the old string to prevent leaks if necessary. Remember this if you had other pointers aliasing that string, in which case you may as well avoid this function and just use <code> asprintf(&amp;(your_dataset-&gt;text[row][col]), "your string")</code>.</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *list = (something already allocated.);
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n &lt; 10; n++){
    <a class="code" href="apop_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(list, n+1, n+1);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(list, n, n, <span class="stringliteral">&quot;This is cell (%i, %i)&quot;</span>, n, n);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a9fba0f07c262a433133f6f3362617da3"></a><!-- doxytag: member="apop_data.c::apop_text_alloc" ref="a9fba0f07c262a433133f6f3362617da3" args="(apop_data *in, const size_t row, const size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This allocates an array of strings and puts it in the <code>text</code> element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>If the <code>text</code> element already exists, then this is effectively a <code>realloc</code> function, reshaping to the size you specify.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. It's OK to send in <code>NULL</code>, in which case an <a class="el" href="structapop__data.html">apop_data</a> set with <code>NULL</code> <code>matrix</code> and <code>vector</code> elements is returned. </td></tr>
    <tr><td class="paramname">row</td><td>the number of rows of text. </td></tr>
    <tr><td class="paramname">col</td><td>the number of columns of text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the relevant <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the input was not <code>NULL</code>, then this is a repeat of the input pointer. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65386d7b37c2eaf37d1eb4e3ae7a7554"></a><!-- doxytag: member="apop_data.c::apop_text_free" ref="a65386d7b37c2eaf37d1eb4e3ae7a7554" args="(char ***freeme, int rows, int cols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> </td>
          <td>(</td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>freeme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free a matrix of chars* (i.e., a char***). This is the form of the text element of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, so you can use this for: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="apop_8h.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a>(yourdata-&gt;text, yourdata-&gt;textsize[0], yourdata-&gt;textsize[1]);
</pre></div><p> This is what <code>apop_data_free</code> uses internally. </p>

</div>
</div>
<a class="anchor" id="af4658a3ecc0acfd17f610bc162fa5556"></a><!-- doxytag: member="apop_data.c::apop_vector_realloc" ref="af4658a3ecc0acfd17f610bc162fa5556" args="(gsl_vector *v, size_t newheight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will resize a <code>gsl_vector</code> to a new length.</p>
<p>Data in the vector will be retained. If the new height is smaller than the old, then data at the end of the vector will be cropped away (in a non--memory-leaking manner). If the new height is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill them before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form---especially when used in a <code>for</code> loop that adds an element each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_vector</code> is a versatile struct that can represent subvectors, matrix columns and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The already-allocated vector to resize. If you give me <code>NULL</code>, this is equivalent to <code>gsl_vector_alloc</code> </td></tr>
    <tr><td class="paramname">newheight</td><td>The height you'd like the vector to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>v, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="a4a69e915d2b6c40f9c69ec1842e2d689"></a><!-- doxytag: member="apop_data.c::apop_vector_to_data" ref="a4a69e915d2b6c40f9c69ec1842e2d689" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deprecated; please do not use. Just use a compound literal, as in the code sample in the documentation for <a class="el" href="apop__data_8c.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a>. </p>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Tue Aug 5 2014.</div></body></html>

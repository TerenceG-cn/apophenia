<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
     <title>Apophenia: a library for scientific computing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
     <link rel="stylesheet" href="typical.css" type="text/css" >
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="typical.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<center><table cellpadding=10pt>
<tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td>
<td><table>
    <tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
    <tr><td><div class="qindex"> <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="group__all__public.html">Index </a>  |         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
                <!-- <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
                                  </td></tr></table></center>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__all__public.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Public functions, structs, and types</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__arms__settings.html">apop_arms_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__cdf__settings.html">apop_cdf_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__composition__settings.html">apop_composition_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__cross__settings.html">apop_cross_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__ct__settings.html">apop_ct_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__data.html">apop_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__dconstrain__settings.html">apop_dconstrain_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__kernel__density__settings.html">apop_kernel_density_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__lm__settings.html">apop_lm_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__loess__settings.html">apop_loess_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__mcmc__proposal__s.html">apop_mcmc_proposal_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__mixture__settings.html">apop_mixture_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__mle__settings.html">apop_mle_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__model.html">apop_model</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__name.html">apop_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__opts__type.html">apop_opts_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__parts__wanted__settings.html">apop_parts_wanted_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__pm__settings.html">apop_pm_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__pmf__settings.html">apop_pmf_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__settings__type.html">apop_settings_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloess__struct.html">loess_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf1210155d44e962846822abfef413fbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1210155d44e962846822abfef413fbb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_ANOVA</b></td></tr>
<tr class="separator:gaf1210155d44e962846822abfef413fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadabbf2a1717d5c76a834e090ddfcfeaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>(d,  col)</td></tr>
<tr class="separator:gadabbf2a1717d5c76a834e090ddfcfeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf15101ec60ce66e80737375baa7391"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>(d,  colname,  outd)</td></tr>
<tr class="separator:gaaaf15101ec60ce66e80737375baa7391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56ce572c7489820777290153ab7d87b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>(m,  col,  v)</td></tr>
<tr class="separator:gad56ce572c7489820777290153ab7d87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc073d46416446dc4f0cdb9e4f1b9a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafc073d46416446dc4f0cdb9e4f1b9a03">Apop_cs</a>(d,  colnum,  len)</td></tr>
<tr class="separator:gafc073d46416446dc4f0cdb9e4f1b9a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825321182fbaa7471069f13447170810"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>(data_to_view,  col)</td></tr>
<tr class="separator:ga825321182fbaa7471069f13447170810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca6159c82c21da0db82ae9ed0582dc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(dataset,  type, ...)</td></tr>
<tr class="separator:gaeca6159c82c21da0db82ae9ed0582dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6b2c53478f9db902ba0340ba499819"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>(sizes, ...)</td></tr>
<tr class="separator:gacb6b2c53478f9db902ba0340ba499819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6be56d710a63aa1ceadf2242c553905"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(adfin, ...)</td></tr>
<tr class="separator:gad6be56d710a63aa1ceadf2242c553905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459acfde11f2c39f5c32cff377f85b9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(freeme)</td></tr>
<tr class="separator:ga459acfde11f2c39f5c32cff377f85b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea849ee3c044e95eafb7b79124ce844"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(in, ...)</td></tr>
<tr class="separator:ga5ea849ee3c044e95eafb7b79124ce844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b522120f0e4d4533bf180e1fde1ee39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b522120f0e4d4533bf180e1fde1ee39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_errorlevel</b></td></tr>
<tr class="separator:ga6b522120f0e4d4533bf180e1fde1ee39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c353f768fb4b0e7a3f98ab7a546ba5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga33c353f768fb4b0e7a3f98ab7a546ba5">apop_estimate_r_squared</a>(in)</td></tr>
<tr class="separator:ga33c353f768fb4b0e7a3f98ab7a546ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb7cd4412e9fca67bb14aa22662aaa65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb7cd4412e9fca67bb14aa22662aaa65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_F_distribution</b></td></tr>
<tr class="separator:gadb7cd4412e9fca67bb14aa22662aaa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6aa069a742d2480040cfdaa79b2bc54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6aa069a742d2480040cfdaa79b2bc54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_F_test</b></td></tr>
<tr class="separator:gae6aa069a742d2480040cfdaa79b2bc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdfc523f5b269827db8cebf28216e28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gabbdfc523f5b269827db8cebf28216e28">apop_gaussian</a></td></tr>
<tr class="separator:gabbdfc523f5b269827db8cebf28216e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1281c546207c8e27e4c8a9239ec3f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf1281c546207c8e27e4c8a9239ec3f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_IV</b></td></tr>
<tr class="separator:gaaf1281c546207c8e27e4c8a9239ec3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b5994e799d38ad44d646d7a457f42d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79b5994e799d38ad44d646d7a457f42d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_line_to_vector</b></td></tr>
<tr class="separator:ga79b5994e799d38ad44d646d7a457f42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7f99e26eb4d5d5438fd5fa16fcadde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>(m,  col,  v)</td></tr>
<tr class="separator:ga3e7f99e26eb4d5d5438fd5fa16fcadde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51cb56786000f7dbd82fbeeae47ac60c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51cb56786000f7dbd82fbeeae47ac60c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>APOP_MATRIX_COL</b></td></tr>
<tr class="separator:ga51cb56786000f7dbd82fbeeae47ac60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b451a0240fbebdd7a95547269c2bde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23b451a0240fbebdd7a95547269c2bde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_matrix_col</b></td></tr>
<tr class="separator:ga23b451a0240fbebdd7a95547269c2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abee86763f92d505fd4fb792f06fd7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>(m,  row,  v)</td></tr>
<tr class="separator:ga9abee86763f92d505fd4fb792f06fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a70a9fff4f3a0efedb583066e6caac9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a70a9fff4f3a0efedb583066e6caac9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>APOP_MATRIX_ROW</b></td></tr>
<tr class="separator:ga8a70a9fff4f3a0efedb583066e6caac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d0f6f694fdca12dd10bc2fee643609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8d0f6f694fdca12dd10bc2fee643609"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_matrix_row</b></td></tr>
<tr class="separator:gad8d0f6f694fdca12dd10bc2fee643609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e17aea4a8d6dbd5c1208dfe9730415"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2e17aea4a8d6dbd5c1208dfe9730415"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_maybe_abort</b>(level)</td></tr>
<tr class="separator:gad2e17aea4a8d6dbd5c1208dfe9730415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0289d499a3dfa51a0c6fc689505cb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga7b0289d499a3dfa51a0c6fc689505cb5">apop_mean</a></td></tr>
<tr class="separator:ga7b0289d499a3dfa51a0c6fc689505cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6667ffc981f0b56c7d6c6e7f01572d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a6667ffc981f0b56c7d6c6e7f01572d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_ml_imputation</b>(d,  m)</td></tr>
<tr class="separator:ga2a6667ffc981f0b56c7d6c6e7f01572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d9e73643bf66f7d69c7ebf959757aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga15d9e73643bf66f7d69c7ebf959757aa">apop_model_coordinate_transform</a>(...)</td></tr>
<tr class="separator:ga15d9e73643bf66f7d69c7ebf959757aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5f7950ae47b299e20f2c447199cf6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8e5f7950ae47b299e20f2c447199cf6f">apop_model_copy_set</a>(model,  type, ...)</td></tr>
<tr class="separator:ga8e5f7950ae47b299e20f2c447199cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc21644ccf24f498a3b3a7e94758e58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafbc21644ccf24f498a3b3a7e94758e58">apop_model_cross</a>(...)</td></tr>
<tr class="separator:gafbc21644ccf24f498a3b3a7e94758e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab664f68b5e481bec56c8ddc7f16928c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab664f68b5e481bec56c8ddc7f16928c0">apop_model_dcompose</a>(...)</td></tr>
<tr class="separator:gab664f68b5e481bec56c8ddc7f16928c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34644b9d55c7528b47f0b887c9241928"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga34644b9d55c7528b47f0b887c9241928">apop_model_dconstrain</a>(...)</td></tr>
<tr class="separator:ga34644b9d55c7528b47f0b887c9241928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40bb98b02fde8f8e4ab59a4d127b692f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga40bb98b02fde8f8e4ab59a4d127b692f">apop_model_mixture</a>(...)</td></tr>
<tr class="separator:ga40bb98b02fde8f8e4ab59a4d127b692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36cae46a2950eb6cfb65794cdd5dac7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(in, ...)</td></tr>
<tr class="separator:ga36cae46a2950eb6cfb65794cdd5dac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674b73c9b8813f35e41009428cbc80f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga674b73c9b8813f35e41009428cbc80f9">Apop_notify</a>(verbosity, ...)</td></tr>
<tr class="separator:ga674b73c9b8813f35e41009428cbc80f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae03e0c8a6bb5f02bb422f4fca465ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaae03e0c8a6bb5f02bb422f4fca465ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_OLS</b></td></tr>
<tr class="separator:gaaae03e0c8a6bb5f02bb422f4fca465ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf417b9601adfa9cefad8c9a377a9674f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf417b9601adfa9cefad8c9a377a9674f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_PMF</b></td></tr>
<tr class="separator:gaf417b9601adfa9cefad8c9a377a9674f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401dbc60c9915be8e4c4def68b22d755"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>(d,  rownum)</td></tr>
<tr class="separator:ga401dbc60c9915be8e4c4def68b22d755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d32f03ca035f4d2ca0ef638b07cd5df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d32f03ca035f4d2ca0ef638b07cd5df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_return_data_error</b>(E)</td></tr>
<tr class="separator:ga8d32f03ca035f4d2ca0ef638b07cd5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e829ce2396bf05ab10460bcc37aeeab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>(thread_in)</td></tr>
<tr class="separator:ga1e829ce2396bf05ab10460bcc37aeeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d87af4e65acbf6982a34cf3dc33eae6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>(d,  rowname,  outd)</td></tr>
<tr class="separator:ga7d87af4e65acbf6982a34cf3dc33eae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6396c26f1d47cced2be3a761185d3b35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>(m,  row,  v)</td></tr>
<tr class="separator:ga6396c26f1d47cced2be3a761185d3b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585f5cf3125fb5fc875dea85980eabd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga585f5cf3125fb5fc875dea85980eabd1">Apop_rs</a>(d,  rownum,  len)</td></tr>
<tr class="separator:ga585f5cf3125fb5fc875dea85980eabd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314f28de914dfe6e45170e09d71d5429"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga314f28de914dfe6e45170e09d71d5429">Apop_rv</a>(data_to_view,  row)</td></tr>
<tr class="separator:ga314f28de914dfe6e45170e09d71d5429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb1877a3cc29edd685a68dd6b4a35dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8fb1877a3cc29edd685a68dd6b4a35dc">Apop_settings_add_group</a>(model,  type, ...)</td></tr>
<tr class="separator:ga8fb1877a3cc29edd685a68dd6b4a35dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47600802191d9ccf5d48fce70e754294"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga47600802191d9ccf5d48fce70e754294">Apop_settings_copy</a>(name, ...)</td></tr>
<tr class="separator:ga47600802191d9ccf5d48fce70e754294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae80181842102bf58ba1ffe18391796b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae80181842102bf58ba1ffe18391796b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_settings_declarations</b>(ysg)</td></tr>
<tr class="separator:gaae80181842102bf58ba1ffe18391796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833e962fb042462eeadada7484671f07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga833e962fb042462eeadada7484671f07">Apop_settings_free</a>(name, ...)</td></tr>
<tr class="separator:ga833e962fb042462eeadada7484671f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba53402807c9e6b82254fb552029501"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4ba53402807c9e6b82254fb552029501">Apop_settings_get</a>(model,  type,  setting)</td></tr>
<tr class="separator:ga4ba53402807c9e6b82254fb552029501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafba071ab93465fed4cac1020082b4c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaafba071ab93465fed4cac1020082b4c8">Apop_settings_get_group</a>(m,  type)</td></tr>
<tr class="separator:gaafba071ab93465fed4cac1020082b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe030e4bba4671d8b026e81be70f764"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaefe030e4bba4671d8b026e81be70f764">Apop_settings_init</a>(name, ...)</td></tr>
<tr class="separator:gaefe030e4bba4671d8b026e81be70f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff4361f65c1e848fabce24b4b8f44f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4ff4361f65c1e848fabce24b4b8f44f7">Apop_settings_rm_group</a>(m,  type)</td></tr>
<tr class="separator:ga4ff4361f65c1e848fabce24b4b8f44f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8659282b6003f7c2adac6f4baad5fae4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8659282b6003f7c2adac6f4baad5fae4">Apop_settings_set</a>(model,  type,  setting,  data)</td></tr>
<tr class="separator:ga8659282b6003f7c2adac6f4baad5fae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd17601e642688d033f62d346f3dace6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gabd17601e642688d033f62d346f3dace6">Apop_stopif</a>(test,  onfail,  level, ...)</td></tr>
<tr class="separator:gabd17601e642688d033f62d346f3dace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0375e20079df9652337e39c1317a14d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad0375e20079df9652337e39c1317a14d">Apop_subm</a>(data_to_view,  srow,  scol,  nrows,  ncols)</td></tr>
<tr class="separator:gad0375e20079df9652337e39c1317a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b05181ceec857e9eb9ed6a8ea7423d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga9b05181ceec857e9eb9ed6a8ea7423d3">apop_sum</a></td></tr>
<tr class="separator:ga9b05181ceec857e9eb9ed6a8ea7423d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb031d6207a4bab47be1ca9c39509184"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb031d6207a4bab47be1ca9c39509184"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_test_ANOVA_independence</b>(d)</td></tr>
<tr class="separator:gadb031d6207a4bab47be1ca9c39509184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62646e05f2fa0d149e240fadd60d1fa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62646e05f2fa0d149e240fadd60d1fa6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_text_add</b></td></tr>
<tr class="separator:ga62646e05f2fa0d149e240fadd60d1fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74dca50ea16ed7bf25cb152315642769"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(dataset, ...)</td></tr>
<tr class="separator:ga74dca50ea16ed7bf25cb152315642769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9308d562a120c8302edde3f736bc25d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae9308d562a120c8302edde3f736bc25d">apop_var</a></td></tr>
<tr class="separator:gae9308d562a120c8302edde3f736bc25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a1a67c02587093d62095f3aa56c690"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga75a1a67c02587093d62095f3aa56c690"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_varad_set</b>(var,  value)</td></tr>
<tr class="separator:ga75a1a67c02587093d62095f3aa56c690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b051e2fbe0e473dddeabfe4932ce0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a>(avfin, ...)</td></tr>
<tr class="separator:gaf9b051e2fbe0e473dddeabfe4932ce0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1974e60ac54b2f06a9731ecc42c74e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1974e60ac54b2f06a9731ecc42c74e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_WLS</b></td></tr>
<tr class="separator:gad1974e60ac54b2f06a9731ecc42c74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0c8c2a99fb8c6ec54822aca08591545e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapop__data.html">apop_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0c8c2a99fb8c6ec54822aca08591545e">apop_data</a></td></tr>
<tr class="separator:ga0c8c2a99fb8c6ec54822aca08591545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3441b2386cb4d58601e5caf7ca4a1465"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapop__mcmc__proposal__s.html">apop_mcmc_proposal_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga3441b2386cb4d58601e5caf7ca4a1465">apop_mcmc_proposal_s</a></td></tr>
<tr class="separator:ga3441b2386cb4d58601e5caf7ca4a1465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b8fd387aa53bca1a8dedab0dd99a42"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae7b8fd387aa53bca1a8dedab0dd99a42">apop_mcmc_settings</a></td></tr>
<tr class="separator:gae7b8fd387aa53bca1a8dedab0dd99a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe86ae10fc82d219906211e4f88e4cf9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafe86ae10fc82d219906211e4f88e4cf9">apop_model</a></td></tr>
<tr class="separator:gafe86ae10fc82d219906211e4f88e4cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1309242dbb7f148916c71a9a70c6b64c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1309242dbb7f148916c71a9a70c6b64c">apop_anova</a> (char *table, char *data, char *grouping1, char *grouping2)</td></tr>
<tr class="separator:ga1309242dbb7f148916c71a9a70c6b64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0492d6f5ae8a73a60b651cadb113d643"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0492d6f5ae8a73a60b651cadb113d643">apop_arms_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memdesc:ga0492d6f5ae8a73a60b651cadb113d643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive rejection metropolis sampling.  <a href="#ga0492d6f5ae8a73a60b651cadb113d643">More...</a><br /></td></tr>
<tr class="separator:ga0492d6f5ae8a73a60b651cadb113d643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abdcdbaceaaf0dd3882a164bc2565de"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a> (double *in, int size)</td></tr>
<tr class="separator:ga8abdcdbaceaaf0dd3882a164bc2565de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69adca14afc66100168f585e05b59dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga69adca14afc66100168f585e05b59dcb">apop_beta_from_mean_var</a> (double m, double v)</td></tr>
<tr class="separator:ga69adca14afc66100168f585e05b59dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb57b1f864c650ed6d7e029550e7bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, gsl_rng *rng, int iterations, char keep_boots, char ignore_nans)</td></tr>
<tr class="separator:ga4eb57b1f864c650ed6d7e029550e7bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee16258d3e52671e254f3ce03bca7754"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:gaee16258d3e52671e254f3ce03bca7754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8c299b83b8500b8b6ecd30817353c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)</td></tr>
<tr class="separator:gaee8c299b83b8500b8b6ecd30817353c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b767b375fb18f61f939c6869955331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char *name, double val)</td></tr>
<tr class="separator:ga44b767b375fb18f61f939c6869955331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b050ee3cfbb8858576bca6ae07571df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b050ee3cfbb8858576bca6ae07571df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_add_names_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, const char type, char const **names)</td></tr>
<tr class="separator:ga1b050ee3cfbb8858576bca6ae07571df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7e530a692571a403e5837fda5e0f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *dataset, <a class="el" href="structapop__data.html">apop_data</a> *newpage, const char *title)</td></tr>
<tr class="separator:ga7e7e530a692571a403e5837fda5e0f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac39d6a56933b6f084328ec5ecd5090d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> (const size_t size1, const size_t size2, const int size3)</td></tr>
<tr class="separator:gac39d6a56933b6f084328ec5ecd5090d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0460790f2d21f03856ed4a212a4132ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> (const size_t size1, const size_t size2, const int size3)</td></tr>
<tr class="separator:ga0460790f2d21f03856ed4a212a4132ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd67e6838ce2521a1d756894dc9b5ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="separator:gadd67e6838ce2521a1d756894dc9b5ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3ab967f57f8ad3cfb99a4a82cfae02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="separator:gafa3ab967f57f8ad3cfb99a4a82cfae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae37a5bf11cddee59e272b083a4efc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="separator:gaeae37a5bf11cddee59e272b083a4efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9801d051a0ea37b5f7516a70b4054188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9801d051a0ea37b5f7516a70b4054188"></a>
<a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double[])</td></tr>
<tr class="separator:ga9801d051a0ea37b5f7516a70b4054188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e8377359d46c9bd02ea57205e7968d3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *freeme)</td></tr>
<tr class="separator:ga3e8377359d46c9bd02ea57205e7968d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06107779e4a3eb229715ceca24352b89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, size_t row, int col, const char *rowname, const char *colname, const char *page)</td></tr>
<tr class="separator:ga06107779e4a3eb229715ceca24352b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec9170cf1382f6cd549a5819472eb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gadec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int col, char type)</td></tr>
<tr class="separator:gadec9170cf1382f6cd549a5819472eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044771db76f0afb410a8d4f05ac51ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char match)</td></tr>
<tr class="separator:ga044771db76f0afb410a8d4f05ac51ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0316d98bbeb6ae13532a8c071019dbe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char inplace)</td></tr>
<tr class="separator:ga0316d98bbeb6ae13532a8c071019dbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24d396c7fda38bc4ab03a3ba2db4943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> (<a class="el" href="structapop__data.html">apop_data</a> *out, const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="separator:gaa24d396c7fda38bc4ab03a3ba2db4943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90feb5dd661cfe0f0b53a85295b8b56e"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga90feb5dd661cfe0f0b53a85295b8b56e">apop_data_pack</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in, gsl_vector *out, char more_pages, char use_info_pages)</td></tr>
<tr class="separator:ga90feb5dd661cfe0f0b53a85295b8b56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc90578a8086a2e6f7b1575300260f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="separator:gacc90578a8086a2e6f7b1575300260f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab45a848e5dbcaf82b5b95cd03f7b396a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, Output_declares)</td></tr>
<tr class="separator:gab45a848e5dbcaf82b5b95cd03f7b396a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7309e87fb273a538b3c8cac2fae660"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e7309e87fb273a538b3c8cac2fae660"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_print</b> (const <a class="el" href="structapop__data.html">apop_data</a> *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="separator:ga0e7309e87fb273a538b3c8cac2fae660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1efbe058d6ca85ece023eb471c66e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char **colnames)</td></tr>
<tr class="separator:gad1efbe058d6ca85ece023eb471c66e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d1c0299c7eb87224bc6c60555784fe"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga59d1c0299c7eb87224bc6c60555784fe">apop_data_ptr</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int row, int col, const char *rowname, const char *colname, const char *page)</td></tr>
<tr class="separator:ga59d1c0299c7eb87224bc6c60555784fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9235c6882a01ac9195665104985cd0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa9235c6882a01ac9195665104985cd0e">apop_data_rank_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int min_bins)</td></tr>
<tr class="separator:gaa9235c6882a01ac9195665104985cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2feb17743f8b07b8ddcf457362cabefc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="separator:ga2feb17743f8b07b8ddcf457362cabefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1312f6568cfe832f1e35f7f44482ffb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int *drop)</td></tr>
<tr class="separator:ga1312f6568cfe832f1e35f7f44482ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac434c9d08b6a8304107d9c93afb81914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char free_p)</td></tr>
<tr class="separator:gac434c9d08b6a8304107d9c93afb81914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ab3a4f332adb368fe970619a8c0252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int *drop, int(*do_drop)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), void *drop_parameter)</td></tr>
<tr class="separator:gae2ab3a4f332adb368fe970619a8c0252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bdc618669b9ddc8239595d7b50bec9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5bdc618669b9ddc8239595d7b50bec9e">apop_data_set</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, size_t row, int col, const double val, const char *rowname, const char *colname, const char *page)</td></tr>
<tr class="separator:ga5bdc618669b9ddc8239595d7b50bec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4048ac06a41a1b3a89261ad6d438565c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4048ac06a41a1b3a89261ad6d438565c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_show</b> (const <a class="el" href="structapop__data.html">apop_data</a> *data)</td></tr>
<tr class="separator:ga4048ac06a41a1b3a89261ad6d438565c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefe4dee819c090e57ac69d4d8bdcfd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__data.html">apop_data</a> *sort_order, char asc, char inplace, double *col_order)</td></tr>
<tr class="separator:gacefe4dee819c090e57ac69d4d8bdcfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0284036801cb75d465a1738f65397e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaef0284036801cb75d465a1738f65397e">apop_data_split</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int splitpoint, char r_or_c)</td></tr>
<tr class="separator:gaef0284036801cb75d465a1738f65397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2ffb5c5ba2bb240e930be08fc4fd56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> (<a class="el" href="structapop__data.html">apop_data</a> *m1, <a class="el" href="structapop__data.html">apop_data</a> *m2, char posn, char inplace)</td></tr>
<tr class="separator:ga0f2ffb5c5ba2bb240e930be08fc4fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253dba4ed7f5c03107d38c1268b46c01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga253dba4ed7f5c03107d38c1268b46c01">apop_data_summarize</a> (<a class="el" href="structapop__data.html">apop_data</a> *data)</td></tr>
<tr class="separator:ga253dba4ed7f5c03107d38c1268b46c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad60f2beb7836119d364676a361cb5e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a> (<a class="el" href="structapop__data.html">apop_data</a> const *indata, <a class="el" href="structapop__data.html">apop_data</a> const *binspec, int bin_count, char close_top_bin)</td></tr>
<tr class="separator:gad60f2beb7836119d364676a361cb5e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b58a490cc5a82a36bd333cef4182b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga86b58a490cc5a82a36bd333cef4182b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_to_db</b> (const <a class="el" href="structapop__data.html">apop_data</a> *set, const char *tabname, char)</td></tr>
<tr class="separator:ga86b58a490cc5a82a36bd333cef4182b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c28224e10f8aacdaa2d130f96f6ba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int col, char type, int keep_first, char append, char remove)</td></tr>
<tr class="separator:gae0c28224e10f8aacdaa2d130f96f6ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27405bd5fdf48d93c8918ca4c07ee260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, char intype, int incol, int outcol)</td></tr>
<tr class="separator:ga27405bd5fdf48d93c8918ca4c07ee260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82281b8673cda3645054d7e061bb1167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char transpose_text, char inplace)</td></tr>
<tr class="separator:ga82281b8673cda3645054d7e061bb1167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3058b7f39d0442f13284464d1ba235d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> (const gsl_vector *in, <a class="el" href="structapop__data.html">apop_data</a> *d, char use_info_pages)</td></tr>
<tr class="separator:gae3058b7f39d0442f13284464d1ba235d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf205f62e9432fe293b05c077d1b61d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gacf205f62e9432fe293b05c077d1b61d4">apop_db_close</a> (char vacuum)</td></tr>
<tr class="separator:gacf205f62e9432fe293b05c077d1b61d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d81aff912df2982697038c51795e358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4d81aff912df2982697038c51795e358">apop_db_open</a> (char const *filename)</td></tr>
<tr class="separator:ga4d81aff912df2982697038c51795e358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad22f12fdb3606b0bc49cd1929a05626e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad22f12fdb3606b0bc49cd1929a05626e">apop_db_to_crosstab</a> (char const *tabname, char const *row, char const *col, char const *data, char is_aggregate)</td></tr>
<tr class="separator:gad22f12fdb3606b0bc49cd1929a05626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6984006ab44fa7c9c2e99463f7d4081b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> (const gsl_matrix *in, gsl_matrix **out, int calc_det, int calc_inv)</td></tr>
<tr class="separator:ga6984006ab44fa7c9c2e99463f7d4081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d13e1b1f20f97e0772a0be41dc430e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d1, const <a class="el" href="structapop__data.html">apop_data</a> *d2, char form1, char form2)</td></tr>
<tr class="separator:gaf2d13e1b1f20f97e0772a0be41dc430e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f15cd1923ed7b5b46e52a77ca1dfef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga87f15cd1923ed7b5b46e52a77ca1dfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0598e5aca68949939a189bd4ce24ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga2c0598e5aca68949939a189bd4ce24ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704e8625a022360600919116bc20ffbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga704e8625a022360600919116bc20ffbb">apop_estimate_coefficient_of_determination</a> (<a class="el" href="structapop__model.html">apop_model</a> *)</td></tr>
<tr class="separator:ga704e8625a022360600919116bc20ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae165633525c5272ab83794b60076eddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae165633525c5272ab83794b60076eddc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_estimate_parameter_tests</b> (<a class="el" href="structapop__model.html">apop_model</a> *est)</td></tr>
<tr class="separator:gae165633525c5272ab83794b60076eddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5e39c00012de5b51cd49ce1ffd31fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> (<a class="el" href="structapop__model.html">apop_model</a> *e, <a class="el" href="structapop__model.html">apop_model</a> *copy, char *starting_pt, double boundary)</td></tr>
<tr class="separator:ga6d5e39c00012de5b51cd49ce1ffd31fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1902b3fd6a6682d1453a80b788e44ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a> (<a class="el" href="structapop__model.html">apop_model</a> *est, <a class="el" href="structapop__data.html">apop_data</a> *contrast)</td></tr>
<tr class="separator:ga1902b3fd6a6682d1453a80b788e44ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217b3299f0704a856d40f213810914c4"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga217b3299f0704a856d40f213810914c4">apop_generalized_harmonic</a> (int N, double s)</td></tr>
<tr class="separator:ga217b3299f0704a856d40f213810914c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe2a099150e242e974ed8f95142b3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2fe2a099150e242e974ed8f95142b3a9">apop_histograms_test_goodness_of_fit</a> (<a class="el" href="structapop__model.html">apop_model</a> *h0, <a class="el" href="structapop__model.html">apop_model</a> *h1)</td></tr>
<tr class="separator:ga2fe2a099150e242e974ed8f95142b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a85afbb18d256bcc8942d2eca7470ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8a85afbb18d256bcc8942d2eca7470ed">apop_jackknife_cov</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model)</td></tr>
<tr class="separator:ga8a85afbb18d256bcc8942d2eca7470ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56d1f280fa5774300d10616cf24a3c4"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa56d1f280fa5774300d10616cf24a3c4">apop_kl_divergence</a> (<a class="el" href="structapop__model.html">apop_model</a> *from, <a class="el" href="structapop__model.html">apop_model</a> *to, int draw_ct, gsl_rng *rng)</td></tr>
<tr class="separator:gaa56d1f280fa5774300d10616cf24a3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad490e5b31d1bbc99223c2cbfac7c1782"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad490e5b31d1bbc99223c2cbfac7c1782">apop_linear_constraint</a> (gsl_vector *beta, <a class="el" href="structapop__data.html">apop_data</a> *constraint, double margin)</td></tr>
<tr class="separator:gad490e5b31d1bbc99223c2cbfac7c1782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e160c8d0a0ee660c89fb3f6de2af89c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5e160c8d0a0ee660c89fb3f6de2af89c">apop_log_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga5e160c8d0a0ee660c89fb3f6de2af89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacff3707e418a067104c77c410b43f69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, apop_fn_d *fn_d, apop_fn_v *fn_v, apop_fn_r *fn_r, apop_fn_dp *fn_dp, apop_fn_vp *fn_vp, apop_fn_rp *fn_rp, apop_fn_dpi *fn_dpi, apop_fn_vpi *fn_vpi, apop_fn_rpi *fn_rpi, apop_fn_di *fn_di, apop_fn_vi *fn_vi, apop_fn_ri *fn_ri, void *param, int inplace, char part, int all_pages)</td></tr>
<tr class="separator:gaacff3707e418a067104c77c410b43f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad65cf464db938a7fbd57de43dfe1c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad65cf464db938a7fbd57de43dfe1c87"></a>
<a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_map</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, int inplace, char part, int all_pages)</td></tr>
<tr class="separator:gaad65cf464db938a7fbd57de43dfe1c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30601e357a1e21648f8d8db3c9ed6f3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, apop_fn_d *fn_d, apop_fn_v *fn_v, apop_fn_r *fn_r, apop_fn_dp *fn_dp, apop_fn_vp *fn_vp, apop_fn_rp *fn_rp, apop_fn_dpi *fn_dpi, apop_fn_vpi *fn_vpi, apop_fn_rpi *fn_rpi, apop_fn_di *fn_di, apop_fn_vi *fn_vi, apop_fn_ri *fn_ri, void *param, char part, int all_pages)</td></tr>
<tr class="separator:ga30601e357a1e21648f8d8db3c9ed6f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871b9e67a6ae243f7420e6943e28e8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga871b9e67a6ae243f7420e6943e28e8a0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>apop_map_sum</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, char part, int all_pages)</td></tr>
<tr class="separator:ga871b9e67a6ae243f7420e6943e28e8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4ae58b861199bbc1a460719942d98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5c4ae58b861199bbc1a460719942d98f">apop_matrix_apply</a> (gsl_matrix *m, void(*fn)(gsl_vector *))</td></tr>
<tr class="separator:ga5c4ae58b861199bbc1a460719942d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga163589e9f5cb08f88f2032fc1229ec6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga163589e9f5cb08f88f2032fc1229ec6f">apop_matrix_apply_all</a> (gsl_matrix *in, void(*fn)(double *))</td></tr>
<tr class="separator:ga163589e9f5cb08f88f2032fc1229ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bb322b9f491c46feb1e24025b6301f"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)</td></tr>
<tr class="separator:ga45bb322b9f491c46feb1e24025b6301f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03038130e4ba55228f9e164dba513961"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> (const gsl_matrix *in)</td></tr>
<tr class="separator:ga03038130e4ba55228f9e164dba513961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185243be2d8a93686c68263cc3318f47"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> (const gsl_matrix *in)</td></tr>
<tr class="separator:ga185243be2d8a93686c68263cc3318f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7707d44884aa63c298510a0662956a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> (gsl_matrix *m, char semi)</td></tr>
<tr class="separator:gafc7707d44884aa63c298510a0662956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da5091a11c37d3501d678b8ecec466f"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> (const gsl_matrix *m, double(*fn)(gsl_vector *))</td></tr>
<tr class="separator:ga5da5091a11c37d3501d678b8ecec466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1df9cb7fdd56e48593d99f5122224d7"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab1df9cb7fdd56e48593d99f5122224d7">apop_matrix_map_all</a> (const gsl_matrix *in, double(*fn)(double))</td></tr>
<tr class="separator:gab1df9cb7fdd56e48593d99f5122224d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04bc576579bfb2e14d5004d4af7bb88"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae04bc576579bfb2e14d5004d4af7bb88">apop_matrix_map_all_sum</a> (const gsl_matrix *in, double(*fn)(double))</td></tr>
<tr class="separator:gae04bc576579bfb2e14d5004d4af7bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0c51a046140b563c8e12a6032e9a16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4f0c51a046140b563c8e12a6032e9a16">apop_matrix_map_sum</a> (const gsl_matrix *in, double(*fn)(gsl_vector *))</td></tr>
<tr class="separator:ga4f0c51a046140b563c8e12a6032e9a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040b9e9fea1abe105de86081bf396d40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)</td></tr>
<tr class="separator:ga040b9e9fea1abe105de86081bf396d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf794cc2491ef147e0c67eb05feed7a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)</td></tr>
<tr class="separator:gaf794cc2491ef147e0c67eb05feed7a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1715c468336800a21ca86971323ae3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa1715c468336800a21ca86971323ae3d">apop_matrix_pca</a> (gsl_matrix *data, int const dimensions_we_want)</td></tr>
<tr class="separator:gaa1715c468336800a21ca86971323ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50915e9992a7cc880807cc266e9f5166"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga50915e9992a7cc880807cc266e9f5166">apop_matrix_print</a> (const gsl_matrix *data, Output_declares)</td></tr>
<tr class="separator:ga50915e9992a7cc880807cc266e9f5166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff17c62bcd3dd808393c9de53751195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ff17c62bcd3dd808393c9de53751195"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_matrix_print</b> (const gsl_matrix *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="separator:ga7ff17c62bcd3dd808393c9de53751195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06b6ab6ec9f78f305b1dacc8ec2efd3"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> (gsl_matrix *m, size_t newheight, size_t newwidth)</td></tr>
<tr class="separator:gaa06b6ab6ec9f78f305b1dacc8ec2efd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f619a8c83d791ce3d07bf4f6eecb32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae7f619a8c83d791ce3d07bf4f6eecb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_matrix_show</b> (const gsl_matrix *data)</td></tr>
<tr class="separator:gae7f619a8c83d791ce3d07bf4f6eecb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e30501a20450f8e68f151844c3fbd78"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8e30501a20450f8e68f151844c3fbd78">apop_matrix_stack</a> (gsl_matrix *m1, gsl_matrix const *m2, char posn, char inplace)</td></tr>
<tr class="separator:ga8e30501a20450f8e68f151844c3fbd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369c774aac917e56d8e32f9c66d9c2a0"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)</td></tr>
<tr class="separator:ga369c774aac917e56d8e32f9c66d9c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fc93322ffcb4e20cfc0b9af9e2aea0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> (gsl_matrix *m)</td></tr>
<tr class="separator:gaf1fc93322ffcb4e20cfc0b9af9e2aea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f092d1786034dd2ab22c63de5c955c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *dist)</td></tr>
<tr class="separator:gae9f092d1786034dd2ab22c63de5c955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a184259c139f1fdd970ef6b43f6274e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *meanvar)</td></tr>
<tr class="separator:ga2a184259c139f1fdd970ef6b43f6274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86381a72949fd3ffafefa87e3f51a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa86381a72949fd3ffafefa87e3f51a4f">apop_model_clear</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model)</td></tr>
<tr class="separator:gaa86381a72949fd3ffafefa87e3f51a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d3a65f43071b9d61d9edd59249c629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a> (<a class="el" href="structapop__model.html">apop_model</a> *in)</td></tr>
<tr class="separator:ga87d3a65f43071b9d61d9edd59249c629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e52d62178e8b52c9161b59d60653ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5e52d62178e8b52c9161b59d60653ca"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_model_cross_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *mlist[])</td></tr>
<tr class="separator:gaf5e52d62178e8b52c9161b59d60653ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e204cdc7429bef3ca2efb83453fe77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, int count, <a class="el" href="structapop__data.html">apop_data</a> *draws)</td></tr>
<tr class="separator:ga4e204cdc7429bef3ca2efb83453fe77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8310d52c11bcb7a8d32656a21c44cd"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a> (<a class="el" href="structapop__model.html">apop_model</a> *in, int draws)</td></tr>
<tr class="separator:ga4d8310d52c11bcb7a8d32656a21c44cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f6ca7e042ac7c09c3c01d29702a739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> (<a class="el" href="structapop__model.html">apop_model</a> *model_in)</td></tr>
<tr class="separator:gab4f6ca7e042ac7c09c3c01d29702a739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf676505faea1c7e30ffbd8690a092ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf676505faea1c7e30ffbd8690a092ed8">apop_model_fix_params_get_base</a> (<a class="el" href="structapop__model.html">apop_model</a> *model_in)</td></tr>
<tr class="separator:gaf676505faea1c7e30ffbd8690a092ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29755a86b82dfe31cdd01d55431cc09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab29755a86b82dfe31cdd01d55431cc09">apop_model_free</a> (<a class="el" href="structapop__model.html">apop_model</a> *free_me)</td></tr>
<tr class="separator:gab29755a86b82dfe31cdd01d55431cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a55a20880947e289767aad6e5b0117c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
<tr class="separator:ga1a55a20880947e289767aad6e5b0117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga733c60eab5b69d89729565a3aeeb15d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, gsl_rng *rng, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga733c60eab5b69d89729565a3aeeb15d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28fc59f2675fd5bcd530cb7325b6c60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa28fc59f2675fd5bcd530cb7325b6c60">apop_model_metropolis_draw</a> (double *out, gsl_rng *rng, <a class="el" href="structapop__model.html">apop_model</a> *model)</td></tr>
<tr class="separator:gaa28fc59f2675fd5bcd530cb7325b6c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f10c642ac9a8c9342da4530de1a4e95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f10c642ac9a8c9342da4530de1a4e95"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_model_mixture_base</b> (<a class="el" href="structapop__model.html">apop_model</a> **inlist)</td></tr>
<tr class="separator:ga5f10c642ac9a8c9342da4530de1a4e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2784b69175d1ecd3833d228d2294e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
<tr class="separator:ga0f2784b69175d1ecd3833d228d2294e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb1e9f6fbed5357e6446211a1dabb804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gadb1e9f6fbed5357e6446211a1dabb804">apop_model_print</a> (<a class="el" href="structapop__model.html">apop_model</a> *print_me, FILE *out)</td></tr>
<tr class="separator:gadb1e9f6fbed5357e6446211a1dabb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b818ff6672229f10c3e559ba9cffb65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b818ff6672229f10c3e559ba9cffb65"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_model_set_parameters_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *in, double ap[])</td></tr>
<tr class="separator:ga0b818ff6672229f10c3e559ba9cffb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa08e29db38e8dcc111899c942022d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4fa08e29db38e8dcc111899c942022d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_model_show</b> (<a class="el" href="structapop__model.html">apop_model</a> *print_me)</td></tr>
<tr class="separator:ga4fa08e29db38e8dcc111899c942022d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313527fa21f9a9686be8dd73579950f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga313527fa21f9a9686be8dd73579950f4">apop_model_to_pmf</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, <a class="el" href="structapop__data.html">apop_data</a> *binspec, long int draws, int bin_count)</td></tr>
<tr class="separator:ga313527fa21f9a9686be8dd73579950f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c76ad8792959b6605402a1d71a1b6c9"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a> (double a, int p)</td></tr>
<tr class="separator:ga2c76ad8792959b6605402a1d71a1b6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180b231acc3c64d07664ed2b1a8ad0e1"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a> (double a, int p)</td></tr>
<tr class="separator:ga180b231acc3c64d07664ed2b1a8ad0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32d4f48cff7788b617d40155703ae64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae32d4f48cff7788b617d40155703ae64">apop_name_add</a> (<a class="el" href="structapop__name.html">apop_name</a> *n, char const *add_me, char type)</td></tr>
<tr class="separator:gae32d4f48cff7788b617d40155703ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ff289eb3d86e1ba5b06e5064a3286f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga29ff289eb3d86e1ba5b06e5064a3286f">apop_name_alloc</a> (void)</td></tr>
<tr class="separator:ga29ff289eb3d86e1ba5b06e5064a3286f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad865208febeeb8cfce2f1d90e13db07a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a> (<a class="el" href="structapop__name.html">apop_name</a> *in)</td></tr>
<tr class="separator:gad865208febeeb8cfce2f1d90e13db07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb1398925a93b7c2c502af8fb2abc49e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a> (const <a class="el" href="structapop__name.html">apop_name</a> *n, const char *findme, const char type)</td></tr>
<tr class="separator:gadb1398925a93b7c2c502af8fb2abc49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a9c548fc646f28518bb1edb84dafc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga62a9c548fc646f28518bb1edb84dafc6">apop_name_free</a> (<a class="el" href="structapop__name.html">apop_name</a> *free_me)</td></tr>
<tr class="separator:ga62a9c548fc646f28518bb1edb84dafc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7220e4b2fe43c56593af0ceb2c7001a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf7220e4b2fe43c56593af0ceb2c7001a">apop_name_print</a> (<a class="el" href="structapop__name.html">apop_name</a> *n)</td></tr>
<tr class="separator:gaf7220e4b2fe43c56593af0ceb2c7001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4fd369dba75ec4782400cf7378e56ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> (<a class="el" href="structapop__name.html">apop_name</a> *n1, <a class="el" href="structapop__name.html">apop_name</a> *nadd, char type1, char typeadd)</td></tr>
<tr class="separator:gab4fd369dba75ec4782400cf7378e56ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6ecb8702153658c29369dc2e7cfba9"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
<tr class="separator:ga1b6ecb8702153658c29369dc2e7cfba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2510c7df8ccd834732ee208005738b0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga2510c7df8ccd834732ee208005738b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae576fb823e38f7b6f2ce1892e4b014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0ae576fb823e38f7b6f2ce1892e4b014">apop_paired_t_test</a> (gsl_vector *a, gsl_vector *b)</td></tr>
<tr class="separator:ga0ae576fb823e38f7b6f2ce1892e4b014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92355da54ab91a8dee22192ae68a37d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga92355da54ab91a8dee22192ae68a37d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4502235c35ff5724f8988e993b81ace1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4502235c35ff5724f8988e993b81ace1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_plot_histogram</b> (gsl_vector *data, size_t bin_count, char *with, char const *output_name, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="separator:ga4502235c35ff5724f8988e993b81ace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867f0b8df261866bb18e9040871c51f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga867f0b8df261866bb18e9040871c51f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373ccc4cb87b162d62d07a2685ccd8ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga373ccc4cb87b162d62d07a2685ccd8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4748bf59f5441cd27e5b93056c7ec1c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga4748bf59f5441cd27e5b93056c7ec1c7">apop_prep_output</a> (char const *output_name, FILE **output_pipe, char *output_type, char *output_append)</td></tr>
<tr class="separator:ga4748bf59f5441cd27e5b93056c7ec1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02cf6319da103f9bfe55dfbbc7675536"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga02cf6319da103f9bfe55dfbbc7675536">apop_query</a> (const char *q,...)</td></tr>
<tr class="separator:ga02cf6319da103f9bfe55dfbbc7675536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade862993166c6482f53562fb77721db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> (const char *fmt,...)</td></tr>
<tr class="separator:gade862993166c6482f53562fb77721db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad75f9dfba696a3741e28896ed5b75d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1ad75f9dfba696a3741e28896ed5b75d">apop_query_to_float</a> (const char *fmt,...)</td></tr>
<tr class="separator:ga1ad75f9dfba696a3741e28896ed5b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f06db34e05b5afb63112f83ad2317b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a> (const char *typelist, const char *fmt,...)</td></tr>
<tr class="separator:ga1f06db34e05b5afb63112f83ad2317b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fbd580cd71f481ae04ee03b5cf64ff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a> (const char *fmt,...)</td></tr>
<tr class="separator:ga2fbd580cd71f481ae04ee03b5cf64ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830703db838855b8abd636069c7145de"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga830703db838855b8abd636069c7145de">apop_query_to_vector</a> (const char *fmt,...)</td></tr>
<tr class="separator:ga830703db838855b8abd636069c7145de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3980c42be0495f001a5b296097682f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1a3980c42be0495f001a5b296097682f">apop_rake</a> (char const *margin_table, char *const *var_list, int var_ct, char *const *contrasts, int contrast_ct, char const *structural_zeros, int max_iterations, double tolerance, char const *count_col, char const *init_table, char const *init_count_col, double nudge)</td></tr>
<tr class="separator:ga1a3980c42be0495f001a5b296097682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ec5e7ed223c09bec044ced54f24fad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> (const char *string, const char *regex, <a class="el" href="structapop__data.html">apop_data</a> **substrings, const char use_case)</td></tr>
<tr class="separator:gaa9ec5e7ed223c09bec044ced54f24fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada044cf02135422a9f9292b6054c86dd"><td class="memItemLeft" align="right" valign="top">gsl_rng *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> (int seed)</td></tr>
<tr class="separator:gada044cf02135422a9f9292b6054c86dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d8c995400d75922553d463f4b2b890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72d8c995400d75922553d463f4b2b890"></a>
gsl_rng *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_rng_get_thread_base</b> (int thread)</td></tr>
<tr class="separator:ga72d8c995400d75922553d463f4b2b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf0d5d65f514d9894a4ca5b0e8755873"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaaf0d5d65f514d9894a4ca5b0e8755873">apop_rng_GHgB3</a> (gsl_rng *r, double *a)</td></tr>
<tr class="separator:gaaf0d5d65f514d9894a4ca5b0e8755873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228b013bc80f308900882312cab93eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga228b013bc80f308900882312cab93eb3">apop_score</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, gsl_vector *out, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="separator:ga228b013bc80f308900882312cab93eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc44b7dfc3c125d19c1db3bef3a80a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga0dc44b7dfc3c125d19c1db3bef3a80a1">apop_settings_copy_group</a> (<a class="el" href="structapop__model.html">apop_model</a> *outm, <a class="el" href="structapop__model.html">apop_model</a> *inm, char *copyme)</td></tr>
<tr class="separator:ga0dc44b7dfc3c125d19c1db3bef3a80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447eff1b2d149fb29476e68a1bff2788"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga447eff1b2d149fb29476e68a1bff2788"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_settings_get_grp</b> (<a class="el" href="structapop__model.html">apop_model</a> *m, char *type, char fail)</td></tr>
<tr class="separator:ga447eff1b2d149fb29476e68a1bff2788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3571609cce3324b52ef96b7b844c32df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3571609cce3324b52ef96b7b844c32df"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_settings_group_alloc</b> (<a class="el" href="structapop__model.html">apop_model</a> *model, char *type, void *free_fn, void *copy_fn, void *the_group)</td></tr>
<tr class="separator:ga3571609cce3324b52ef96b7b844c32df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52cb7b05e3a71c5094f429340dfebd36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga52cb7b05e3a71c5094f429340dfebd36"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_settings_group_alloc_wm</b> (<a class="el" href="structapop__model.html">apop_model</a> *model, char *type, void *free_fn, void *copy_fn, void *the_group)</td></tr>
<tr class="separator:ga52cb7b05e3a71c5094f429340dfebd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga564d11900c26fec78f7992617a7eee4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga564d11900c26fec78f7992617a7eee4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_settings_remove_group</b> (<a class="el" href="structapop__model.html">apop_model</a> *m, char *delme)</td></tr>
<tr class="separator:ga564d11900c26fec78f7992617a7eee4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga153362f8a4c7f64e0c8dad893edadea4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga153362f8a4c7f64e0c8dad893edadea4">apop_system</a> (const char *fmt,...)</td></tr>
<tr class="separator:ga153362f8a4c7f64e0c8dad893edadea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c94b79fe91308dc97829741acc9322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga65c94b79fe91308dc97829741acc9322">apop_t_test</a> (gsl_vector *a, gsl_vector *b)</td></tr>
<tr class="separator:ga65c94b79fe91308dc97829741acc9322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d501ca84ade92bc72fd4f67a617f64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga01d501ca84ade92bc72fd4f67a617f64">apop_table_exists</a> (char const *name, char remove)</td></tr>
<tr class="separator:ga01d501ca84ade92bc72fd4f67a617f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650d1ecf6f78c3bdb85c8fce71dfae05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> (double statistic, char *distribution, double p1, double p2, char tail)</td></tr>
<tr class="separator:ga650d1ecf6f78c3bdb85c8fce71dfae05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b92b7494f4e24d2f47244e3792d566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a> (<a class="el" href="structapop__data.html">apop_data</a> *d)</td></tr>
<tr class="separator:ga12b92b7494f4e24d2f47244e3792d566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8627a1eebf904699e90e66adc8b4b021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a> (<a class="el" href="structapop__data.html">apop_data</a> *intab)</td></tr>
<tr class="separator:ga8627a1eebf904699e90e66adc8b4b021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ccaa9de7cb16e60a435c56eaf3400d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a> (<a class="el" href="structapop__model.html">apop_model</a> *m1, <a class="el" href="structapop__model.html">apop_model</a> *m2)</td></tr>
<tr class="separator:ga98ccaa9de7cb16e60a435c56eaf3400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fba0f07c262a433133f6f3362617da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col)</td></tr>
<tr class="separator:ga9fba0f07c262a433133f6f3362617da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd20a9fd056845b5469b6d3bb48c653"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1fd20a9fd056845b5469b6d3bb48c653"></a>
<a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_text_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *data, char *text[])</td></tr>
<tr class="separator:ga1fd20a9fd056845b5469b6d3bb48c653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65386d7b37c2eaf37d1eb4e3ae7a7554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> (char ***freeme, int rows, int cols)</td></tr>
<tr class="separator:ga65386d7b37c2eaf37d1eb4e3ae7a7554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6270ad55c566140e0d7962cb4d5daacc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a> (<a class="el" href="structapop__data.html">apop_data</a> const *strings, char *between, char *before, char *after, char *between_cols, int(*prune)(<a class="el" href="structapop__data.html">apop_data</a> *, int, int, void *), void *prune_parameter)</td></tr>
<tr class="separator:ga6270ad55c566140e0d7962cb4d5daacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae987ac014cda5e483f8c16bfd59147ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col, const char *fmt,...)</td></tr>
<tr class="separator:gae987ac014cda5e483f8c16bfd59147ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630de5d4fcbe9ef13373029f5d813a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a> (char const *text_file, int has_row_names, int has_col_names, int const *field_ends, char const *delimiters)</td></tr>
<tr class="separator:ga630de5d4fcbe9ef13373029f5d813a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd00e16791a970631c3ed4ac3487da46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gabd00e16791a970631c3ed4ac3487da46">apop_text_to_db</a> (char const *text_file, char *tabname, int has_row_names, int has_col_names, char **field_names, int const *field_ends, <a class="el" href="structapop__data.html">apop_data</a> *field_params, char *table_params, char const *delimiters, char if_table_exists)</td></tr>
<tr class="separator:gabd00e16791a970631c3ed4ac3487da46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c937ea4764d3da2ed9968273fa4544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d, size_t col)</td></tr>
<tr class="separator:ga77c937ea4764d3da2ed9968273fa4544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c0ddb63673ddd40ba69f7dc8bff800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *prior, <a class="el" href="structapop__model.html">apop_model</a> *likelihood, gsl_rng *rng)</td></tr>
<tr class="separator:gac7c0ddb63673ddd40ba69f7dc8bff800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51964750c64d327e52e2230019e44f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a> (gsl_vector *v, void(*fn)(double *))</td></tr>
<tr class="separator:ga51964750c64d327e52e2230019e44f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136ded2b6d190739deca064701cf5ca1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> (const gsl_vector *in, long double max)</td></tr>
<tr class="separator:ga136ded2b6d190739deca064701cf5ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baf0e8717a30fdcfba350da904c1825"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)</td></tr>
<tr class="separator:ga5baf0e8717a30fdcfba350da904c1825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1154897fec0c56bc0161ed24c48759c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1154897fec0c56bc0161ed24c48759c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>apop_vector_correlation</b> (const gsl_vector *ina, const gsl_vector *inb)</td></tr>
<tr class="separator:gae1154897fec0c56bc0161ed24c48759c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105323d45e054e608d284e7efb9c0950"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga105323d45e054e608d284e7efb9c0950">apop_vector_correlation</a> (const gsl_vector *ina, const gsl_vector *inb, const gsl_vector *weights)</td></tr>
<tr class="separator:ga105323d45e054e608d284e7efb9c0950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0881e9b640f6c6448014f44f5ac1f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga7c0881e9b640f6c6448014f44f5ac1f5">apop_vector_cov</a> (gsl_vector const *v1, gsl_vector const *v2, gsl_vector const *weights)</td></tr>
<tr class="separator:ga7c0881e9b640f6c6448014f44f5ac1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a77f5e6867c627fd313f3f6e252ff8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)</td></tr>
<tr class="separator:ga44a77f5e6867c627fd313f3f6e252ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5c77978dc6972e4ba52f77fb8dfef0"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gabd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a> (gsl_vector *in)</td></tr>
<tr class="separator:gabd5c77978dc6972e4ba52f77fb8dfef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032dcecb67155c527c884dd2c1cc6a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> (gsl_vector *v)</td></tr>
<tr class="separator:ga032dcecb67155c527c884dd2c1cc6a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b73de331ecf350babafa9418795860d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b73de331ecf350babafa9418795860d"></a>
gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_vector_fill_base</b> (gsl_vector *in, double[])</td></tr>
<tr class="separator:ga0b73de331ecf350babafa9418795860d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5740c698174b1a265d182f4af1c0252"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a> (const gsl_vector *in)</td></tr>
<tr class="separator:gaf5740c698174b1a265d182f4af1c0252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe3183e8a6a496f3fd6ab316687381e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaabe3183e8a6a496f3fd6ab316687381e">apop_vector_kurtosis_pop</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr class="separator:gaabe3183e8a6a496f3fd6ab316687381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a622b8360eba63795a6049c30ac54a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> (gsl_vector *v)</td></tr>
<tr class="separator:ga5a622b8360eba63795a6049c30ac54a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4a67e0b0bec8205cfe75bd3786c30e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> (gsl_vector *v)</td></tr>
<tr class="separator:ga1a4a67e0b0bec8205cfe75bd3786c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30eadf8772ecb9a2689ddf104902ea4"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf30eadf8772ecb9a2689ddf104902ea4">apop_vector_map</a> (const gsl_vector *v, double(*fn)(double))</td></tr>
<tr class="separator:gaf30eadf8772ecb9a2689ddf104902ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a135fcdd8ea6f9cbc0d518773d6c3c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaa1a135fcdd8ea6f9cbc0d518773d6c3c">apop_vector_map_sum</a> (const gsl_vector *in, double(*fn)(double))</td></tr>
<tr class="separator:gaa1a135fcdd8ea6f9cbc0d518773d6c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20e5ad95df0f24a1ea06294695031a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr class="separator:gab20e5ad95df0f24a1ea06294695031a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61185af7877b709c8b257b342c24edbc"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga61185af7877b709c8b257b342c24edbc">apop_vector_moving_average</a> (gsl_vector *, size_t)</td></tr>
<tr class="separator:ga61185af7877b709c8b257b342c24edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194ad92b1bc632ba1d13d9958c7b5b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> (gsl_vector *in, gsl_vector **out, const char normalization_type)</td></tr>
<tr class="separator:ga194ad92b1bc632ba1d13d9958c7b5b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb838084f967543fa8a03e460180d53b"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafb838084f967543fa8a03e460180d53b">apop_vector_percentiles</a> (gsl_vector *data, char rounding)</td></tr>
<tr class="separator:gafb838084f967543fa8a03e460180d53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e68deb42339cf6068ab6e741237918d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga6e68deb42339cf6068ab6e741237918d">apop_vector_print</a> (gsl_vector *data, Output_declares)</td></tr>
<tr class="separator:ga6e68deb42339cf6068ab6e741237918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d4b5805cf1a72d302fb84405215809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3d4b5805cf1a72d302fb84405215809"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_vector_print</b> (gsl_vector *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="separator:gad3d4b5805cf1a72d302fb84405215809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4658a3ecc0acfd17f610bc162fa5556"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> (gsl_vector *v, size_t newheight)</td></tr>
<tr class="separator:gaf4658a3ecc0acfd17f610bc162fa5556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eafc3727869f5ec195809ad6686ba7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8eafc3727869f5ec195809ad6686ba7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_vector_show</b> (const gsl_vector *data)</td></tr>
<tr class="separator:ga8eafc3727869f5ec195809ad6686ba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d269f1dc62b038c0da72085cac1c28"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gac9d269f1dc62b038c0da72085cac1c28">apop_vector_skew</a> (const gsl_vector *in)</td></tr>
<tr class="separator:gac9d269f1dc62b038c0da72085cac1c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb284d668d567de4810620962043f827"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gafb284d668d567de4810620962043f827">apop_vector_skew_pop</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr class="separator:gafb284d668d567de4810620962043f827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294d0269c4cbe36709130bebd893938d"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga294d0269c4cbe36709130bebd893938d">apop_vector_stack</a> (gsl_vector *v1, gsl_vector const *v2, char inplace)</td></tr>
<tr class="separator:ga294d0269c4cbe36709130bebd893938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6182181dd424bc4de98b4bfbd349b4e"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)</td></tr>
<tr class="separator:gaf6182181dd424bc4de98b4bfbd349b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga604388dc6d7d08d95bbaa4422085db9c"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> (const gsl_vector *in, char row_col)</td></tr>
<tr class="separator:ga604388dc6d7d08d95bbaa4422085db9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d68bacc086420a382366f9118cf5bc7"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> (const gsl_vector *v)</td></tr>
<tr class="separator:ga6d68bacc086420a382366f9118cf5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc397ab90933d79b3062206301a0aa0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#gadcc397ab90933d79b3062206301a0aa0">apop_vector_var</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr class="separator:gadcc397ab90933d79b3062206301a0aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2446385225c68c62ade26402c63600a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga2446385225c68c62ade26402c63600a4">apop_vector_var_m</a> (const gsl_vector *in, const double mean)</td></tr>
<tr class="separator:ga2446385225c68c62ade26402c63600a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0b078785923b7ebf991959e5fa48630e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b078785923b7ebf991959e5fa48630e"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_bernoulli</b></td></tr>
<tr class="separator:ga0b078785923b7ebf991959e5fa48630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cabd19bb6fe21b69caacb6e7c049cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6cabd19bb6fe21b69caacb6e7c049cd"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_beta</b></td></tr>
<tr class="separator:gae6cabd19bb6fe21b69caacb6e7c049cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59528acef7371d496b3d53f8f1972222"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59528acef7371d496b3d53f8f1972222"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_binomial</b></td></tr>
<tr class="separator:ga59528acef7371d496b3d53f8f1972222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289aee941407e021f68214687d656056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga289aee941407e021f68214687d656056"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_chi_squared</b></td></tr>
<tr class="separator:ga289aee941407e021f68214687d656056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618d4cbbb5b910f361766ecc99a0ffa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga618d4cbbb5b910f361766ecc99a0ffa0"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_composition</b></td></tr>
<tr class="separator:ga618d4cbbb5b910f361766ecc99a0ffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab707dc9e20143e26f6a89d0677af8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeab707dc9e20143e26f6a89d0677af8f"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_coordinate_transform</b></td></tr>
<tr class="separator:gaeab707dc9e20143e26f6a89d0677af8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd54f12eb112f8aa7502b193f32f7c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd54f12eb112f8aa7502b193f32f7c6c"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_cross</b></td></tr>
<tr class="separator:gacd54f12eb112f8aa7502b193f32f7c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8babcd9877d0f4991ee2aca9316ca6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8babcd9877d0f4991ee2aca9316ca6e"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_dconstrain</b></td></tr>
<tr class="separator:gae8babcd9877d0f4991ee2aca9316ca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac4c68d07c52e2133bea97033efb9b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ac4c68d07c52e2133bea97033efb9b2"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_dirichlet</b></td></tr>
<tr class="separator:ga0ac4c68d07c52e2133bea97033efb9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da48b7a513b0edffc1039b793d2bf1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5da48b7a513b0edffc1039b793d2bf1e"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_exponential</b></td></tr>
<tr class="separator:ga5da48b7a513b0edffc1039b793d2bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a879b97021e4187cf93d1319900e11c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a879b97021e4187cf93d1319900e11c"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_f_distribution</b></td></tr>
<tr class="separator:ga5a879b97021e4187cf93d1319900e11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343bdd2f8ac26b9dfc3aab70371dc1a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga343bdd2f8ac26b9dfc3aab70371dc1a5"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_gamma</b></td></tr>
<tr class="separator:ga343bdd2f8ac26b9dfc3aab70371dc1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad427ffccf160021bc1ce64ddcd792d9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad427ffccf160021bc1ce64ddcd792d9e"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_improper_uniform</b></td></tr>
<tr class="separator:gad427ffccf160021bc1ce64ddcd792d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126c685e799d0eec806c5819f91845cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga126c685e799d0eec806c5819f91845cc"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_iv</b></td></tr>
<tr class="separator:ga126c685e799d0eec806c5819f91845cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6cd49361e8635fd5e3e3312e8040ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b6cd49361e8635fd5e3e3312e8040ed"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_kernel_density</b></td></tr>
<tr class="separator:ga4b6cd49361e8635fd5e3e3312e8040ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9457bd24a17a8705f4ee1c8fe7807dd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9457bd24a17a8705f4ee1c8fe7807dd9"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_loess</b></td></tr>
<tr class="separator:ga9457bd24a17a8705f4ee1c8fe7807dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e8bb3aac8ce211c9ebcb7e2ef06241"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3e8bb3aac8ce211c9ebcb7e2ef06241"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_logit</b></td></tr>
<tr class="separator:gab3e8bb3aac8ce211c9ebcb7e2ef06241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc72d4e9d073dd029032675fd7c7feb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc72d4e9d073dd029032675fd7c7feb1"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_lognormal</b></td></tr>
<tr class="separator:gacc72d4e9d073dd029032675fd7c7feb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86a3bbaf8312a5c8aa3e1c4dcc53d0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad86a3bbaf8312a5c8aa3e1c4dcc53d0d"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_mixture</b></td></tr>
<tr class="separator:gad86a3bbaf8312a5c8aa3e1c4dcc53d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc96895b91ff00eda42b36b31fe0df1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bc96895b91ff00eda42b36b31fe0df1"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_multinomial</b></td></tr>
<tr class="separator:ga2bc96895b91ff00eda42b36b31fe0df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6133f5f2ed5172c4a98e51bd17a18b23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6133f5f2ed5172c4a98e51bd17a18b23"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_multivariate_normal</b></td></tr>
<tr class="separator:ga6133f5f2ed5172c4a98e51bd17a18b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74c3f0a4c9263e1f5e17c9ef873c8f02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74c3f0a4c9263e1f5e17c9ef873c8f02"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_normal</b></td></tr>
<tr class="separator:ga74c3f0a4c9263e1f5e17c9ef873c8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3d6eb287feb7e22399fcfcf5d30d0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a3d6eb287feb7e22399fcfcf5d30d0d"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_ols</b></td></tr>
<tr class="separator:ga7a3d6eb287feb7e22399fcfcf5d30d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7975faa07196cf463ec261ff0ddc3ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__opts__type.html">apop_opts_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a></td></tr>
<tr class="separator:ga7975faa07196cf463ec261ff0ddc3ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7975faa07196cf463ec261ff0ddc3ccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7975faa07196cf463ec261ff0ddc3ccc"></a>
<a class="el" href="structapop__opts__type.html">apop_opts_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_opts</b></td></tr>
<tr class="separator:ga7975faa07196cf463ec261ff0ddc3ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f90682cc2ba9b6f0f36b3ad4066b7c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f90682cc2ba9b6f0f36b3ad4066b7c4"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_pmf</b></td></tr>
<tr class="separator:ga3f90682cc2ba9b6f0f36b3ad4066b7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695d628d5c038a6ba9f9b983c483c535"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga695d628d5c038a6ba9f9b983c483c535"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_poisson</b></td></tr>
<tr class="separator:ga695d628d5c038a6ba9f9b983c483c535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2fe38172bbc4a70cbfd2077eb22dc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a2fe38172bbc4a70cbfd2077eb22dc4"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_probit</b></td></tr>
<tr class="separator:ga0a2fe38172bbc4a70cbfd2077eb22dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c08bcad3e882d38e92ad77f9296f43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04c08bcad3e882d38e92ad77f9296f43"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_t_distribution</b></td></tr>
<tr class="separator:ga04c08bcad3e882d38e92ad77f9296f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6043cdfc7c38877cd1c1c9a46ae1b231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6043cdfc7c38877cd1c1c9a46ae1b231"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_uniform</b></td></tr>
<tr class="separator:ga6043cdfc7c38877cd1c1c9a46ae1b231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17169ed9be0b026a496b8d16a11c87ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17169ed9be0b026a496b8d16a11c87ea"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_wls</b></td></tr>
<tr class="separator:ga17169ed9be0b026a496b8d16a11c87ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67e6b37ea29a900a26a2c382d1f965b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf67e6b37ea29a900a26a2c382d1f965b"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_yule</b></td></tr>
<tr class="separator:gaf67e6b37ea29a900a26a2c382d1f965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf238f568423aedb7e775a6ac259e820f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf238f568423aedb7e775a6ac259e820f"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_zipf</b></td></tr>
<tr class="separator:gaf238f568423aedb7e775a6ac259e820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gadabbf2a1717d5c76a834e090ddfcfeaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_c</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to generate a temporary one-column view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only column <code>col</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gafc073d46416446dc4f0cdb9e4f1b9a03">Apop_cs</a>, <a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>, <a class="el" href="group__all__public.html#gad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="group__all__public.html#gaaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="group__all__public.html#ga3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaf15101ec60ce66e80737375baa7391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_col_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">colname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After this call, <code>v</code> will hold a view of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. The view will consist only of a <code>gsl_vector</code> view of the column of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code> with name <code>col_name</code>. Unlike <a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, the second argument is a column name, that I'll look up using <a class="el" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>, and the third is the name of the view to be generated. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gafc073d46416446dc4f0cdb9e4f1b9a03">Apop_cs</a>, <a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, <a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>, <a class="el" href="group__all__public.html#gad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="group__all__public.html#ga3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad56ce572c7489820777290153ab7d87b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_col_tv</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After this call, <code>v</code> will hold a <code>gsl_vector</code> view of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. The view will consist only of the column with name <code>col_name</code>. Unlike <a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>, the second argument is a column name, that I'll look up using <a class="el" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>, and the third is the name of the view to be generated. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gafc073d46416446dc4f0cdb9e4f1b9a03">Apop_cs</a>, <a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, <a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>, <a class="el" href="group__all__public.html#gaaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="group__all__public.html#ga3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafc073d46416446dc4f0cdb9e4f1b9a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_cs</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">colnum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to generate a temporary view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, beginning at column <code>col</code> and having length <code>len</code>. It expires as soon as the program leaves the current scope (like with the usual automatically declared vars). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, <a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>, <a class="el" href="group__all__public.html#gad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="group__all__public.html#gaaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="group__all__public.html#ga3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga825321182fbaa7471069f13447170810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_cv</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_to_view, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to generate a temporary one-column view of the matrix in an <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only column <code>col</code>. The view is a <code>gsl_vector</code> set.</p>
<p>As usual, column -1 is the vector element of the <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_vector *v = Apop_cv(your_data, i);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;for (int i=0; i&lt; your_data-&gt;matrix-&gt;size2; i++)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    printf(&quot;Σ_%i = %g\n&quot;, i, apop_vector_sum(Apop_c(your_data, i)));</div>
</div><!-- fragment --><p>The view is automatically allocated, and disappears as soon as the program leaves the scope in which it is declared.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gafc073d46416446dc4f0cdb9e4f1b9a03">Apop_cs</a>, <a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, <a class="el" href="group__all__public.html#gad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="group__all__public.html#gaaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="group__all__public.html#ga3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeca6159c82c21da0db82ae9ed0582dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_add_names</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a list of names to a data set.</p>
<ul>
<li>Use this with a list of names that you type in yourself, like <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data_add_names(mydata, &#39;c&#39;, &quot;age&quot;, &quot;sex&quot;, &quot;height&quot;);</div>
</div><!-- fragment --> Notice the lack of curly braces around the list.</li>
</ul>
<ul>
<li>You may have an array of names, probably autogenerated, that you would like to add. In this case, make certain that the last element of the array is <code>NULL</code>, and call the base function: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char **[] colnames = {&quot;age&quot;, &quot;sex&quot;, &quot;height&quot;, NULL};</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_add_names_base(mydata, &#39;c&#39;, colnames);</div>
</div><!-- fragment --> But if you forget the <code>NULL</code> marker, this has good odds of segfaulting. You may prefer to use a <code>for</code> loop that inserts each name in turn using <a class="el" href="group__all__public.html#gae32d4f48cff7788b617d40155703ae64">apop_name_add</a>.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gae32d4f48cff7788b617d40155703ae64">apop_name_add</a>, although <a class="el" href="group__all__public.html#gaeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a> will be more useful in most cases. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb6b2c53478f9db902ba0340ba499819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_falloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sizes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a data set and fill it with values. Put the data set dimensions (one, two, or three dimensions as per <a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>) in parens, then the data (as per <a class="el" href="group__all__public.html#gad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>). E.g.: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *identity2 = apop_data_falloc((2,2),</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                         1, 0,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                         0, 1);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;apop_data *count_vector = apop_data_falloc((5), 0, 1, 2, 3, 4);</div>
</div><!-- fragment --><p>If you forget the parens, you will get an obscure error during compilation.</p>
<ul>
<li>This is a simple macro wrapping <a class="el" href="group__all__public.html#gad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a> and <a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>, because they appear together so often. The second example expands to: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *count_vector = apop_data_fill(apop_data_alloc(5), 0, 1, 2, 3, 4);</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="gad6be56d710a63aa1ceadf2242c553905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_fill</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adfin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a pre-allocated data set with values.</p>
<p>For example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;apop.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int main(){</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    apop_data *a =apop_data_alloc(2,2,2);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    double    eight   = 8.0;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    apop_data_fill(a, 8, 2.2, eight/2,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;                      0, 6.0, eight);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    apop_data_show(a);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
</div><!-- fragment --><p>Warning: I need as many arguments as the size of the data set, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your matrix with garbage or a simple segfault.</p>
<p>Underlying this function is a base function that takes a single list, as opposed to a set of unassociated numbers as above:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;apop.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int main(){</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  apop_data *a =apop_data_alloc(2,2,2);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  double    eight   = 8.0;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  double list[] = {8, 2.2, eight/2, </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;                   0, 6.0, eight};</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    apop_data_fill_base(a, list);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    apop_data_show(a);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adfin</td><td>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of at least as many floating-point values as there are blanks in the data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the same data set that was input.</dd></dl>
<ul>
<li>I assume that <code>vector-&gt;size==matrix-&gt;size1</code>; otherwise I just use <code>matrix-&gt;size1</code>.</li>
</ul>
<ul>
<li>See also <a class="el" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a> to allocate and fill on one line. E.g., to generate a unit vector for three dimensions: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *unit_vector = apop_data_falloc((3), 1, 1, 1);</div>
</div><!-- fragment --></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>, <a class="el" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>, <a class="el" href="group__all__public.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga459acfde11f2c39f5c32cff377f85b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">freeme</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an <a class="el" href="gentle.html#apop_data">apop_data</a> structure.</p>
<ul>
<li>As with <code>free()</code>, it is safe to send in a <code>NULL</code> pointer (in which case the function does nothing). </li>
<li>If the <code>more</code> pointer is not <code>NULL</code>, I will free the pointed-to data set first. If you don't want to free data sets down the chain, set <code>more=NULL</code> before calling this. </li>
<li>This is actually a macro (that calls <a class="el" href="group__all__public.html#ga3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> to do the real work). It sets <code>freeme</code> to <code>NULL</code> when it's done, because there's nothing safe you can do with the freed location, and you can later safely test conditions like <code>if (data) ...</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5ea849ee3c044e95eafb7b79124ce844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_prune_columns</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep only the columns of a data set that you name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">...</td><td>A list of names to retain (i.e. the columns that shouldn't be pruned out). For example, if you have run <a class="el" href="group__all__public.html#ga253dba4ed7f5c03107d38c1268b46c01">apop_data_summarize</a>, you have columns for several statistics, but may care about only one or two; see the example.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* This sample produces a dummy times table, gets a summary, and prunes the summary table.</span></div>
<div class="line"><span class="comment">If you are not a test script, uncomment the last line to display the pruned table.  */</span></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">int</span> i, j;</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(0, 10, 4);</div>
<div class="line">    <span class="keywordflow">for</span> (i=0; i&lt; 10; i++)</div>
<div class="line">        <span class="keywordflow">for</span> (j=0; j&lt; 4; j++)</div>
<div class="line">            <a class="code" href="group__all__public.html#ga5bdc618669b9ddc8239595d7b50bec9e">apop_data_set</a>(d, i, j, i*j);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *summary = <a class="code" href="group__all__public.html#ga253dba4ed7f5c03107d38c1268b46c01">apop_data_summarize</a>(d);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(summary, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;mean&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;median&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;max&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;variance&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(summary, .row=0, .colname=<span class="stringliteral">&quot;mean&quot;</span>)==0);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(summary, .row=1, .colname=<span class="stringliteral">&quot;median&quot;</span>)==4);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(summary, .row=2, .colname=<span class="stringliteral">&quot;median&quot;</span>)==8);</div>
<div class="line">    <span class="comment">//apop_data_show(summary);</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>I use a case-insensitive search to find your column. </li>
<li>If your name multiple columns, I'll only give you the first. </li>
<li>If I can't find a column matching one of your strings, I throw an error to the screen and continue. </li>
<li>This is a macro calling <a class="el" href="group__all__public.html#gad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a>. It packages your list of columns into a list of strings, adds a <code>NULL</code> string at the end, and calls that function. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga33c353f768fb4b0e7a3f98ab7a546ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_estimate_r_squared</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A synonym for <a class="el" href="group__all__public.html#ga704e8625a022360600919116bc20ffbb">apop_estimate_coefficient_of_determination</a>, q.v. </p>

</div>
</div>
<a class="anchor" id="gabbdfc523f5b269827db8cebf28216e28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_gaussian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> distribution, qv. </p>

</div>
</div>
<a class="anchor" id="ga3e7f99e26eb4d5d5438fd5fa16fcadde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_matrix_col</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>View a single column of a <code>gsl_matrix</code> as a <code>gsl_vector</code>. This is a convenience macro wrapping <code>gsl_matrix_column</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>gsl_matrix</code> </td></tr>
    <tr><td class="paramname">col</td><td>The number of the desired column. </td></tr>
    <tr><td class="paramname">v</td><td>The name of the vector view that will be created.</td></tr>
  </table>
  </dd>
</dl>
<p>An: example </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_matrix *m = [fill matrix here];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Apop_matrix_col(m, 2, coltwo);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Apop_matrix_col(m, 3, colthree);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;printf(&quot;The correlation coefficient between columns two &quot;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;       &quot;and three is %g.\n&quot;, apop_vector_correlation(coltwo, colthree));</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gafc073d46416446dc4f0cdb9e4f1b9a03">Apop_cs</a>, <a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, <a class="el" href="group__all__public.html#ga825321182fbaa7471069f13447170810">Apop_cv</a>, <a class="el" href="group__all__public.html#gad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="group__all__public.html#gaaaf15101ec60ce66e80737375baa7391">Apop_col_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9abee86763f92d505fd4fb792f06fd7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_matrix_row</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>View a single row of a <code>gsl_matrix</code> as a <code>gsl_vector</code>. This is a convenience macro wrapping <code>gsl_matrix_row</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>gsl_matrix</code> </td></tr>
    <tr><td class="paramname">row</td><td>The number of the desired row. </td></tr>
    <tr><td class="paramname">v</td><td>The name of the vector view that will be created.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__all__public.html#ga105323d45e054e608d284e7efb9c0950">apop_vector_correlation</a> for an example of use.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga585f5cf3125fb5fc875dea85980eabd1">Apop_rs</a>, <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, Apop_row_v, <a class="el" href="group__all__public.html#ga6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="group__all__public.html#ga7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b0289d499a3dfa51a0c6fc689505cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_mean</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mean of the elements of the vector <code>v</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A gsl_vector.</td></tr>
  </table>
  </dd>
</dl>
<p>An alias for <a class="el" href="group__all__public.html#gab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a>. Returns the mean of the data in the given vector. </p>

</div>
</div>
<a class="anchor" id="ga15d9e73643bf66f7d69c7ebf959757aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_coordinate_transform</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build an <a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a> model. See its documentation for details and an example.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of <a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a> and is appropriately set up.</dd></dl>
<ul>
<li>Uses the <a class="el" href="structapop__ct__settings.html">apop_ct_settings</a> group. This macro takes elements of that struct as inputs.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga8e5f7950ae47b299e20f2c447199cf6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_copy_set</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">model, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a model and add a settings group. Useful for models that require a settings group to function. See <a class="el" href="group__all__public.html#ga8fb1877a3cc29edd685a68dd6b4a35dc">Apop_settings_add_group</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly-prepped model. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbc21644ccf24f498a3b3a7e94758e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_cross</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a model consisting of the cross product of several independent models. The output <a class="el" href="structapop__model.html">apop_model</a> is a copy of <a class="el" href="group__models.html#ga7d33309b547d525c7325c062f4bc774f">apop_cross</a>; see that model's documentation for details.</p>
<p>Sample use:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_model *m1 = apop_model_set_parameters(apop_normal, 0, 1);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_model *m2 = apop_model_copy(m1);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_model *m3 = apop_model_copy(m1);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;apop_model *two_independent_normals = apop_model_cross(n1, n2);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;apop_model *three_independent_normals = apop_model_cross(n1, n2, n3);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;//But you don&#39;t have to parameterize ahead of time. E.g.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;apop_model *two_n = apop_model_cross(</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                apop_model_copy(apop_normal),</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                apop_model_copy(apop_normal)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                );</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;apop_model *estimated_norms = apop_estimate(indata, two_n);</div>
</div><!-- fragment --><ul>
<li>If you input only one model, return a copy of that model; print a warning iff <code>apop_opts.verbose &gt;= 1</code>. <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error=='n'</td><td>First model input is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gab664f68b5e481bec56c8ddc7f16928c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_dcompose</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>Data composition</em> is using either random draws or parameter estimates from the output of one model as the input data for another model.</p>
<ul>
<li>The <a class="el" href="group__models.html#gaedd07c678027bea683f48aa8617c4b89">apop_dcomposition</a> model relies on the <a class="el" href="structapop__composition__settings.html">apop_composition_settings</a> struct, qv. This macro takes the elements of that struct as input. You can use the designated initializer syntax to specify them.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of the <code>apop_composition</code> model. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34644b9d55c7528b47f0b887c9241928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_dconstrain</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build an <code>apop_dconstrain</code> model, q.v., which applies a data constraint to the data set. For example, this is how one would truncate a model to have data above zero.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a> and is appropriately set up.</dd></dl>
<ul>
<li>Uses the <a class="el" href="structapop__dconstrain__settings.html">apop_dconstrain_settings</a> group. This macro takes elements of that struct as inputs.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga40bb98b02fde8f8e4ab59a4d127b692f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_mixture</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a model as a linear combination of other models. See the documentation for the <a class="el" href="group__models.html#gaf085564a8adc67ba156c4cd1db8145e3">apop_mixture</a> model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>A list of models, either all parameterized or all unparameterized. See examples in the <a class="el" href="group__models.html#gaf085564a8adc67ba156c4cd1db8145e3">apop_mixture</a> documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36cae46a2950eb6cfb65794cdd5dac7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_set_parameters</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take in an unparameterized <code><a class="el" href="structapop__model.html">apop_model</a></code> and return a new <code><a class="el" href="structapop__model.html">apop_model</a></code> with the given parameters. For example, if you need a N(0,1) quickly: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_model *std_normal = apop_model_set_parameters(apop_normal, 0, 1);</div>
</div><!-- fragment --><p>This doesn't take in data, so it won't work with models that take the number of parameters from the data, and it will only set the vector of the model's parameter <a class="el" href="gentle.html#apop_data">apop_data</a> set. This is most standard models, so that's not a real problem either. If you have a situation where these options are out, you'll have to do something like <code><a class="el" href="structapop__model.html">apop_model</a> *new = apop_model_copy(in); apop_prep(your_data, new);</code> and then set <code>in-&gt;parameters</code> using your data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An unparameterized model, like <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> or <a class="el" href="group__models.html#ga9c67838a4761452cc2c9113557f2a070">apop_poisson</a>. </td></tr>
    <tr><td class="paramname">...</td><td>The list of parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the input model, with parameters set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error: you gave me a model with an indeterminate number of parameters. Set <code></code>.vsize or <code></code>.msize1 and <code></code>.msize2 first, then call this function, or use <code><a class="el" href="structapop__model.html">apop_model</a> *new = apop_model_copy(in); apop_prep(your_data, new);</code> and then call this (because <a class="el" href="group__all__public.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> is required to correctly allocate <code>new-&gt;parameters</code> to conform to your data). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga674b73c9b8813f35e41009428cbc80f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_notify</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">verbosity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify the user of errors, warning, or debug info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbosity</td><td>At what verbosity level should the user be warned? E.g., if level==2, then print iff apop_opts.verbosity &gt;= 2. </td></tr>
    <tr><td class="paramname">...</td><td>The message to write to STDERR (presuming the verbosity level is high enough). This can be a printf-style format with following arguments. You can produce much more informative error messages this way, e.g., <code>apop_notify</code>(0, "Beta is %g but should be greater than zero.", beta);. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga401dbc60c9915be8e4c4def68b22d755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_r</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rownum&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to generate a temporary one-row view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only row <code>row</code>. The view is also an <a class="el" href="gentle.html#apop_data">apop_data</a> set, with names and other decorations. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *v = Apop_r(your_data, i);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;for (int i=0; i&lt; your_data-&gt;matrix-&gt;size1; i++)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    apop_data_print(Apop_r(your_data, i));</div>
</div><!-- fragment --><p>The view is automatically allocated, and disappears as soon as the program leaves the scope in which it is declared. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga585f5cf3125fb5fc875dea85980eabd1">Apop_rs</a>, Apop_row_v, <a class="el" href="group__all__public.html#ga6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="group__all__public.html#ga7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="group__all__public.html#ga9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e829ce2396bf05ab10460bcc37aeeab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_rng_get_thread</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thread_in</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>gsl_rng</code> is not itself thread-safe, in the sense that it can not be used simultaneously by multiple threads. However, if each thread has its own <code>gsl_rng</code>, then each will safely operate independently.</p>
<p>Thus, Apophenia keeps an internal store of RNGs for use by threaded functions. If the input to this function, <code>thread</code>, is greater than any previous input, then the array of <code>gsl_rng</code>s is extended to length <code>thread</code>, and each element extended using <code>++apop_opts.rng_seed</code> (i.e., the seed is incremented before use).</p>
<p>This function can be used anywhere a gsl_rng would be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_in</td><td>The number of the RNG to retrieve, starting at zero (which is how OpenMP numbers its threads). If -1, I'll look up the current thread (via <code>omp_get_thread_num</code>) for you.</td></tr>
  </table>
  </dd>
</dl>
<p>See threading for additional notes. In most cases, you want to use <code>apop_rng_get_thread(-1)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The appropriate RNG, initialized if necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d87af4e65acbf6982a34cf3dc33eae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_row_t</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rowname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After this call, <code>v</code> will hold an <a class="el" href="gentle.html#apop_data">apop_data</a> view of an <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. The view will consist only of the row with name <code>row_name</code>. Unlike <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, the second argument is a row name, that I'll look up using <a class="el" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>, and the third is the name of the view to be generated. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga585f5cf3125fb5fc875dea85980eabd1">Apop_rs</a>, <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, <a class="el" href="group__all__public.html#ga314f28de914dfe6e45170e09d71d5429">Apop_rv</a>, <a class="el" href="group__all__public.html#ga6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="group__all__public.html#ga9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6396c26f1d47cced2be3a761185d3b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_row_tv</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After this call, <code>v</code> will hold a <code>gsl_vector</code> view of an <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. The view will consist only of the row with name <code>row_name</code>. Unlike <a class="el" href="group__all__public.html#ga314f28de914dfe6e45170e09d71d5429">Apop_rv</a>, the second argument is a row name, that I'll look up using <a class="el" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>, and the third is the name of the view to be generated. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga585f5cf3125fb5fc875dea85980eabd1">Apop_rs</a>, <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, <a class="el" href="group__all__public.html#ga314f28de914dfe6e45170e09d71d5429">Apop_rv</a>, <a class="el" href="group__all__public.html#ga7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="group__all__public.html#ga9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga585f5cf3125fb5fc875dea85980eabd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_rs</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rownum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to generate a temporary view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, beginning at row <code>row</code> and having length <code>len</code>. The view expires as soon as the program leaves the current scope (like with the usual automatically declared vars). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, <a class="el" href="group__all__public.html#ga314f28de914dfe6e45170e09d71d5429">Apop_rv</a>, <a class="el" href="group__all__public.html#ga6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="group__all__public.html#ga7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="group__all__public.html#ga9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga314f28de914dfe6e45170e09d71d5429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_rv</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_to_view, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to generate a temporary one-row view of the matrix in an <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only row <code>row</code>. The view is a <code>gsl_vector</code> set.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_vector *v = Apop_rv(your_data, i);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;for (int i=0; i&lt; your_data-&gt;matrix-&gt;size1; i++)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    printf(&quot;Σ_%i = %g\n&quot;, i, apop_vector_sum(Apop_r(your_data, i)));</div>
</div><!-- fragment --><p>The view is automatically allocated, and disappears as soon as the program leaves the scope in which it is declared. </p><dl class="section see"><dt>See also</dt><dd>Apop_rows, Apop_row_v, <a class="el" href="group__all__public.html#ga6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="group__all__public.html#ga7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="group__all__public.html#ga9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fb1877a3cc29edd685a68dd6b4a35dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_add_group</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">model, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a settings group. The first two arguments (the model you are attaching to and the settings group name) are mandatory, and then you can use the <a class="el" href="designated.html">Designated initializers</a> syntax to specify default values (if any). </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the newly-prepped group.</dd></dl>
<p>See <a class="el" href="modelsec.html#modelsettings">Settings groups</a> or <a class="el" href="maxipage.html">Optimization</a> for examples.</p>
<ul>
<li>If a settings group of the given type is already attached to the model, the previous version is removed. Use <a class="el" href="group__all__public.html#ga4ba53402807c9e6b82254fb552029501">Apop_settings_get</a> to check whether a group of the given type is already attached to a model, and <a class="el" href="group__all__public.html#ga8659282b6003f7c2adac6f4baad5fae4">Apop_settings_set</a> to modify an existing group. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga47600802191d9ccf5d48fce70e754294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_copy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience macro for declaring the copy function for a new settings group. See <a class="el" href="modeldetails.html#settingswriting">Writing new settings groups</a> for details and an example. </p>

</div>
</div>
<a class="anchor" id="ga833e962fb042462eeadada7484671f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience macro for declaring the delete function for a new settings group. See <a class="el" href="modeldetails.html#settingswriting">Writing new settings groups</a> for details and an example. </p>

</div>
</div>
<a class="anchor" id="ga4ba53402807c9e6b82254fb552029501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">model, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">setting&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a setting from a model. See <a class="el" href="group__all__public.html#gaafba071ab93465fed4cac1020082b4c8">Apop_settings_get_group</a> to pull the entire group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>. </td></tr>
    <tr><td class="paramname">type</td><td>A string giving the type of the settings group you are retrieving, without the <code>_settings</code> ending. E.g., for an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group, use <code>apop_mle</code>. </td></tr>
    <tr><td class="paramname">setting</td><td>The struct element you want to retrieve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaafba071ab93465fed4cac1020082b4c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_get_group</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a settings group from a model. See <a class="el" href="group__all__public.html#ga4ba53402807c9e6b82254fb552029501">Apop_settings_get</a> to just pull a single item from within the settings group.</p>
<p>This macro returns NULL if a group of type <code>type_settings</code> isn't found attached to model <code>m</code>, so you can easily put it in a conditional like </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if (!apop_settings_get_group(m, &quot;apop_ols&quot;)) ...</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An <a class="el" href="structapop__model.html">apop_model</a> </td></tr>
    <tr><td class="paramname">type</td><td>A string giving the type of the settings group you are retrieving. E.g., for an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group, use <code>apop_mle</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the desired struct (or <code>NULL</code> if not found). </dd></dl>

</div>
</div>
<a class="anchor" id="gaefe030e4bba4671d8b026e81be70f764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience macro for declaring the initialization function for a new settings group. See <a class="el" href="modeldetails.html#settingswriting">Writing new settings groups</a> for details and an example. </p>

</div>
</div>
<a class="anchor" id="ga4ff4361f65c1e848fabce24b4b8f44f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_rm_group</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a settings group from a model's list.</p>
<ul>
<li>If the so-named group is not found, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga8659282b6003f7c2adac6f4baad5fae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_settings_set</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">model, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">setting, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modifies a single element of a settings group to the given value.</p>
<ul>
<li>If <code>model==NULL</code>, fails silently. </li>
<li>If <code>model!=NULL</code> but the given settings group is not found attached to the model, set <code>model-&gt;error='s'</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="gabd17601e642688d033f62d346f3dace6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_stopif</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">onfail, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute an action and print a message to the current <code>FILE</code> handle held by <code>apop_opts.log_file</code> (default: <code>stderr</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>The expression that, if true, triggers the action. </td></tr>
    <tr><td class="paramname">onfail</td><td>If the assertion fails, do this. E.g., <code>out-&gt;error='x'; return GSL_NAN</code>. Notice that it is OK to include several lines of semicolon-separated code here, but if you have a lot to do, the most readable option may be <code>goto outro</code>, plus an appropriately-labeled section at the end of your function. </td></tr>
    <tr><td class="paramname">level</td><td>Print the warning message only if <a class="el" href="structapop__opts__type.html">apop_opts.verbose</a> is greater than or equal to this. Zero usually works, but for minor infractions use one, or for more verbose debugging output use 2. </td></tr>
    <tr><td class="paramname">...</td><td>The error message in printf form, plus any arguments to be inserted into the printf string. I'll provide the function name and a carriage return.</td></tr>
  </table>
  </dd>
</dl>
<p>Some examples:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;//the typical case, stopping function execution:</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Apop_stopif(isnan(x), return NAN, 0, &quot;x is NAN; failing&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;//Mark a flag, go to a cleanup step</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Apop_stopif(x &lt; 0, needs_cleanup=1; goto cleanup, 0, &quot;x is %g; cleaning up and exiting.&quot;, x);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;//Print a diagnostic iff &lt;tt&gt;apop_opts.verbose&gt;=1&lt;/tt&gt; and continue</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Apop_stopif(x &lt; 0,  , 1, &quot;warning: x is %g.&quot;, x);</div>
</div><!-- fragment --><ul>
<li>If <code>apop_opts.stop_on_warning</code> is nonzero and not <code>'v'</code>, then a failed test halts via <code>abort()</code>, even if the <code>apop_opts.verbose</code> level is set so that the warning message doesn't print to screen. Use this when running via debugger. </li>
<li>If <code>apop_opts.stop_on_warning</code> is <code>'v'</code>, then a failed test halts via <code>abort()</code> iff the verbosity level is high enough to print the error. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad0375e20079df9652337e39c1317a14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_subm</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_to_view, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">srow, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scol, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nrows, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ncols&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the mean of the input vector. Generate a view of a submatrix within a <code>gsl_matrix</code>. Like <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, et al., the view is an automatically-allocated variable that is lost once the program flow leaves the scope in which it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_to_view</td><td>The root matrix </td></tr>
    <tr><td class="paramname">srow</td><td>the first row (in the root matrix) of the top of the submatrix </td></tr>
    <tr><td class="paramname">scol</td><td>the first column (in the root matrix) of the left edge of the submatrix </td></tr>
    <tr><td class="paramname">nrows</td><td>number of rows in the submatrix </td></tr>
    <tr><td class="paramname">ncols</td><td>number of columns in the submatrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An automatically-allocated view of type c . </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b05181ceec857e9eb9ed6a8ea7423d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_sum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for <a class="el" href="group__all__public.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>. Returns the sum of the data in the given vector. </p>

</div>
</div>
<a class="anchor" id="ga74dca50ea16ed7bf25cb152315642769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_text_fill</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the text part of an already-allocated <a class="el" href="gentle.html#apop_data">apop_data</a> set with a list of strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>A data set that you already prepared with <a class="el" href="group__all__public.html#ga9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>. </td></tr>
    <tr><td class="paramname">...</td><td>A list of strings. The first row is filled first, then the second, and so on to the end of the text grid.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>No <code>NULL</code> strings. A blank string, <code>""</code> is OK. </li>
<li>If you provide more or fewer strings than are needed to fill the text grid and <code>apop_opts.verbose &gt;=1</code>, I print a warning and continue to the end of the text grid or data set, whichever is shorter. </li>
<li>If the data set is <code>NULL</code>, I return <code>NULL</code>. If you provide a <code>NULL</code> data set but a non-NULL list of text elements, and <code>apop_opts.verbose &gt;=1</code>, I print a warning and return <code>NULL</code>. </li>
<li>Remember that the C preprocessor concatenates two adjacent strings into one. Here is an attempt to fill a <img class="formulaInl" alt="$ 2\times 3$" src="form_8.png"/> grid: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *one23 = apop_text_fill(apop_text_alloc(NULL, 2, 3),</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                                   &quot;one&quot;, &quot;two&quot;, &quot;three&quot;   //missing comma!</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                                   &quot;two&quot;, &quot;four&quot;, &quot;six&quot;);</div>
</div><!-- fragment --> The preprocessor will join <code>"three" "two"</code> to form <code>"threetwo"</code>, leaving you with only five strings.</li>
</ul>
<ul>
<li>If you have a <code>NULL-delimited</code> array of strings (not just a loose list as above), then use <code>apop_text_fill_base</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae9308d562a120c8302edde3f736bc25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_var</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for <a class="el" href="group__all__public.html#gadcc397ab90933d79b3062206301a0aa0">apop_vector_var</a>. Returns the variance of the data in the given vector. </p>

</div>
</div>
<a class="anchor" id="gaf9b051e2fbe0e473dddeabfe4932ce0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_vector_fill</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">avfin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a pre-allocated <code>gsl_vector</code> with values.</p>
<p>See <code>apop_data_alloc</code> for a relevant example. See also <code>apop_matrix_alloc</code>.</p>
<p>Warning: I need as many arguments as the size of the vector, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your vector with garbage or a simple segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avfin</td><td>A <code>gsl_vector</code> (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of exactly as many values as there are spaces in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the same vector that was input. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga0c8c2a99fb8c6ec54822aca08591545e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__data.html">apop_data</a>  <a class="el" href="structapop__data.html">apop_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure represents a data set. It primarily joins together a gsl_vector, a gsl_matrix, and a table of strings, then gives them all row and column names. It tries to be minimally intrusive, so you can use it everywhere you would use a <code>gsl_matrix</code> or a <code>gsl_vector</code>.</p>
<p>Here is a diagram showing a sample data set with all of the elements in place. Together, they represet a data set where each row is an observation, which includes both numeric and text values, and where each row/column is named.</p>
<table frame=box>
<tr>
<td>Rowname</td><td>Vector</td><td> Matrix</td><td> Text</td><td>Weights</td>
</tr><tr valign=bottom>
<td align=center>
<table frame=box>
<tr><td> </td></tr>
<tr>
<td>"Steven"</td>
</tr><tr>
<td>"Sandra"</td>
</tr><tr>
<td>"Joe"</td><td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th>Outcome</th>
</tr> <tr>
<td align=center>1</td>
</tr><tr>
<td align=center>0</td>
</tr><tr>
<td align=center>1</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th> Age</th><th> Weight (kg)</th><th> Height (cm)</th>
</tr> <tr>
<td> 32</td><td> 65</td><td> 175</td>
</tr><tr>
<td> 41</td><td> 61</td><td> 165</td>
</tr><tr>
<td> 40</td><td> 73</td><td> 181</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th> Sex</th><th> State</th>
</tr>
<tr>
<td> Male</td><td> Alaska</td><td>
</tr><tr>
<td> Female</td><td> Alabama</td>
</tr><tr>
<td> Male</td><td> Alabama</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr><td> </td></tr>
<tr>
<td>1</td>
</tr><tr>
<td>3.2</td>
</tr><tr>
<td>2.4</td>
</tr> 
</table>
</td></tr>
</table>
 <p>Allocate using <code>apop_data_alloc</code>, free via <code>apop_data_free</code>, or more generally, see the <code>apop_data_</code>... section of the index (in the header links) for the many other functions that operate on this struct.</p>
<p>See also <a class="el" href="dataoverview.html">Data sets</a> for further notes on getting and manipulating the elements of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. </p>

</div>
</div>
<a class="anchor" id="ga3441b2386cb4d58601e5caf7ca4a1465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__mcmc__proposal__s.html">apop_mcmc_proposal_s</a>  <a class="el" href="structapop__mcmc__proposal__s.html">apop_mcmc_proposal_s</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A proposal distribution for <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> and its accompanying functions and information. By default, these will be <a class="el" href="group__models.html#ga3a4389e6e2a1a2ea606f89d55ec558d3">apop_multivariate_normal</a> models. The <code>step_fn</code> and <code>adapt_fn</code> have to be written around the model and your preferences. For the defaults, the step function recenters the mean of the distribution around the last accepted proposal, and the adapt function widens the Σ for the Normal if the accept rate is too low; narrows it if the accept rate is too large.</p>
<p>You may provide an array of proposals. The length of the list of proposals must match the number of chunks, as per the <code>gibbs_chunks</code> setting in the <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group that the array of proposals is a part of. Each proposal must be initialized to include all elements, and the step and adapt functions probably have to be written anew for each type of model.</p>
<p>This segment of the interface is in beta. A future revision may make it easier to design new proposals. </p>

</div>
</div>
<a class="anchor" id="gae7b8fd387aa53bca1a8dedab0dd99a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a>  <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method settings for a model to be put through Bayesian updating. </p>

</div>
</div>
<a class="anchor" id="gafe86ae10fc82d219906211e4f88e4cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__model.html">apop_model</a> <a class="el" href="structapop__model.html">apop_model</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A statistical model. See <a class="el" href="modelsec.html">Models</a> for details. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1309242dbb7f148916c71a9a70c6b64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_anova </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grouping1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grouping2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function produces a traditional one- or two-way ANOVA table. It works from data in an SQL table, using queries of the form <code>select data from table group by grouping1, grouping2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to be queried. Anything that can go in an SQL <code>from</code> clause is OK, so this can be a plain table name or a temp table specification like <code>(select ... )</code>, with parens. </td></tr>
    <tr><td class="paramname">data</td><td>The name of the column holding the count or other such data </td></tr>
    <tr><td class="paramname">grouping1</td><td>The name of the first column by which to group data </td></tr>
    <tr><td class="paramname">grouping2</td><td>If this is <code>NULL</code>, then the function will return a one-way ANOVA. Otherwise, the name of the second column by which to group data in a two-way ANOVA. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0492d6f5ae8a73a60b651cadb113d643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_arms_draw </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive rejection metropolis sampling. </p>
<p>Make random draws from a univariate distribution.</p>
<p>The author, Wally Gilks, explains on <a href="http://www.amsta.leeds.ac.uk/~wally.gilks/adaptive.rejection/web_page/Welcome.html">http://www.amsta.leeds.ac.uk/~wally.gilks/adaptive.rejection/web_page/Welcome.html</a> , that ``ARS works by constructing an envelope function of the log of the target density, which is then used in rejection sampling (see, for example, Ripley, 1987). Whenever a point is rejected by ARS, the envelope is updated to correspond more closely to the true log density, thereby reducing the chance of rejecting subsequent points. Fewer ARS rejection steps implies fewer point-evaluations of the log density.''</p>
<ul>
<li>It accepts only functions with univariate inputs. I.e., it will put a single value in the vector part of a <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then evaluate the log likelihood at that point. For multivariate situations, see <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a>.</li>
</ul>
<ul>
<li>It is currently the default for the <a class="el" href="group__all__public.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a> function given a univariate model, so you can just call that if you prefer.</li>
</ul>
<ul>
<li>There are a great number of parameters, in the <code><a class="el" href="structapop__arms__settings.html">apop_arms_settings</a></code> structure. The structure also holds a history of the points tested to date. That means that the system will be more accurate as more draws are made. It also means that if the parameters change, or you use <a class="el" href="group__all__public.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>, you should call <code><a class="el" href="group__all__public.html#ga4ff4361f65c1e848fabce24b4b8f44f7">Apop_settings_rm_group(your_model, apop_arms)</a></code> to clear the model of points that are not valid for a different situation. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga8abdcdbaceaaf0dd3882a164bc2565de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_array_to_vector </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a one-dimensional array to a <code>gsl_vector</code>. The input array is undisturbed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An array of <code>double</code>s. (No default. Must not be <code>NULL</code>); </td></tr>
    <tr><td class="paramname">size</td><td>How long <code>line</code> is. If this is zero or omitted, I'll guess using the <code>sizeof(line)/sizeof(line[0])</code> trick, which will work for most arrays allocated using <code>double []</code> and won't work for those allocated using <code>double *</code>. (default = auto-guess) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>gsl_vector</code>, allocated and filled with a copy of (not a pointer to) the input data.</dd></dl>
<ul>
<li>If you send in a <code>NULL</code> vector, you get a <code>NULL</code> pointer in return. I warn you of this if <code>apop_opts.verbosity &gt;=1 </code>.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga69adca14afc66100168f585e05b59dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_beta_from_mean_var </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Beta distribution is useful for modeling because it is bounded between zero and one, and can be either unimodal (if the variance is low) or bimodal (if the variance is high), and can have either a slant toward the bottom or top of the range (depending on the mean).</p>
<p>The distribution has two parameters, typically named <img class="formulaInl" alt="$\alpha$" src="form_4.png"/> and <img class="formulaInl" alt="$\beta$" src="form_5.png"/>, which can be difficult to interpret. However, there is a one-to-one mapping between (alpha, beta) pairs and (mean, variance) pairs. Since we have good intuition about the meaning of means and variances, this function takes in a mean and variance, calculates alpha and beta behind the scenes, and returns the appropriate Beta distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mean the Beta distribution should have. Notice that m is in [0,1].</td></tr>
    <tr><td class="paramname">v</td><td>The variance which the Beta distribution should have. It is in (0, 1/12), where (1/12) is the variance of a Uniform(0,1) distribution. Funny things happen with variance near 1/12 and mean far from 1/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="structapop__model.html">apop_model</a> produced by copying the <code>apop_beta</code> model and setting its parameters appropriately.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='r'</td><td>Range error: mean is not within [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4eb57b1f864c650ed6d7e029550e7bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_bootstrap_cov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>keep_boots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ignore_nans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give me a data set and a model, and I'll give you the bootstrapped covariance matrix of the parameter estimates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. An <code><a class="el" href="structapop__data.html">apop_data</a></code> set where each row is a single data point. (No default) </td></tr>
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>, whose <code>estimate</code> method will be used here. (No default) </td></tr>
    <tr><td class="paramname">iterations</td><td>How many bootstrap draws should I make? (default: 1,000) </td></tr>
    <tr><td class="paramname">rng</td><td>An RNG that you have initialized, probably with <code>apop_rng_alloc</code>. (Default: an RNG from <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>) </td></tr>
    <tr><td class="paramname">keep_boots</td><td>If 'y', then add a page to the output <a class="el" href="gentle.html#apop_data">apop_data</a> set with the statistics calculated for each bootstrap iteration. They are packed via <a class="el" href="group__all__public.html#ga90feb5dd661cfe0f0b53a85295b8b56e">apop_data_pack</a>, so use <a class="el" href="group__all__public.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> if needed. (Default: 'n') <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *boot_output = apop_bootstrap_cov(your_data, your_model, .keep_boots=&#39;y&#39;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data *boot_stats = apop_data_get_page(boot_output, &quot;&lt;bootstrapped statistics&gt;&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;printf(&quot;The statistics calculated on the 28th iteration:\n&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;gsl_vector *row_27 = Apop_rv(boot_stats, 27);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;apop_data_print(apop_data_unpack(row_27));</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramname">ignore_nans</td><td>If <code>'y'</code> and any of the elements in the estimation return <code>NaN</code>, then I will throw out that draw and try again. If <code>'n'</code>, then I will write that set of statistics to the list, <code>NaN</code> and all. I keep count of throw-aways; if there are more than <code>iterations</code> elements thrown out, then I throw an error and return with estimates using data I have so far. That is, I assume that <code>NaNs</code> are rare edge cases; if they are as common as good data, you might want to rethink how you are using the bootstrap mechanism. (Default: 'n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set whose matrix element is the estimated covariance matrix of the parameters. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='n'</td><td><code>NULL</code> input data. </td></tr>
    <tr><td class="paramname">out-&gt;error=='N'</td><td><code>too</code> many NaNs.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga8a85afbb18d256bcc8942d2eca7470ed">apop_jackknife_cov</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gaee16258d3e52671e254f3ce03bca7754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_cdf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input a one-row data point/vector and a model; returns the area of the model's PDF beneath the given point.</p>
<p>By default, make random draws from the PDF and return the percentage of those draws beneath or equal to the given point. Many models have closed-form solutions that make no use of random draws.</p>
<p>See also <a class="el" href="structapop__cdf__settings.html">apop_cdf_settings</a>, which is the structure used to store draws already made (which means the second, third, ... calls to this function will take much less time than the first), the <code>gsl_rng</code>, and the number of draws to be made. These are handled without your involvement, but if you would like to change the number of draws from the default, add this group before calling <a class="el" href="group__all__public.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Apop_model_add_group(your_model, apop_cdf, .draws=1e5, .rng=my_rng);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double cdf_value = apop_cdf(your_data_point, your_model);</div>
</div><!-- fragment --><ul>
<li>Only the first row of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set is used. Note that if you need to view row 20 of a data set as a one-row data set, use <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>.</li>
</ul>
<p>Here are many examples using common, mostly symmetric distributions.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="comment">//Set up an apop_data set with only one number.</span></div>
<div class="line">    <span class="comment">//Most of these functions will only look at the first data point encountered.</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *onept = <a class="code" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((1), 23);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *norm = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 23, 138.8);</div>
<div class="line">    <span class="keywordtype">double</span> val = <a class="code" href="group__all__public.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a>(onept, norm);</div>
<div class="line">    assert(fabs(val - 0.5) &lt; 1e-4);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> tolerance = 1e-8;</div>
<div class="line">    <span class="comment">//Macroizing the sample routine above:</span></div>
<div class="line"><span class="preprocessor">    #define model_val_cdf(model, value, cdf_result) {   \</span></div>
<div class="line"><span class="preprocessor">        apop_data_set(onept, .val=(value));             \</span></div>
<div class="line"><span class="preprocessor">        assert(fabs((apop_cdf(onept, model))-(cdf_result))&lt; tolerance);   \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *uni = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga95be4cc3931072118a7c8ffece73fbe1">apop_uniform</a>, 20, 26);</div>
<div class="line">    model_val_cdf(uni, 0, 0);</div>
<div class="line">    model_val_cdf(uni, 20, 0);</div>
<div class="line">    model_val_cdf(uni, 21, 1./6);</div>
<div class="line">    model_val_cdf(uni, 23, 0.5);</div>
<div class="line">    model_val_cdf(uni, 25, 5./6);</div>
<div class="line">    model_val_cdf(uni, 26, 1);</div>
<div class="line">    model_val_cdf(uni, 260, 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Improper uniform always returns 1/2.</span></div>
<div class="line">    model_val_cdf(<a class="code" href="group__models.html#ga8b3ad07d082de47bc9cd85661fe9fc4b">apop_improper_uniform</a>, 0, 0.5);</div>
<div class="line">    model_val_cdf(<a class="code" href="group__models.html#ga8b3ad07d082de47bc9cd85661fe9fc4b">apop_improper_uniform</a>, 228, 0.5);</div>
<div class="line">    model_val_cdf(<a class="code" href="group__models.html#ga8b3ad07d082de47bc9cd85661fe9fc4b">apop_improper_uniform</a>, INFINITY, 0.5);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *binom = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, 2001, 0.5);</div>
<div class="line">    model_val_cdf(binom, 0, 0);</div>
<div class="line">    model_val_cdf(binom, 1000, .5);</div>
<div class="line">    model_val_cdf(binom, 2000, 1);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *bernie = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">apop_bernoulli</a>, 0.75);</div>
<div class="line">    <span class="comment">//p(0)=.25; p(1)=.75; that determines the CDF.</span></div>
<div class="line">    <span class="comment">//Notice that the CDF&#39;s integral is over a closed interval.</span></div>
<div class="line">    model_val_cdf(bernie, -1, 0);</div>
<div class="line">    model_val_cdf(bernie, 0, 0.25);</div>
<div class="line">    model_val_cdf(bernie, 0.1, 0.25);</div>
<div class="line">    model_val_cdf(bernie, .99, 0.25);</div>
<div class="line">    model_val_cdf(bernie, 1, 1);</div>
<div class="line">    model_val_cdf(bernie, INFINITY, 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//alpha=beta -&gt; symmetry</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *beta = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, 2, 2);</div>
<div class="line">    model_val_cdf(beta, -INFINITY, 0);</div>
<div class="line">    model_val_cdf(beta, 0.5, 0.5);</div>
<div class="line">    model_val_cdf(beta, INFINITY, 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//This beta distribution -&gt; uniform</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *beta_uni = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, 1, 1);</div>
<div class="line">    model_val_cdf(beta_uni, 0, 0);</div>
<div class="line">    model_val_cdf(beta_uni, 1./6, 1./6);</div>
<div class="line">    model_val_cdf(beta_uni, 0.5, 0.5);</div>
<div class="line">    model_val_cdf(beta_uni, 1, 1);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    beta_uni-&gt;<a class="code" href="structapop__model.html#ac72b67b999bbd537732625da8f91ed6b">cdf</a> = NULL; <span class="comment">//With no closed-form CDF; make random draws to estimate the CDF.</span></div>
<div class="line">    Apop_model_add_group(beta_uni, <a class="code" href="group__all__public.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a>, .draws=1e6); <span class="comment">//extra draws to improve accuracy, but we have to lower our tolerance anyway.</span></div>
<div class="line">    tolerance=1e-3;</div>
<div class="line">    model_val_cdf(beta_uni, 0, 0);</div>
<div class="line">    model_val_cdf(beta_uni, 1./6, 1./6);</div>
<div class="line">    model_val_cdf(beta_uni, 0.5, 0.5);</div>
<div class="line">    model_val_cdf(beta_uni, 1, 1);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">//sum of three symmetric distributions: still symmetric.</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *sum_of_three = <a class="code" href="group__all__public.html#ga40bb98b02fde8f8e4ab59a4d127b692f">apop_model_mixture</a>(beta, <a class="code" href="group__models.html#ga8b3ad07d082de47bc9cd85661fe9fc4b">apop_improper_uniform</a>, beta_uni);</div>
<div class="line">    model_val_cdf(sum_of_three, 0.5, 0.5);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *threepts = <a class="code" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((3,1), -1, 0, 1);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *kernels = <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(threepts, <a class="code" href="group__models.html#gaded18b6bf8bd63a53f7b72ed5f27fdb5">apop_kernel_density</a>);</div>
<div class="line">    model_val_cdf(kernels, -5, 0);</div>
<div class="line">    model_val_cdf(kernels, 0, 0.5);</div>
<div class="line">    model_val_cdf(kernels, 10, 1);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaee8c299b83b8500b8b6ecd30817353c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_crosstab_to_db </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>row_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>col_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_col_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="group__all__public.html#gad22f12fdb3606b0bc49cd1929a05626e">apop_db_to_crosstab</a> for the storyline; this is the complement, which takes a crosstab and writes its values to the database.</p>
<p>For example, I would take </p><table  frame="box">
<tr>
<td></td><td>c0</td><td>c1 </td></tr>
<tr>
<td>r0</td><td>2</td><td>3 </td></tr>
<tr>
<td>r1</td><td>0</td><td>4 </td></tr>
</table>
<p>and do the following writes to the database:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;insert into your_table values (&#39;r0&#39;, &#39;c0&#39;, 2);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;insert into your_table values (&#39;r0&#39;, &#39;c1&#39;, 3);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;insert into your_table values (&#39;r1&#39;, &#39;c0&#39;, 3);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;insert into your_table values (&#39;r1&#39;, &#39;c1&#39;, 4);</div>
</div><!-- fragment --><ul>
<li>If your data set does not have names (or not enough names), I will use the scheme above, filling in names of the form <code>r0</code>, <code>r1</code>, ... <code>c0</code>, <code>c1</code>, .... Text columns get their own names, <code>t0</code>, <code>t1</code>.</li>
</ul>
<ul>
<li>This function handles only the matrix and text. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga44b767b375fb18f61f939c6869955331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_add_named_elmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function to add a named element to a data set. Many of Apophenia's testing procedures use this to easily produce a column of named parameters. It is public as a convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure. Must not be <code>NULL</code>, but may be blank (as per allocation via <a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> <code>( )</code> ). </td></tr>
    <tr><td class="paramname">name</td><td>The name to add </td></tr>
    <tr><td class="paramname">val</td><td>the value to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>I use the position of the last non-empty row name to know where to put the value. If there are two names in the data set, then I will put the new name in the third name slot and the data in the third slot in the vector. If you use this function from start to finish in building your list, then you'll be fine. </li>
<li>If the vector is too short (or <code>NULL</code>), I will call <a class="el" href="group__all__public.html#gaf4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> internally to make space. </li>
<li>This fits well with the defaults for <a class="el" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>. An example:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *list = apop_data_alloc();</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_add_named_elmt(list, &quot;height&quot;, 165);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_data_add_named_elmt(list, &quot;weight&quot;, 60);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;double height = apop_data_get(list, .rowname=&quot;height&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;//or</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;#define Lookup(dataset, key) apop_data_get(dataset, .rowname=#key)</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;height = Lookup(list, height);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7e7e530a692571a403e5837fda5e0f12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_add_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>newpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a page to an <a class="el" href="gentle.html#apop_data">apop_data</a> set. It gets a name so you can find it later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>The input data set, to which a page will be added. </td></tr>
    <tr><td class="paramname">newpage</td><td>The page to append </td></tr>
    <tr><td class="paramname">title</td><td>The name of the new page.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new page. I post a warning if I am appending or appending to a <code>NULL</code> data set and <code>apop_opts.verbose &gt;=1 </code>.</dd></dl>
<ul>
<li>See <a class="el" href="dataoverview.html#pps">Pages</a> for further notes. </li>
</ul>

</div>
</div>
<a class="anchor" id="gac39d6a56933b6f084328ec5ecd5090d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_alloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate an <a class="el" href="gentle.html#apop_data">apop_data</a> structure.</p>
<ul>
<li>The typical case is three arguments, like <code>apop_data_alloc(2,3,4)</code>: vector size, matrix rows, matrix cols. If the first argument is zero, you get a <code>NULL</code> vector. </li>
<li>Two arguments, <code>apop_data_alloc(2,3)</code>, would allocate just a matrix, leaving the vector <code>NULL</code>. </li>
<li>One argument, <code>apop_data_alloc(2)</code>, would allocate just a vector, leaving the matrix <code>NULL</code>. </li>
<li>Zero arguments, <code><a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, will produce a basically blank set, with <code>out-&gt;matrix</code> and <code>out-&gt;vector</code> set to <code>NULL</code>.</li>
</ul>
<p>For allocating the text part, see <a class="el" href="group__all__public.html#ga9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>.</p>
<p>The <code>weights</code> vector is set to <code>NULL</code>. If you need it, allocate it via </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;d-&gt;weights = gsl_vector_alloc(row_ct); </div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and ready to be populated with data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. The matrix, vector, or names couldn't be <code>malloc</code>ed, which probably means that you requested a very large data set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An <a class="el" href="gentle.html#apop_data">apop_data</a> struct, by itself, is about 72 bytes. If I can't allocate that much memory, I return <code>NULL</code>. But if even this much fails, your computer may be on fire and you should go put it out.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0460790f2d21f03856ed4a212a4132ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_calloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data; set everything in the allocated portion to zero. See <a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and zeroed out. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error; probably out of memory. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadd67e6838ce2521a1d756894dc9b5ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data is duplicated.</p>
<p>Basically a front-end for <a class="el" href="group__all__public.html#gaa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> for those who prefer this sort of syntax.</p>
<p>If the data set has a <code>more</code> pointer, that will be followed and subsequent pages copied as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure that this function will allocate and fill. If input is NULL, then this will be NULL.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out.error='c'</td><td>Cyclic link: <code>D-&gt;more == D</code> (may be later in the chain, e.g., <code>D-&gt;more-&gt;more = D-&gt;more</code>) You'll have only a partial copy. </td></tr>
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; should never happen. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Missing part error; should never happen.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the input data set has an error, then I will copy it anyway, including the error flag (which might be overwritten). I print a warning if the verbosity level is <code>&gt;=1</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="gafa3ab967f57f8ad3cfb99a4a82cfae02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_correlation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_75.png"/> relating each column with each other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. If you give me a weights vector, I'll use it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the square variance/covariance matrix with dimensions equal to the number of input columns. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeae37a5bf11cddee59e272b083a4efc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_covariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sample variance/covariance matrix relating each column of the matrix to each other column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the weights vector is set, I'll take it into account.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This is the sample covariance&mdash;dividing by <img class="formulaInl" alt="$n-1$" src="form_59.png"/>, not <img class="formulaInl" alt="$n$" src="form_10.png"/>. If you need the population variance, use <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *popcov = apop_data_covariance(indata);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int size=indata-&gt;matrix-&gt;size1;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;gsl_matrix_scale(popcov-&gt;matrix, size/(size-1.));</div>
</div><!-- fragment --></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="gentle.html#apop_data">apop_data</a> set the variance/covariance matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e8377359d46c9bd02ea57205e7968d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char apop_data_free_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>freeme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the elements of the given <a class="el" href="gentle.html#apop_data">apop_data</a> set and then the <a class="el" href="gentle.html#apop_data">apop_data</a> set itself. Intended to be used by <a class="el" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>, a macro that calls this to free elements, then sets the value to <code>NULL</code>.</p>
<ul>
<li><a class="el" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> is a macro that calls this function and, on success, sets the input pointer to <code>NULL</code>. For typical cases, that's slightly more useful than this function.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">freeme.error='c'</td><td>Circular linking is against the rules. If <code>freeme-&gt;more == freeme</code>, then I set <code>freeme.error='c'</code> and return. If you send in a structure like A -&gt; B -&gt; B, then both data sets A and B will be marked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> on OK, <code>'c'</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06107779e4a3eb229715ceca24352b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_data_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rowname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the data element at the given point.</p>
<p>In case of error (probably that you asked for a data point out of bounds), returns <code>NAN</code>. See <a class="el" href="dataoverview.html#data_set_get">the set/get page</a> for details and examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. Must not be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">row</td><td>The row number of the desired element. If <code>rowname==NULL</code>, default is zero. </td></tr>
    <tr><td class="paramname">col</td><td>The column number of the desired element. -1 indicates the vector. If <code>colname==NULL</code>, default is zero if the <code>-&gt;matrix</code> element is not <code>NULL</code> and -1 if the <code>-&gt;matrix</code> element is <code>NULL</code> and the <code>-&gt;vector</code> element is not.</td></tr>
    <tr><td class="paramname">rowname</td><td>The row name of the desired element. If <code>NULL</code>, use the row number. </td></tr>
    <tr><td class="paramname">colname</td><td>The column name of the desired element. If <code>NULL</code>, use the column number. </td></tr>
    <tr><td class="paramname">page</td><td>The case-insensitive name of the page on which the element is found. If <code>NULL</code>, use first page.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the given location. </dd></dl>

</div>
</div>
<a class="anchor" id="gadec9170cf1382f6cd549a5819472eb51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_get_factor_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Factor names are stored in an auxiliary table with a name like <code>"&lt;categories for your_var&gt;"</code>. Producing this name is annoying (and prevents us from eventually making it human-language independent), so use this function to get the list of factor names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">col</td><td>The column in the main data set whose name I'll use to check for the factor name list. Vector==-1. (default=0) </td></tr>
    <tr><td class="paramname">type</td><td>If you are referring to a text column, use 't'. (default='d')</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the page in the data set with the given factor names.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga044771db76f0afb410a8d4f05ac51ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_get_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It's good form to get a page from your data set by name, because you may not know the order for the pages, and the stepping through makes for dull code anyway (<code><a class="el" href="structapop__data.html">apop_data</a> *page = dataset; while (page-&gt;more) page= page-&gt;more;</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set to use. No default; if <code>NULL</code>, gives a warning if <code>apop_opts.verbose &gt;=1</code> and returns <code>NULL</code>.</td></tr>
    <tr><td class="paramname">title</td><td>The name of the page to retrieve. Default=<code>"&lt;Info&gt;"</code>, which is the name of the page of additional estimation information returned by estimation routines (log likelihood, status, AIC, BIC, confidence intervals, ...).</td></tr>
    <tr><td class="paramname">match</td><td>If <code>'c'</code>, case-insensitive match (via <code>strcasecmp</code>); if <code>'e'</code>, exact match, if <code>'r'</code> regular expression substring search (via <a class="el" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>). Default=<code>'c'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The page whose title matches what you gave me. If I don't find a match, return <code>NULL</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga0316d98bbeb6ae13532a8c071019dbe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_listwise_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If there is an NaN anywhere in the row of data (including the matrix, the vector, the weights, and the text) then delete the row from the data set.</p>
<ul>
<li>If every row has a NaN, then this returns <code>NULL</code>. </li>
<li>If <code>apop_opts.nan_string</code> is not <code>NULL</code>, then I will make case-insensitive comparisons to the text elements to check for bad data as well. </li>
<li>If <code>inplace</code> = 'y', then I'll free each element of the input data set and refill it with the pruned elements. I'll still take up (up to) twice the size of the data set in memory during the function. If every row has a NaN, then your <code><a class="el" href="structapop__data.html">apop_data</a></code> set will end up with <code>NULL</code> vector, matrix, .... if <code>inplace</code> = 'n', then the original data set is left where it was, though internal elements may be moved. </li>
<li>I only look at the first page of data (i.e. the <code>more</code> element is ignored). </li>
<li>Listwise deletion is often not a statistically valid means of dealing with missing data. It is typically better to impute the data (preferably multiple times). See <a class="el" href="group__all__public.html#ga2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> for a less-invalid means, or <a href="https://github.com/rodri363/tea">Tea for survey imputation</a> for heavy-duty survey editing and imputation. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data, with NaNs </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, clear out the pointer-to-<a class="el" href="gentle.html#apop_data">apop_data</a> that you sent in and refill with the pruned data. If <code>'n'</code>, leave the set alone and return a new data set. Default=<code>'n'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (potentially shorter) copy of the data set, without NaNs. If <code>inplace=='y'</code>, a pointer to the input, which was shortened in place. If the entire data set is cleared out, then this will be <code>NULL</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa24d396c7fda38bc4ab03a3ba2db4943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another.</p>
<p>This function does not allocate the output structure or the vector, matrix, text, or weights elements&mdash;I assume you have already done this and got the dimensions right. I will assert that there is at least enough room in the destination for your data, and fail if the copy would write more elements than there are bins.</p>
<ul>
<li>If you want space allocated or are unsure about dimensions, use <a class="el" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>. </li>
<li>If both <code>in</code> and <code>out</code> have a <code>more</code> pointer, also copy subsequent page(s). </li>
<li>You can use the subsetting macros, <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>, <a class="el" href="group__all__public.html#ga585f5cf3125fb5fc875dea85980eabd1">Apop_rs</a>, <a class="el" href="group__all__public.html#gadabbf2a1717d5c76a834e090ddfcfeaa">Apop_c</a>, and so on, to copy within a data set:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;//Copy the contents of row i of mydata to row j.</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data *fromrow = Apop_r(mydata, i);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_data *torow = Apop_r(mydata, j);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;apop_data_memcpy(torow, fromrow);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// or just</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;apop_data_memcpy(Apop_r(mydata, i), Apop_r(mydata, j));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A structure that this function will fill. Must be preallocated with the appropriate sizes. </td></tr>
    <tr><td class="paramname">in</td><td>The input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='d'</td><td>Dimension error. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Part missing; e.g., in-&gt;matrix exists but out-&gt;matrix doesn't. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90feb5dd661cfe0f0b53a85295b8b56e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_data_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>more_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>use_info_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes in an <a class="el" href="gentle.html#apop_data">apop_data</a> set and writes it as a single column of numbers, outputting a <code>gsl_vector</code>. It is valid to use the <code>out_vector-&gt;data</code> element as an array of <code>doubles</code> of size <code>out_vector-&gt;data-&gt;size</code> (i.e. its <code>stride==1</code>).</p>
<p>The complement is <code>apop_data_unpack</code>. I.e., </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data_unpack(apop_data_pack(in_data), data_copy) </div>
</div><!-- fragment --><p> will return the original data set (stripped of text and names).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an <code><a class="el" href="structapop__data.html">apop_data</a></code> set. No default; if <code>NULL</code>, return <code>NULL</code>. </td></tr>
    <tr><td class="paramname">out</td><td>If this is not <code>NULL</code>, then put the output here. The dimensions must match exactly. If <code>NULL</code>, then allocate a new data set. Default = <code>NULL</code>. </td></tr>
    <tr><td class="paramname">more_pages</td><td>If <code>'y'</code>, then follow the <code> -&gt;more</code> pointer to fill subsequent pages; else fill only the first page. Informational pages will still be ignored, unless you set <code>.use_info_pages='y'</code> as well. Default = <code>'y'</code>. </td></tr>
    <tr><td class="paramname">use_info_pages</td><td>Pages in XML-style brackets, such as <code>&lt;Covariance&gt;</code> will be ignored unless you set <code>.use_info_pages='y'</code>. Be sure that this is set to the same thing when you both pack and unpack. Default: <code>'n'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>gsl_vector</code> with the vector data (if any), then each row of data (if any), then the weights (if any), then the same for subsequent pages (if any <code>&amp;&amp; .more_pages=='y'</code>). If <code>out</code> is not <code>NULL</code>, then this is <code>out</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NULL</td><td>If you give me a vector as input, and its size is not correct, returns <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gacc90578a8086a2e6f7b1575300260f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_pmf_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Say that you have added a long list of observations to a single <a class="el" href="gentle.html#apop_data">apop_data</a> set, meaning that each row has weight one. There are a huge number of duplicates, perhaps because there are a handful of types that keep repeating:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
</table>
<p>Use this function to reduce this to a set of distinct values, with their weights adjusted accordingly:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights &lt;tr valign=bottom</td><td></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>3 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>4 </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set that may have duplicate rows. As above, the data may be in text and/or numeric formats.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Your input is changed in place, via <a class="el" href="group__all__public.html#gae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a>, so use <a class="el" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> before calling this function if you need to retain the original format. For your convenience, this function returns a pointer to your original data, which has now been pruned. If there is a <code>weights</code> vector, I will add those weights together as duplicates are merged. If there is no <code>weights</code> vector, I will create one, which is initially set to one for all values, and then aggregated as above. </dd></dl>

</div>
</div>
<a class="anchor" id="gab45a848e5dbcaf82b5b95cd03f7b396a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_declares&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print an <a class="el" href="gentle.html#apop_data">apop_data</a> set to a file, the database, or the screen, as determined by the <code></code>.output_type.</p>
<ul>
<li>See <a class="el" href="group__all__public.html#ga4748bf59f5441cd27e5b93056c7ec1c7">apop_prep_output</a> for more on how printing settings are set. </li>
<li>See <a class="el" href="c.html#Legi">Legible output</a> for more details and examples. </li>
<li>See <a class="el" href="c.html#sqlsec">About SQL, the syntax for querying databases</a> for notes on writing an <a class="el" href="gentle.html#apop_data">apop_data</a> set to the database. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad1efbe058d6ca85ece023eb471c66e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_prune_columns_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>colnames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep only the columns of a data set that you name. This is the function called internally by the <a class="el" href="group__all__public.html#ga5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a> macro. In most cases, you'll want to use that macro. An example of the two uses demonstrating the difference:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data_prune_columns(d, &quot;mean&quot;, &quot;median&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char *list[] = {&quot;mean&quot;, &quot;median&quot;, NULL};</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;apop_data_prune_columns_base(d, list);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">colnames</td><td>A NULL-terminated list of names to retain (i.e. the columns that shouldn't be pruned out). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the input data set, now pruned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga59d1c0299c7eb87224bc6c60555784fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* apop_data_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rowname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to an element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<ul>
<li>If a <code>NULL</code> vector or matrix (as the case may be), or the row/column you requested is outside bounds, return <code>NULL</code>. </li>
<li>See <a class="el" href="dataoverview.html#data_set_get">the set/get page</a> for details.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. Must not be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">row</td><td>The row number of the desired element. If <code>rowname==NULL</code>, default is zero. </td></tr>
    <tr><td class="paramname">col</td><td>The column number of the desired element. -1 indicates the vector. If <code>colname==NULL</code>, default is zero. </td></tr>
    <tr><td class="paramname">rowname</td><td>The row name of the desired element. If <code>NULL</code>, use the row number. </td></tr>
    <tr><td class="paramname">colname</td><td>The column name of the desired element. If <code>NULL</code>, use the column number. </td></tr>
    <tr><td class="paramname">page</td><td>The case-insensitive name of the page on which the element is found. If <code>NULL</code>, use first page.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9235c6882a01ac9195665104985cd0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rank_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One often finds data where the column indicates the value of the data point. There may be two columns, and a mark in the first indicates a miss while a mark in the second is a hit. Or say that we have the following list of observations:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;2 3 3 2 1 1 2 1 1 2 1 1</div>
</div><!-- fragment --><p> Then we could write this as: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;0  1  2  3</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;----------</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;0  6  4  2</div>
</div><!-- fragment --><p> because there are six 1s observed, four 2s observed, and two 3s observed. We call this rank format, because 1 (or zero) is typically the most common, 2 is second most common, et cetera.</p>
<p>This function takes in a list of observations, and aggregates them into a single row in rank format.</p>
<ul>
<li>For the complement, see <a class="el" href="group__all__public.html#ga2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>.</li>
</ul>
<ul>
<li>See also <a class="el" href="group__all__public.html#ga27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> to convert real numbers or text into a matrix of categories.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input <a class="el" href="gentle.html#apop_data">apop_data</a> set. If <code>NULL</code>, return <code>NULL</code>. </td></tr>
    <tr><td class="paramname">min_bins</td><td>If this is omitted, the number of bins is simply the largest number found. So if there are bins {0, 1, 2} and your data set happens to consist of <code>0 0 1 1 0</code>, then I won't know to generate results with three bins where the last bin has a count of zero. Set <code>.min_bins=2</code> to ensure that bin is included.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">/* A round trip: generate Zipf-distributed draws, summarize them to a single list of</span></div>
<div class="line"><span class="comment">rankings, then expand the rankings to a list of single entries. The sorted list at the end</span></div>
<div class="line"><span class="comment">of this should be identical to the (sorted) original list. */</span></div>
<div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    gsl_rng *r = <a class="code" href="group__all__public.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(2342);</div>
<div class="line">    <span class="keywordtype">int</span> i, length = 1e4;</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *a_zipf = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, 3.2);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *draws = <a class="code" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(length);</div>
<div class="line">    <span class="keywordflow">for</span> (i=0; i&lt; length; i++)</div>
<div class="line">        <a class="code" href="group__all__public.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a>(<a class="code" href="group__all__public.html#ga59d1c0299c7eb87224bc6c60555784fe">apop_data_ptr</a>(draws, i, -1), r, a_zipf);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *by_rankings = <a class="code" href="group__all__public.html#gaa9235c6882a01ac9195665104985cd0e">apop_data_rank_compress</a>(draws);</div>
<div class="line">    <span class="comment">//The first row of the matrix is suitable for plotting.</span></div>
<div class="line">    <span class="comment">//apop_data_show(by_rankings);</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a>(by_rankings-&gt;matrix) == length);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *re_expanded = <a class="code" href="group__all__public.html#ga2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>(by_rankings);</div>
<div class="line">    gsl_sort_vector(draws-&gt;vector);</div>
<div class="line">    gsl_sort_vector(re_expanded-&gt;vector);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(draws-&gt;vector, re_expanded-&gt;vector) &lt; 1e-5);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2feb17743f8b07b8ddcf457362cabefc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rank_expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The complement to this is <a class="el" href="group__all__public.html#gaa9235c6882a01ac9195665104985cd0e">apop_data_rank_compress</a>; see that function's documentation for the story and an example.</p>
<p>This function takes in a data set where the zeroth column includes the count(s) of times that zero was observed, the first gives the count(s) of times that one was observed, et cetera. It outputs a data set whose vector element includes a list that has exactly the given frequency of zeros, ones, et cetera. </p>

</div>
</div>
<a class="anchor" id="ga1312f6568cfe832f1e35f7f44482ffb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_rm_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the columns of the <a class="el" href="gentle.html#apop_data">apop_data</a> set corresponding to a nonzero value in the <code>drop</code> vector.</p>
<ul>
<li>The returned data structure looks like it was modified in place, but the data matrix and the names are duplicated before being pared down, so if your data is taking up more than half of your memory, this may not work.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down. </td></tr>
    <tr><td class="paramname">drop</td><td>An array of ints. If use[7]==1, then column seven will be cut from the output. A reminder: <code>calloc(in-&gt;size2 , sizeof(int))</code> will fill your array with zeros on allocation, and <code>memset(use, 1, in-&gt;size2 * sizeof(int))</code> will quickly fill an array of ints with nonzero values. <a class="el" href="group__all__public.html#gae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac434c9d08b6a8304107d9c93afb81914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rm_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>free_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the first page from an <a class="el" href="gentle.html#apop_data">apop_data</a> set that matches a given name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data set, from which a page will be removed. No default. If <code>NULL</code>, maybe print a warning (see below).</td></tr>
    <tr><td class="paramname">title</td><td>The case-insensitive name of the page to remove. Default: <code>"&lt;Info&gt;"</code> </td></tr>
    <tr><td class="paramname">free_p</td><td>If <code>'y'</code>, then <a class="el" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> the page. Default: <code>'y'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If not freed, a pointer to the <code><a class="el" href="structapop__data.html">apop_data</a></code> page that I just pulled out. Thus, you can use this to pull a single page from a data set. I set that page's <code>more</code> pointer to <code>NULL</code>, to minimize any confusion about more-than-linear linked list topologies. If <code>free_p=='y'</code> (the default) or the page is not found, return <code>NULL</code>.</dd></dl>
<ul>
<li>I don't check the first page, so there's no concern that the head of your list of pages will move. Again, the intent of the <code>-&gt;more</code> pointer in the <a class="el" href="gentle.html#apop_data">apop_data</a> set is not to fully implement a linked list, but primarily to allow you to staple auxiliary information to a main data set.</li>
</ul>
<ul>
<li>If I don't find the page you want, I return NULL, and maybe print a warning; see below.</li>
</ul>
<ul>
<li>For the two above cases where a warning may be printed, if the page is to be returned and <code> apop_opts.verbose &gt;= 1 </code>, print a warning. If the page is to be freed and <code> apop_opts.verbose &gt;= 2 </code>, print a warning.</li>
</ul>
<ul>
<li>The remaining <code>more</code> pointers in the <a class="el" href="gentle.html#apop_data">apop_data</a> set are adjusted accordingly. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae2ab3a4f332adb368fe970619a8c0252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rm_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ir&#160;</td>
          <td class="paramname"><em>do_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drop_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the rows set to one in the <code>drop</code> vector or for which the <code>do_drop</code> function returns one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down </td></tr>
    <tr><td class="paramname">drop</td><td>a vector with as many elements as the max of the vector, matrix, or text parts of <code>in</code>, with a one marking those rows to be removed. </td></tr>
    <tr><td class="paramname">do_drop</td><td>A function that returns one for rows to drop and zero for rows to not drop. A sample function: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int your_drop_function(apop_data *onerow, void *extra_param){</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  return gsl_isnan(apop_data_get(onerow)) ||</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;              !strcmp(onerow-&gt;text[0][0], &quot;Uninteresting data point&quot;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
</div><!-- fragment --> <a class="el" href="group__all__public.html#gae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> will use <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a> to get a subview of the input data set of height one, and send that subview to this function (and since arguments typically default to zero, you don't have to write out things like <a class="el" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a> <code>(onerow, .row=0, .col=0)</code>, which can help to keep things readable). </td></tr>
    <tr><td class="paramname">drop_parameter</td><td>If your <code>do_drop</code> function requires additional input, put it here and it will be passed through.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the input data set, now pruned.</dd></dl>
<ul>
<li>If all the rows are to be removed, then you will wind up with the same <a class="el" href="gentle.html#apop_data">apop_data</a> set, with <code>NULL</code> <code>vector</code>, <code>matrix</code>, <code>weight</code>, and text. Therefore, you may wish to check for <code>NULL</code> elements after use. I remove rownames, but leave the other names, in case you want to add new data rows. </li>
<li>The typical use is to provide only a list or only a function. If both are <code>NULL</code>, I return without doing anything, and print a warning if <code>apop_opts.verbose &gt;=2</code>. If you provide both, I will drop the row if either the vector has a one in that row's position, or if the function returns a nonzero value. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a>, <a class="el" href="group__all__public.html#ga1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga5bdc618669b9ddc8239595d7b50bec9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_data_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rowname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a data element. See <a class="el" href="dataoverview.html#data_set_get">the set/get page</a> for details and examples.</p>
<dl class="section return"><dt>Returns</dt><dd>0=OK, -1=error: couldn't find row/column name, or you asked for a location outside the vector/matrix bounds.</dd></dl>
<ul>
<li>The error codes for out-of-bounds errors are thread-safe iff you are have a C11-compliant compiler (thanks to the <code>_Thread_local</code> keyword) or a version of GCC with the <code>__thread</code> extension enabled.</li>
</ul>
<ul>
<li>Set weights via <code>gsl_vector_set(your_data-&gt;weights, row, val);</code>. </li>
<li>Set text elements via <a class="el" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. Must not be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">row</td><td>The row number of the desired element. If <code>rowname==NULL</code>, default is zero. </td></tr>
    <tr><td class="paramname">col</td><td>The column number of the desired element. -1 indicates the vector. If <code>colname==NULL</code>, default is zero. </td></tr>
    <tr><td class="paramname">rowname</td><td>The row name of the desired element. If <code>NULL</code>, use the row number. </td></tr>
    <tr><td class="paramname">colname</td><td>The column name of the desired element. If <code>NULL</code>, use the column number. </td></tr>
    <tr><td class="paramname">page</td><td>The case-insensitive name of the page on which the element is found. If <code>NULL</code>, use first page. </td></tr>
    <tr><td class="paramname">val</td><td>The value to give the point.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gacefe4dee819c090e57ac69d4d8bdcfd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>col_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort an <a class="el" href="gentle.html#apop_data">apop_data</a> set on an arbitrary sequence of columns.</p>
<p>The <code>sort_order</code> set is a one-row data set that should look like the data set being sorted. The easiest way to generate it is to use <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a> to pull one row of the table, then copy and fill it. For each column you want used in the sort, assign a ranking giving whether the column should be sorted first, second, .... Columns you don't want used in the sorting should be set to <code>NAN</code>. Ties are broken by the earlier element in the default order (see below).</p>
<p>E.g., to sort by the last column of a five-column matrix first, then the next-to-last column, then the next-to-next-to-last, then by the first text column, then by the second text column:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *sort_order = apop_data_copy(Apop_r(data, 0));</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sort_order-&gt;vector = NULL; //so it will be skipped.</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Apop_data_fill(sort_order, NAN, NAN, 3, 2, 1);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;apop_text_set(sort_order, 0, 0, &quot;4&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;apop_text_set(sort_order, 0, 1, &quot;5&quot;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;apop_data_sort(data, sort_order);</div>
</div><!-- fragment --><p>To determine which columns are sorted at which step, I use only comparisons, not the actual numeric values. For example, (1, 2, 3) and (-1.32, 0, 27) work identically. For text, I use <code>atof</code> to convert the your text to a number, as in the example above that set text values of <code>"4"</code> and <code>"5"</code>. A blank string, NaN numeric value, or NULL element in the <a class="el" href="gentle.html#apop_data">apop_data</a> set means that column will not be sorted.</p>
<ul>
<li>Strings are sorted case-insensitively, using <code>strcasecmp</code>. [exercise for the reader: modify the source to use Glib's locale-correct string sorting.]</li>
</ul>
<ul>
<li>The setup generates a lexicographic sort using the columns you specify. If you would like a different sort order, such as Euclidian distance to the origin, you can generate a new column expressing your preferred metric, and then sorting on that. See the example below.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to be sorted. If <code>NULL</code>, this function is a no-op that returns <code>NULL</code>. </td></tr>
    <tr><td class="paramname">sort_order</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set describing the order in which columns are used for sorting, as above. If <code>NULL</code>, then sort by the vector, then each matrix column, then text, then weights, then row names. </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'n', make a copy, else sort in place. (default: 'y'). </td></tr>
    <tr><td class="paramname">asc</td><td>If 'a', ascending; if 'd', descending. This is applied to all columns; column-by-column application is to do. (default: 'a'). </td></tr>
    <tr><td class="paramname">col_order</td><td>For internal use only. In your call, it should be <code>NULL</code>; you can leave this off your function call entirely and the <a class="el" href="designated.html">Designated initializers</a> syntax will takes care of it for you.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the sorted data set. If <code>inplace=='y'</code> (the default), then this is the same as the input set.</dd></dl>
<p>A few examples:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef Datadir</span></div>
<div class="line"><span class="preprocessor">#define DATADIR Datadir</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define DATADIR &quot;.&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef Testing</span></div>
<div class="line"><span class="preprocessor">#include &quot;sort_tests.c&quot;</span> <span class="comment">//For Apophenia&#39;s test suite, some tedious checks that the sorts worked</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//get_distance is for the sort-by-Euclidian distance example below.</span></div>
<div class="line"><span class="keywordtype">double</span> get_distance(gsl_vector *v) {<span class="keywordflow">return</span> <a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v);}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="group__all__public.html#gabd00e16791a970631c3ed4ac3487da46">apop_text_to_db</a>( DATADIR <span class="stringliteral">&quot;/&quot;</span> <span class="stringliteral">&quot;amash_vote_analysis.csv&quot;</span> , .tabname=<span class="stringliteral">&quot;amash_vote_analysis&quot;</span>);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a>(<span class="stringliteral">&quot;mntmtm&quot;</span>, <span class="stringliteral">&quot;select 1,id,party,contribs/1000.0,vote,ideology from amash_vote_analysis &quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//use the default order of columns for sorting</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *sorted = <a class="code" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(d, .inplace=<span class="charliteral">&#39;n&#39;</span>);</div>
<div class="line"><span class="preprocessor">#ifndef Testing</span></div>
<div class="line">    <a class="code" href="group__all__public.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(sorted);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    check_sorting1(sorted);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">//set up a specific column order</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *perm = <a class="code" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(<a class="code" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>(d, 0));</div>
<div class="line">    perm-&gt;vector = NULL;</div>
<div class="line">    <a class="code" href="group__all__public.html#gad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(perm, 5, 3, 4);</div>
<div class="line">    <a class="code" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a>(perm, 0, 0, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line">    <a class="code" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a>(perm, 0, 1, <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(d, perm);</div>
<div class="line"><span class="preprocessor">#ifndef Testing</span></div>
<div class="line">    <a class="code" href="group__all__public.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(d);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    check_sorting2(d);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">//sort a list of names</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *blank = <a class="code" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>();</div>
<div class="line">    <a class="code" href="group__all__public.html#gaeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(blank, <span class="charliteral">&#39;r&#39;</span>, <span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;E&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">    <a class="code" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(blank);</div>
<div class="line">    assert(*blank-&gt;names-&gt;row[0] == <span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">    assert(*blank-&gt;names-&gt;row[1] == <span class="charliteral">&#39;C&#39;</span>);</div>
<div class="line">    assert(*blank-&gt;names-&gt;row[2] == <span class="charliteral">&#39;E&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//take each row of the matrix as a vector; store the Euclidian distance to the origin in the vector;</span></div>
<div class="line">    <span class="comment">//sort in descending order.</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *rowvectors = <a class="code" href="group__all__public.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a>( DATADIR <span class="stringliteral">&quot;/&quot;</span> <span class="stringliteral">&quot;test_data&quot;</span> );</div>
<div class="line">    <a class="code" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>(rowvectors, .fn_v=get_distance, .part=<span class="charliteral">&#39;r&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *arow = <a class="code" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(<a class="code" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>(rowvectors, 0));</div>
<div class="line">    arow-&gt;matrix=NULL; <span class="comment">//sort only by the distance vector</span></div>
<div class="line">    <a class="code" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(rowvectors, arow, .asc=<span class="charliteral">&#39;d&#39;</span>);</div>
<div class="line"><span class="preprocessor">#ifndef Testing</span></div>
<div class="line">    apop_data_show(rowvectors);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="keywordtype">double</span> prev = INFINITY;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; rowvectors-&gt;vector-&gt;size; i++){</div>
<div class="line">        <span class="keywordtype">double</span> <span class="keyword">this</span> = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(rowvectors, i, -1);</div>
<div class="line">        assert(<span class="keyword">this</span> &lt; prev);</div>
<div class="line">        prev = <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaef0284036801cb75d465a1738f65397e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>** apop_data_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>r_or_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split one input <a class="el" href="gentle.html#apop_data">apop_data</a> structure into two.</p>
<p>For the opposite operation, see <a class="el" href="group__all__public.html#ga0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure to split </td></tr>
    <tr><td class="paramname">splitpoint</td><td>The index of what will be the first row/column of the second data set. E.g., if this is -1 and <code>r_or_c=='c'</code>, then the whole data set will be in the second data set; if this is the length of the matrix then the whole data set will be in the first data set. Another way to put it is that for values between zero and the matrix's size, <code>splitpoint</code> will equal the number of rows/columns in the first matrix.</td></tr>
    <tr><td class="paramname">r_or_c</td><td>If this is 'r' or 'R', then put some rows in the first data set and some in the second; of 'c' or 'C', split columns into first and second data sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of two <a class="el" href="gentle.html#apop_data">apop_data</a> sets. If one is empty then a <code>NULL</code> pointer will be returned in that position. For example, for a data set of 50 rows, <code><a class="el" href="structapop__data.html">apop_data</a> **out = apop_data_split(data, 100, 'r')</code> sets <code>out[0] = apop_data_copy(data)</code> and <code>out[1] = NULL</code>.</dd></dl>
<ul>
<li>When splitting at a row, the text is also split. </li>
<li>The <code>more</code> pointer is ignored. </li>
<li>The <code>apop_data-&gt;vector</code> is taken to be the -1st element of the matrix. </li>
<li>Weights will be preserved. If splitting by rows, then the top and bottom parts of the weights vector will be assigned to the top and bottom parts of the main data set. If splitting by columns, identical copies of the weights vector will be assigned to both parts. </li>
<li>Data is copied, so you may want to call <code><a class="el" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free(in)</a></code> after this. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga0f2ffb5c5ba2bb240e930be08fc4fd56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the first data set either on top of or to the left of the second data set.</p>
<p>For the opposite operation, see <a class="el" href="group__all__public.html#gaef0284036801cb75d465a1738f65397e">apop_data_split</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">posn</td><td>If 'r', stack rows of m1 above rows of m2<br />
 if 'c', stack columns of m1 to left of m2's<br />
 (default = 'r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, use <a class="el" href="group__all__public.html#gaa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> and <a class="el" href="group__all__public.html#gaf4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>m1</code> in place. Otherwise, allocate a new <a class="el" href="gentle.html#apop_data">apop_data</a> set, leaving <code>m1</code> undisturbed. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stacked data, either in a new <a class="el" href="gentle.html#apop_data">apop_data</a> set or <code>m1</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Dimension error; couldn't make a complete copy.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The function returns a new data set, meaning that until you <a class="el" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free()</a> the original data sets, you will be taking up twice as much memory. </li>
<li>If m1 or m2 are <code>NULL</code>, returns a copy of the other element, and if both are <code>NULL</code>, returns <code>NULL</code>. If <code>m2</code> is <code>NULL</code> and <code>inplace</code> is <code>'y'</code>, returns the original <code>m1</code> pointer unmodified. </li>
<li>Text is handled as you'd expect: If 'r', one set of text is stacked on top of the other [number of columns must match]; if 'c', one set of text is set next to the other [number of rows must match]. </li>
<li><code>more</code> is ignored. </li>
<li>If stacking rows on rows, the output vector is the input vectors stacked accordingly. If stacking columns by columns, the output vector is just a copy of the vector of <code>m1</code> and <code>m2-&gt;vector</code> doesn't appear in the output at all. </li>
<li>The same rules for dealing with the vector(s) hold for the vector(s) of weights. </li>
<li>Names are a copy of the names for <code>m1</code>, with the names for <code>m2</code> appended to the row or column list, as appropriate. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga253dba4ed7f5c03107d38c1268b46c01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_summarize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>indata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put summary information about the columns of a table (mean, std dev, variance, min, median, max) in a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indata</td><td>The table to be summarized. An <a class="el" href="gentle.html#apop_data">apop_data</a> structure. May have a <code>weights</code> element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> structure with one row for each column in the original table, and a column for each summary statistic. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This function gives more columns than you probably want; use <a class="el" href="group__all__public.html#ga5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a> to pick the ones you want to see.</li>
</ul>
<ul>
<li>See apop_data_prune_columns for an example. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad60f2beb7836119d364676a361cb5e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_to_bins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> const *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> const *&#160;</td>
          <td class="paramname"><em>binspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>close_top_bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a histogram from data by putting data into bins of fixed width. Your input <a class="el" href="gentle.html#apop_data">apop_data</a> set may be multidimensional, and may include both vector and matrix parts, and the bins output will have corresponding dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indata</td><td>The input data that will be binned, one observation per row. This is copied and the copy will be modified. (No default) </td></tr>
    <tr><td class="paramname">binspec</td><td>This is an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the same number of columns as <code>indata</code>. If you want a fixed size for the bins, then the first row of the bin spec is the bin width for each column. This allows you to specify a width for each dimension, or specify the same size for all with something like: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *binspec = apop_data_copy(Apop_r(indata, 0));</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;gsl_matrix_set_all(binspec-&gt;matrix, 10); //bins of size 10 for all dim.s</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_data_to_bins(indata, binspec);</div>
</div><!-- fragment --> The presumption is that the first bin starts at zero in all cases. You can add a second row to the spec to give the offset for each dimension. (default: NULL) </td></tr>
    <tr><td class="paramname">bin_count</td><td>If you don't provide a bin spec, I'll provide this many evenly-sized bins to cover the data set. (Default: <img class="formulaInl" alt="$\sqrt{N}$" src="form_18.png"/>) </td></tr>
    <tr><td class="paramname">close_top_bin</td><td>Normally, a bin covers the range from the point equal to its minimum to points strictly less than the minimum plus the width. if <code>'y'</code>, then the top bin includes points less than or equal to the upper bound. This solves the problem of displaying histograms where the top bin is just one point. (default: <code>'y'</code> if <code>binspec==NULL</code>, else <code>'n'</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the same dimension as your input data. Each cell is an integer giving the bin number into which the cell falls.</dd></dl>
<ul>
<li>If no binspec and no binlist, then a grid with offset equal to the min of the column, and bin size such that it takes <img class="formulaInl" alt="$\sqrt{N}$" src="form_18.png"/> bins to cover the range to the max element. </li>
<li>The text segment is not binned. The <code>more</code> pointer, if any, is not followed. </li>
<li>Given <code>NULL</code> input, return <code>NULL</code> output. Print a warning if <code>apop_opts.verbose &gt;= 2</code>.</li>
</ul>
<p>Iff you didn't give me a binspec, then I attach one to the output set as a page named <code>&lt;binspec&gt;</code>. This means that you can snap a second data set to the same grid using </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data_to_bins(first_set, NULL);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_to_bins(second_set, apop_data_get_page(first_set, &quot;&lt;binspec&gt;&quot;));</div>
</div><!-- fragment --> <ul>
<li>If you want to plot the output, it may help to run it through <a class="el" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> to produce a vector of bin weights.</li>
</ul>
<p>Here is a sample program highlighting <a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a> and <a class="el" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> .</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define _GNU_SOURCE</span></div>
<div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef Testing</span></div>
<div class="line"><span class="preprocessor">    #define printdata(dataset)  ;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">    #define printdata(dataset)           \</span></div>
<div class="line"><span class="preprocessor">            printf(&quot;\n-----------\n\n&quot;); \</span></div>
<div class="line"><span class="preprocessor">            apop_data_print(dataset);   </span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(<a class="code" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(6), 6, 1);</div>
<div class="line">    <a class="code" href="group__all__public.html#gad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(d,   1,   2,   3,   3,   1,   2);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(d,  <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line"></div>
<div class="line">    asprintf(&amp;d-&gt;names-&gt;title, <span class="stringliteral">&quot;Original data set&quot;</span>);</div>
<div class="line">    printdata(d);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//binned, where bin ends are equidistant but not necessarily in the data</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *binned = <a class="code" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a>(d);</div>
<div class="line">    asprintf(&amp;binned-&gt;names-&gt;title, <span class="stringliteral">&quot;Post binning&quot;</span>);</div>
<div class="line">    printdata(binned);</div>
<div class="line">    assert(fabs(<span class="comment">//equal distance between bins</span></div>
<div class="line">              (<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 1) - <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 0))</div>
<div class="line">            - (<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 2) - <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 1))) &lt; 1e-5);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//compressed, where the data is as in the original, but weights </span></div>
<div class="line">        <span class="comment">//are redone to accommodate repeated observations.</span></div>
<div class="line">    <a class="code" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(d);</div>
<div class="line">    asprintf(&amp;d-&gt;names-&gt;title, <span class="stringliteral">&quot;Post compression&quot;</span>);</div>
<div class="line">    printdata(d);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga9b05181ceec857e9eb9ed6a8ea7423d3">apop_sum</a>(d-&gt;weights)==6);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *d_as_pmf = <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, <a class="code" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *firstrow = <a class="code" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a>(d, 0); <span class="comment">//1A</span></div>
<div class="line">    assert(fabs(<a class="code" href="group__all__public.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a>(firstrow, d_as_pmf) - 2./6 &lt; 1e-5));</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae0c28224e10f8aacdaa2d130f96f6ba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_to_dummies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A utility to make a matrix of dummy variables. You give me a single vector that lists the category number for each item, and I'll produce a matrix with a single one in each row in the column specified.</p>
<p>After that, you have to decide what to do with the new matrix and the original data column.</p>
<ul>
<li>You can manually join the dummy data set with your main data, e.g.: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *dummies  = apop_data_to_dummies(main_regression_vars, .col=8, .type=&#39;t&#39;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_stack(main_regression_vars, dummies, &#39;c&#39;, .inplace=&#39;y&#39;);</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>The <code>.remove='y'</code> option specifies that I should use <a class="el" href="group__all__public.html#ga1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> to remove the column used to generate the dummies. Implemented only for <code>type=='d'</code>.</li>
</ul>
<ul>
<li>By specifying <code>.append='y'</code> or <code>.append='e'</code> I will run the above two lines for you. Your <a class="el" href="gentle.html#apop_data">apop_data</a> pointer will not change, but its <code>matrix</code> element will be reallocated (via <a class="el" href="group__all__public.html#ga0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>).</li>
</ul>
<ul>
<li>By specifying <code>.append='i'</code>, I will place the matrix of dummies in place, immediately after the data column you had specified. You will probably use this with <code>.remove='y'</code> to replace the single column with the new set of dummy columns. Bear in mind that if there are two or more dummy columns, adding columns will change subsequent column numbers; use <a class="el" href="group__all__public.html#gadb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a> to find columns instead of giving an explicit column number.</li>
</ul>
<ul>
<li>If <code>.append='i'</code> and you asked for a text column, I will append to the end of the table, which is equivalent to <code>append='e'</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set with the column to be dummified (No default.) </td></tr>
    <tr><td class="paramname">col</td><td>The column number to be transformed; -1==vector (default = 0) </td></tr>
    <tr><td class="paramname">type</td><td>'d'==data column, 't'==text column. (default = 't') </td></tr>
    <tr><td class="paramname">keep_first</td><td>If <code>'n'</code>, return a matrix where each row has a one in the (column specified <em>minus one</em>). That is, the zeroth category is dropped, the first category has an entry in column zero, et cetera. If you don't know why this is useful, then this is what you need. If you know what you're doing and need something special, set this to <code>'y'</code> and the first category won't be dropped. (default = <code>'n'</code>) </td></tr>
    <tr><td class="paramname">append</td><td>If <code>'e'</code> or <code>'y'</code>, append the dummy grid to the end of the original data matrix. If <code>'i'</code>, insert in place, immediately after the original data column. (default = <code>'n'</code>) </td></tr>
    <tr><td class="paramname">remove</td><td>If <code>'y'</code>, remove the original data or text column. (default = <code>'n'</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set whose <code>matrix</code> element is the one-zero matrix of dummies. If you used <code>.append</code>, then this is the main matrix. Also, I add a page named <code>"\&lt;categories for your_var\&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Use <a class="el" href="group__all__public.html#gadec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> to get the list of category names. </li>
<li>NaNs appear at the end of the sort order. </li>
<li>See <a class="el" href="dataoverview.html#fact">Generating factors</a> for further discussion. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga27405bd5fdf48d93c8918ca4c07ee260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_to_factors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>intype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outcol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a column of text or numbers into a column of numeric factors, which you can use for a multinomial probit/logit, for example.</p>
<p>If you don't run this on your data first, <a class="el" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a> and <a class="el" href="group__models.html#gaa88a402cf7d02c25c4613a74ace1b0c1">apop_logit</a> default to running it on the vector or (if no vector) zeroth column of the matrix of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set, because those models need a list of the unique values of the dependent variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to be modified in place. (No default. If <code>NULL</code>, returns <code>NULL</code> and a warning) </td></tr>
    <tr><td class="paramname">intype</td><td>If <code>'t'</code>, then <code>incol</code> refers to text, if <code>'d'</code>, refers to the vector or matrix. (default = <code>'t'</code>) </td></tr>
    <tr><td class="paramname">incol</td><td>The column in the text that will be converted. -1 is the vector. (default = 0) </td></tr>
    <tr><td class="paramname">outcol</td><td>The column in the data set where the numeric factors will be written (-1 means the vector). (default = 0)</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *d  = apop_query_to_mixed_data(&quot;mmt&quot;, &quot;select 0, year, color from data&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_to_factors(d);</div>
</div><!-- fragment --><p> Notice that the query pulled a column of zeros for the sake of saving room for the factors. It reads column zero of the text, and writes it to column zero of the matrix.</p>
<p>Another example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *d  = apop_query_to_data(&quot;mmt&quot;, &quot;select type, year from data&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_to_factors(d, .intype=&#39;d&#39;, .incol=0, .outcol=0);</div>
</div><!-- fragment --><p> Here, the <code>type</code> column is converted to sequential integer factors and those factors overwrite the original data. Since a reference table is added as a second page of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, you can recover the original values as needed.</p>
<dl class="section return"><dt>Returns</dt><dd>A table of the factors used in the code. This is an <code><a class="el" href="structapop__data.html">apop_data</a></code> set with only one column of text. Also, I add a page named <code>"&lt;categories for your_var&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading) use <a class="el" href="group__all__public.html#gadec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> to retrieve that table.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the vector or matrix you wanted to write to is <code>NULL</code>, I will allocate it for you. </li>
<li>Use <a class="el" href="group__all__public.html#gadec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> to get the list of category names. </li>
<li>See <a class="el" href="dataoverview.html#fact">Generating factors</a> for further discussion. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga82281b8673cda3645054d7e061bb1167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transpose_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose the matrix and text elements of the input data set, including the row/column names.</p>
<p>The vector and weights elements of the input data set are completely ignored (but see also <a class="el" href="group__all__public.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>, which can convert a vector to a 1 X N matrix.) If copying, these other elements won't be present; if <code>.inplace='y'</code>, it is up to you to handle these not-transposed elements correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input <a class="el" href="gentle.html#apop_data">apop_data</a> set. If <code>NULL</code>, I return <code>NULL</code>. (default: <code>NULL</code>) </td></tr>
    <tr><td class="paramname">transpose_text</td><td>If <code>'y'</code>, then also transpose the text element. (default: <code>'y'</code>) </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, transpose the input in place; if <code>'n'</code>, produce a transposed copy, leaving the original untouched. Due to how <code>gsl_matrix_transpose_memcpy</code> works, a copy will still be made, then copied to the original location. (default: <code>'y'</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>inplace=='n'</code>, a newly alloced <a class="el" href="gentle.html#apop_data">apop_data</a> set, with the appropriately transposed matrix and/or text. The vector and weights elements will be <code>NULL</code>. If <code>transpose_text='n'</code>, then the text element of the output set will also be <code>NULL</code>.<br />
 if <code>inplace=='y'</code>, a pointer to the original data set, with matrix and (if <code>transpose_text='y'</code>, text) transposed and vector and weights left in place untouched.</dd></dl>
<ul>
<li>Row names are written to column names of the output matrix, text, or both (whichever is not empty in the input). </li>
<li>If only the matrix or only the text have names, then the one set of names is written to the row names of the output. </li>
<li>If both matrix column names and text column names are present, text column names are lost. </li>
<li>if you have a <code>gsl_matrix</code> with no names or text, you may prefer to use <code>gsl_matrix_transpose_memcpy</code>. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae3058b7f39d0442f13284464d1ba235d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_unpack </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>use_info_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the complement to <a class="el" href="group__all__public.html#ga90feb5dd661cfe0f0b53a85295b8b56e">apop_data_pack</a>, qv. It writes the <code>gsl_vector</code> produced by that function back to the <a class="el" href="gentle.html#apop_data">apop_data</a> set you provide. It overwrites the data in the vector and matrix elements and, if present, the <code>weights</code> (and that's it, so names or text are as before).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> of the form produced by <a class="el" href="group__all__public.html#ga90feb5dd661cfe0f0b53a85295b8b56e">apop_data_pack</a>. No default; must not be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">d</td><td>That data set to be filled. Must be allocated to the correct size. No default; must not be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">use_info_pages</td><td>Pages in XML-style brackets, such as <code>&lt;Covariance&gt;</code> will be ignored unless you set <code>.use_info_pages='y'</code>. Be sure that this is set to the same thing when you both pack and unpack. (Default: <code>'n'</code>).</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If I get to the end of the first page of the <code><a class="el" href="structapop__data.html">apop_data</a></code> set and have more entries in the vector to unpack, and the data to fill has a <code>more</code> element, then I will continue into subsequent pages. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gacf205f62e9432fe293b05c077d1b61d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_db_close </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vacuum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the database on disk. If you opened the database with <code>apop_db_open(NULL)</code>, then this is basically optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vacuum</td><td>'v': vacuum&mdash;do clean-up to minimize the size of the database on disk.<br />
 'q': Don't bother; just close the database. (default = 'q')</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on OK, nonzero on error. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4d81aff912df2982697038c51795e358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_db_open </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you want to use a database on the hard drive instead of memory, then call this once and only once before using any other database utilities.</p>
<p>With SQLite, if you want a disposable database which you won't use after the program ends, don't bother with this function.</p>
<p>The trade-offs between an on-disk database and an in-memory db are as one would expect: memory is faster, but the database is destroyed when the program exits.</p>
<p>MySQL users: either set the environment variable APOP_DB_ENGINE=mysql or set <code>apop_opts.db_engine</code> = 'm'.</p>
<p>The Apophenia package assumes you are only using a single database at a time. You can use the SQL <code>attach</code> function to load other databases, or see <a href="http://modelingwithdata.org/arch/00000142.htm">this blog post</a> for further suggestions and sample code.</p>
<p>When you are done doing your database manipulations, call <a class="el" href="group__all__public.html#gacf205f62e9432fe293b05c077d1b61d4">apop_db_close</a> if writing to disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of a file on the hard drive on which to store the database. If <code>NULL</code>, then the database will be kept in memory (in which case, the other database functions will call this function for you and you don't need to bother).</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>See <a class="el" href="c.html#sqlsec">About SQL, the syntax for querying databases</a> for mroe notes on using databases.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0: everything OK<br />
 1: database did not open. </dd></dl>

</div>
</div>
<a class="anchor" id="gad22f12fdb3606b0bc49cd1929a05626e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_db_to_crosstab </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>is_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give the name of a table in the database, and optional names of three of its columns: the x-dimension, the y-dimension, and the data. The output is a 2D matrix with rows indexed by 'row' and cols by 'col' and the cells filled with the entry in the 'data' column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tabname</td><td>The database table I'm querying. Anything that will work inside a <code>from</code> clause is OK, such as a subquery in parens. (no default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">row</td><td>The column of the data set that will indicate the rows of the output crosstab (no default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">col</td><td>The column of the data set that will indicate the columns of the output crosstab (no default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">data</td><td>The column of the data set holding the data for the cells of the crosstab (default: <code>count(*)</code>) </td></tr>
    <tr><td class="paramname">is_aggregate</td><td>Set to <code>'y'</code> if the <code>data</code> is a function like <code>count(*)</code> or <code>sum(col)</code>. That is, set to <code>'y'</code> if querying this would require a <code>group by</code> clause. (default: if I find an end-paren in <code>datacol</code>, <code>'y'</code>; else <code>'n'</code>.)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the query to get data to fill the table (select row, col, data from tabname) returns an empty data set, then I will return a <code>NULL</code> data set and if <code>apop_opts.verbosity &gt;= 1</code> print a warning.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='n'</td><td>Name not found error. </td></tr>
    <tr><td class="paramname">out-&gt;error='q'</td><td>Query returned an empty table (which might mean that it just failed).</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The simplest use is to get a tally of how often (r1, r2) appears in the data via <code>apop_db_to_crosstab("datatab", "r1", "r2")</code>. </li>
<li>If you want a 1-D crosstab, omit the other dimension. Or omit both to get a grand tally of your statistic for the entire table. </li>
<li>There is a commnad-line tool, <code>apop_db_to_crosstab</code> that calls this function. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga6984006ab44fa7c9c2e99463f7d4081b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_det_and_inv </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calc_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calc_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the determinant of a matrix, its inverse, or both, via LU decomposition. The <code>in</code> matrix is not destroyed in the process.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a>, <a class="el" href="group__all__public.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be inverted/determined. </td></tr>
    <tr><td class="paramname">out</td><td>If you want an inverse, this is where to place the matrix to be filled with the inverse. Will be allocated by the function.</td></tr>
    <tr><td class="paramname">calc_det</td><td>0: Do not calculate the determinant.<br />
 1: Do.</td></tr>
    <tr><td class="paramname">calc_inv</td><td>0: Do not calculate the inverse.<br />
 1: Do.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>calc_det == 1</code>, then return the determinant. Otherwise, just returns zero. If <code>calc_inv!=0</code>, then <code>*out</code> is pointed to the matrix inverse. In case of difficulty, I will set <code>*out=NULL</code> and return <code>NaN</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2d13e1b1f20f97e0772a0be41dc430e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>form1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>form2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for dot products, which requires less prep and typing than the <code>gsl_cblas_dgexx</code> functions.</p>
<p>It makes use of the semi-overloading of the <a class="el" href="gentle.html#apop_data">apop_data</a> structure. <code>d1</code> may be a vector or a matrix, and the same for <code>d2</code>, so this function can do vector dot matrix, matrix dot matrix, and so on. If <code>d1</code> includes both a vector and a matrix, then later parameters will indicate which to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d1</td><td>the left part of <img class="formulaInl" alt="$ d1 \cdot d2$" src="form_23.png"/> </td></tr>
    <tr><td class="paramname">d2</td><td>the right part of <img class="formulaInl" alt="$ d1 \cdot d2$" src="form_23.png"/> </td></tr>
    <tr><td class="paramname">form1</td><td>'t' or 'p': transpose or prime <code>d1-&gt;matrix</code>, or, if <code>d1-&gt;matrix</code> is <code>NULL</code>, read <code>d1-&gt;vector</code> as a row vector.<br />
 'n' or 0: use matrix if present; no transpose. (the default)<br />
 'v': ignore the matrix and use the vector.</td></tr>
    <tr><td class="paramname">form2</td><td>As above, with <code>d2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If two matrices come in, the vector element is <code>NULL</code> and the matrix has the dot product; if either or both are vectors, the vector has the output and the matrix is <code>NULL</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error='d'</td><td>dimension-matching error. </td></tr>
    <tr><td class="paramname">out-&gt;error='m'</td><td>GSL math error. </td></tr>
    <tr><td class="paramname">NULL</td><td>If you ask me to take the dot product of NULL, I return NULL. [May some day change.]</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Some systems auto-transpose non-conforming matrices. You input a <img class="formulaInl" alt="$3 \times 5$" src="form_24.png"/> and a <img class="formulaInl" alt="$3 \times 5$" src="form_24.png"/> matrix, and the system assumes that you meant to transpose the second, producing a <img class="formulaInl" alt="$(3 \times 5) \cdot (5 \times 3) \rightarrow (3 \times 3)$" src="form_25.png"/> output. Apophenia does not do this. First, it's ambiguous whether the output should be <img class="formulaInl" alt="$3 \times 3$" src="form_26.png"/> or <img class="formulaInl" alt="$5 \times 5$" src="form_27.png"/>. Second, your next run might have three observations, and two <img class="formulaInl" alt="$3 \times 3$" src="form_26.png"/> matrices don't require transposition; auto-transposition thus creates situations where bugs can pop up on only some iterations of a loop. </li>
<li>For a vector <img class="formulaInl" alt="$\cdot$" src="form_28.png"/> a matrix, the vector is always treated as a row vector, meaning that a <img class="formulaInl" alt="$(3\times 1)$" src="form_29.png"/> dot a <img class="formulaInl" alt="$(3\times 4)$" src="form_30.png"/> matrix is correct, and produces a <img class="formulaInl" alt="$(1 \times 4)$" src="form_31.png"/> vector. For a matrix <img class="formulaInl" alt="$\cdot$" src="form_28.png"/> a vector, the vector is always treated as a column vector. Requests for transposing the vector are ignored in both cases. </li>
<li>As a corrollary to the above rule, a vector dot a vector always produces a scalar, which will be put in the zeroth element of the output vector; see the example. </li>
<li>If you want to multiply an <img class="formulaInl" alt="$N \times 1$" src="form_32.png"/> vector <img class="formulaInl" alt="$\cdot$" src="form_28.png"/> a <img class="formulaInl" alt="$1 \times N$" src="form_33.png"/> vector to produce an <img class="formulaInl" alt="$N \times N$" src="form_34.png"/> matrix, then use <a class="el" href="group__all__public.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> to turn your vectors into matrices; see the example. </li>
<li>A note for readers of <em>Modeling with Data</em>: the awkward instructions on using this function on p 130 are now obsolete, thanks to the designated initializer syntax for function calls. Notably, in the case where <code>d1</code> is a vector and <code>d2</code> a matrix, then <code>apop_dot(d1,d2,'t')</code> won't work, because <code>'t'</code> now refers to <code>d1</code>. Instead use <code>apop_dot(d1,d2,.form2='t')</code> or <code>apop_dot(d1,d2,0, 't')</code> </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<p>Sample code: </p><div class="fragment"><div class="line"><span class="comment">/* A demonstration of dot products and various useful </span></div>
<div class="line"><span class="comment">   transformations among types. */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> eps=1e-3;<span class="comment">//slow to converge series--&gt;large tolerance.</span></div>
<div class="line"><span class="preprocessor">#define Diff(L, R) Apop_assert(fabs((L)-(R)&lt;(eps)), &quot;%g is too different from %g (abitrary limit=%g).&quot;, (double)(L), (double)(R), eps);</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">int</span> len = 3000;</div>
<div class="line">    gsl_vector *v = gsl_vector_alloc(len);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> i=0; i&lt; len; i++) gsl_vector_set(v, i, 1./(i+1));</div>
<div class="line">    <span class="keywordtype">double</span> square;</div>
<div class="line">    gsl_blas_ddot(v, v, &amp;square);</div>
<div class="line"><span class="preprocessor">    #ifndef Testing</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;1 + (1/2)^2 + (1/3)^2 + ...= %g\n&quot;</span>, square);</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> pi_over_six = gsl_pow_2(M_PI)/6.;</div>
<div class="line">    Diff(square, pi_over_six);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Now using apop_dot, in a few forms.</span></div>
<div class="line"><span class="comment">       First, vector-as-data dot itself.</span></div>
<div class="line"><span class="comment">       If one of the inputs is a vector,</span></div>
<div class="line"><span class="comment">       apop_dot puts the output in a vector-as-data:*/</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *v_as_data = &amp;(<a class="code" href="group__all__public.html#ga0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.vector=v};</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *vdotv = <a class="code" href="group__all__public.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(v_as_data, v_as_data);</div>
<div class="line">    Diff(gsl_vector_get(vdotv-&gt;vector, 0), pi_over_six);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Wrap matrix in an apop_data set. */</span></div>
<div class="line">    gsl_matrix *v_as_matrix = <a class="code" href="group__all__public.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>(v);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> dm = (<a class="code" href="group__all__public.html#ga0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.matrix=v_as_matrix};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// (1 X len) vector dot (len X 1) matrix --- produce a scalar (one item vector).</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *mdotv = <a class="code" href="group__all__public.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(v_as_data, &amp;dm);</div>
<div class="line">    <span class="keywordtype">double</span> scalarval = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(mdotv);</div>
<div class="line">    Diff(scalarval, pi_over_six);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//(len X 1) dot (len X 1) --- bad dimensions.</span></div>
<div class="line">    <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a>=-1; <span class="comment">//don&#39;t print an error.</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *mdotv2 = <a class="code" href="group__all__public.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(&amp;dm, v_as_data);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a>=0; <span class="comment">//back to safety.</span></div>
<div class="line">    assert(mdotv2-&gt;error);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If we want (len X 1) dot (1 X len) --&gt; (len X len),</span></div>
<div class="line">    <span class="comment">// use apop_vector_to_matrix.</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> dmr = (<a class="code" href="group__all__public.html#ga0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.matrix=<a class="code" href="group__all__public.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>(v, .row_col=<span class="charliteral">&#39;r&#39;</span>)};</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *product_matrix = <a class="code" href="group__all__public.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(&amp;dm, &amp;dmr);</div>
<div class="line">    <span class="comment">//The trace is the sum of squares:</span></div>
<div class="line">    gsl_vector_view trace = gsl_matrix_diagonal(product_matrix-&gt;matrix);</div>
<div class="line">    <span class="keywordtype">double</span> tracesum = <a class="code" href="group__all__public.html#ga9b05181ceec857e9eb9ed6a8ea7423d3">apop_sum</a>(&amp;trace.vector);</div>
<div class="line">    Diff(tracesum, pi_over_six);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(product_matrix);</div>
<div class="line">    gsl_matrix_free(dmr.matrix);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga87f15cd1923ed7b5b46e52a77ca1dfef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_draw </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draw from a model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An already-allocated array of <code>double</code>s to be filled by the draw method. It must have size <code>m-&gt;dsize</code>. </td></tr>
    <tr><td class="paramname">r</td><td>A <code>gsl_rng</code>, probably allocated via <a class="el" href="group__all__public.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>. Optional; if <code>NULL</code>, then I will call <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a> for an RNG. </td></tr>
    <tr><td class="paramname">m</td><td>The model from which to make draws.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the model has its own <code>draw</code> method, then this function will call it. </li>
<li>Else, if the model is univariate, use <a class="el" href="group__all__public.html#ga0492d6f5ae8a73a60b651cadb113d643">apop_arms_draw</a> to generate random draws. </li>
<li>Else, if the model is multivariate, use <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a> to generate random draws. </li>
<li>This makes a single draw of the given size. See <a class="el" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a> to fill a matrix with draws.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero on success; nozero on failure. <code>out[0]</code> is probably <code>NAN</code> on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c0598e5aca68949939a189bd4ce24ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_estimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the parameters of a model given data.</p>
<p>This function copies the input model, preps it (see <a class="el" href="group__all__public.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a>), and calls <code>m.estimate(d, m)</code> (which users are encouraged to never call directly). If your model has no <code>estimate</code> method, then call <code>apop_maximum_likelihood(d, m)</code>, with the default MLE settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data </td></tr>
    <tr><td class="paramname">m</td><td>The model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an output model, which typically matches the input model but has its <code>parameters</code> element filled in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga704e8625a022360600919116bc20ffbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_estimate_coefficient_of_determination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Also known as <img class="formulaInl" alt="$R^2$" src="form_46.png"/>. Let <img class="formulaInl" alt="$Y$" src="form_47.png"/> be the dependent variable, <img class="formulaInl" alt="$\epsilon$" src="form_48.png"/> the residual, <img class="formulaInl" alt="$n$" src="form_10.png"/> the number of data points, and <img class="formulaInl" alt="$k$" src="form_49.png"/> the number of independent vars (including the constant). Returns an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the following entries (in the vector element):</p>
<ul>
<li><img class="formulaInl" alt="$ SST \equiv \sum (Y_i - \bar Y) ^2 $" src="form_50.png"/> </li>
<li><img class="formulaInl" alt="$ SSE \equiv \sum \epsilon ^2 $" src="form_51.png"/> </li>
<li><img class="formulaInl" alt="$ R^2 \equiv 1 - {SSE\over SST} $" src="form_52.png"/> </li>
<li><img class="formulaInl" alt="$ R^2_{adj} \equiv R^2 - {(k-1)\over (n-k-1)}(1-R^2) $" src="form_53.png"/></li>
</ul>
<p>Internally allocates (and frees) a vector the size of your data set.</p>
<dl class="section return"><dt>Returns</dt><dd>: a <img class="formulaInl" alt="$5 \times 1$" src="form_54.png"/> <a class="el" href="structapop__data.html">apop_data</a> table with the following fields: <ul>
<li>"R squared" </li>
<li>"R squared adj" </li>
<li>"SSE" </li>
<li>"SST" </li>
<li>"SSR"</li>
</ul>
If the output is in <code>sss</code>, use <code>apop_data_get(sss, .rowname="SSE")</code> to get the SSE, and so on for the other items.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A model. I use the pointer to the data set used for estimation and the info page named <code>"&lt;Predicted&gt;"</code>. The Predicted page should include observed, expected, and residual columns, which I use to generate the sums of squared errors and residuals, et cetera. All generalized linear models produce a page with this name and of this form, as do a host of other models. Nothing keeps you from finding the <img class="formulaInl" alt="$R^2$" src="form_46.png"/> of, say, a kernel smooth; it is up to you to determine whether such a thing is appropriate to your given models and situation.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>apop_estimate(yourdata, apop_ols)</code> does this automatically </li>
<li>If I don't find a <code>"&lt;Predicted&gt;"</code> page, I print an error (iff <code>apop_opts.verbose &gt;=0</code>) and return <code>NULL</code>. </li>
<li>The number of observations equals the number of rows in the Predicted page </li>
<li>The number of independent variables, needed only for the adjusted <img class="formulaInl" alt="$R^2$" src="form_46.png"/>, is from the number of columns in the main data set's matrix (i.e. the first page; i.e. the set of parameters if this is the <code>parameters</code> output from a model estimation). </li>
<li>If your data (first page again) has a <code>weights</code> vector, I will find weighted SSE, SST, and SSR (and calculate the <img class="formulaInl" alt="$R^2$" src="form_46.png"/>s using those values). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga6d5e39c00012de5b51cd49ce1ffd31fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_estimate_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>starting_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum likelihod searches are not guaranteed to find a global optimum, and it can be difficult to tune a search such that it covers a wide space, but also accurately hones in on the optimum. In both cases, one could restart the search using a different starting point or different parameters.</p>
<p>The simplest use of this function is to restart a model at the latest parameter estimates.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_model *m = apop_estimate(data, model_using_an_MLE_search);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;for (int i=0; i&lt; 10; i++)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    m = apop_estimate_restart(m);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;apop_data_show(m);</div>
</div><!-- fragment --><p>By adding a line to reduce the tolerance each round [e.g., <code>Apop_settings_set(m, apop_mle, tolerance, pow(10,-i))</code>], you can start broad and hone in on a precise optimum.</p>
<p>You may have a new estimation method, such as first doing a coarse simulated annealing search, then a fine conjugate gradient search. When reading this example, recall that the form for adding a new settings group differs from the form for modifying existing settings: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Apop_model_add_settings(your_base_model, apop_mle, .method=APOP_SIMAN);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_model *m = apop_estimate(data, your_base_model);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Apop_settings_set(m, apop_mle, method, APOP_CG_PR);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;m = apop_estimate_restart(m);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;apop_data_show(m);</div>
</div><!-- fragment --><p>Only one estimate is returned, either the one you sent in or a new one. The loser (which may be the one you sent in) is freed, to prevent memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An <a class="el" href="structapop__model.html">apop_model</a> that is the output from a prior MLE estimation. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">copy</td><td>Another not-yet-parametrized model that will be re-estimated with (1) the same data and (2) a <code>starting_pt</code> as per the next setting (probably to the parameters of <code>e</code>). If this is <code>NULL</code>, then copy <code>e</code>. (Default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">starting_pt</td><td>"ep"=last estimate of the first model (i.e., its current parameter estimates)<br />
 "es"= starting point originally used by the first model<br />
 "np"=current parameters of the new (second) model<br />
 "ns"=starting point specified by the new model's MLE settings. (default = "ep") </td></tr>
    <tr><td class="paramname">boundary</td><td>I test whether the starting point you give me has magintude greater than this bound, so I can warn you if there's divergence in your sequence of re-estimations. (default: 1e8)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the new estimated parameters include any NaNs/Infs, then the old estimate is returned (even if the old estimate included NaNs/Infs). Otherwise, the estimate with the largest log likelihood is returned.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1902b3fd6a6682d1453a80b788e44ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_f_test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>contrast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs an F-test specified by <code>q</code> and <code>c</code>. See the chapter on hypothesis testing in <a href="http://modelingwithdata.org">Modeling With Data</a>, p 309, which will tell you that: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[{N-K\over q} {({\bf Q}'\hat\beta - {\bf c})' [{\bf Q}' ({\bf X}'{\bf X})^{-1} {\bf Q}]^{-1} ({\bf Q}' \hat\beta - {\bf c}) \over {\bf u}' {\bf u} } \sim F_{q,N-K},\]" src="form_90.png"/>
</p>
<p> and that's what this function is based on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">est</td><td>An <a class="el" href="structapop__model.html">apop_model</a> that you have already calculated. (No default) </td></tr>
    <tr><td class="paramname">contrast</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set whose matrix represents <img class="formulaInl" alt="${\bf Q}$" src="form_91.png"/> and whose vector represents <img class="formulaInl" alt="${\bf c}$" src="form_92.png"/>. Each row represents a hypothesis. (Defaults: if matrix is <code>NULL</code>, it is set to the identity matrix with the top row missing. If the vector is <code>NULL</code>, it is set to a zero matrix of length equal to the height of the contrast matrix. Thus, if the entire <code><a class="el" href="structapop__data.html">apop_data</a></code> set is NULL or omitted, we are testing the hypothesis that all but <img class="formulaInl" alt="$\beta_1$" src="form_93.png"/> are zero.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set with a few variants on the confidence with which we can reject the joint hypothesis. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error='d'</td><td>dimension-matching error. </td></tr>
    <tr><td class="paramname">out-&gt;error='i'</td><td>matrix inversion error. </td></tr>
    <tr><td class="paramname">out-&gt;error='m'</td><td>GSL math error.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>There are two approaches to an <img class="formulaInl" alt="$F$" src="form_97.png"/>-test: the ANOVA approach, which is typically built around the claim that all effects but the mean are zero; and the more general regression form, which allows for any set of linear claims about the data. If you send a <code>NULL</code> contrast set, I will generate the set of linear contrasts that are equivalent to the ANOVA-type approach. This is why the top row of the default <img class="formulaInl" alt="${\bf Q}$" src="form_91.png"/> matrix is missing: there is no hypothesis test about the coefficient for the constant term. See the example below. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define Diff(L, R, eps) {double left=(L), right=(R); Apop_stopif(isnan(left-right) || fabs((left)-(right))&gt;(eps), abort(), 0, &quot;%g is too different from %g (abitrary limit=%g).&quot;, (double)(left), (double)(right), eps);}</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> test_f(<a class="code" href="structapop__model.html">apop_model</a> *est){</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *rsq  = <a class="code" href="group__all__public.html#ga704e8625a022360600919116bc20ffbb">apop_estimate_coefficient_of_determination</a>(est);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *constr= <a class="code" href="group__all__public.html#ga0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a>(est-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector-&gt;size-1, est-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector-&gt;size);</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordflow">for</span> (i=1; i&lt; est-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector-&gt;size; i++)</div>
<div class="line">        <a class="code" href="group__all__public.html#ga5bdc618669b9ddc8239595d7b50bec9e">apop_data_set</a>(constr, i-1, i, 1);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *ftab = apop_F_test(est, constr);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *ftab2 = apop_F_test(est, NULL);</div>
<div class="line">    <span class="comment">//apop_data_show(ftab);</span></div>
<div class="line">    <span class="comment">//apop_data_show(ftab2);</span></div>
<div class="line">    <span class="keywordtype">double</span> n = est-&gt;<a class="code" href="structapop__model.html#a076635fcdacf54e685c4715c07c1183c">data</a>-&gt;matrix-&gt;size1;</div>
<div class="line">    <span class="keywordtype">double</span> K = est-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector-&gt;size-1;</div>
<div class="line">    <span class="keywordtype">double</span> r = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(rsq, .rowname=<span class="stringliteral">&quot;R squared&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> f = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(ftab, .rowname=<span class="stringliteral">&quot;F statistic&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> f2 = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(ftab2, .rowname=<span class="stringliteral">&quot;F statistic&quot;</span>);</div>
<div class="line">    Diff (f , r*(n-K)/((1-r)*K) , 1e-3);</div>
<div class="line">    Diff (f2 , r*(n-K)/((1-r)*K) , 1e-3);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a>(<span class="stringliteral">&quot;test_data2&quot;</span>);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *an_ols_model = <a class="code" href="group__all__public.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>);</div>
<div class="line">    Apop_model_add_group(an_ols_model, apop_lm, .want_expected_value= 1);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *e  = <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, an_ols_model);</div>
<div class="line">    test_f(e);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga217b3299f0704a856d40f213810914c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_generalized_harmonic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate <img class="formulaInl" alt="$\sum_{n=1}^N {1\over n^s}$" src="form_3.png"/></p>
<ul>
<li>There are no doubt efficient shortcuts do doing this, but I use brute force. [Though Knuth's Art of Programming v1 doesn't offer anything, which is strong indication of nonexistence.] To speed things along, I save the results so that they can just be looked up should you request the same calculation.</li>
</ul>
<ul>
<li>If <code>N</code> is zero or negative, return NaN. Notify the user if <code>apop_opts.verbosity &gt;=0</code></li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">double</span> out = <a class="code" href="group__all__public.html#ga217b3299f0704a856d40f213810914c4">apop_generalized_harmonic</a>(270, 0.0);</div>
<div class="line">     assert (out == 270);</div>
<div class="line">     out  = <a class="code" href="group__all__public.html#ga217b3299f0704a856d40f213810914c4">apop_generalized_harmonic</a>(370, -1.0);</div>
<div class="line">     assert (out == 370*371/2);</div>
<div class="line">     out  = <a class="code" href="group__all__public.html#ga217b3299f0704a856d40f213810914c4">apop_generalized_harmonic</a>(12, -1.0);</div>
<div class="line">     assert (out == 12*13/2);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2fe2a099150e242e974ed8f95142b3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_histograms_test_goodness_of_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test the goodness-of-fit between two <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> models.</p>
<p>Let <img class="formulaInl" alt="$o_i$" src="form_12.png"/> be the <img class="formulaInl" alt="$i$" src="form_13.png"/>th observed bin and <img class="formulaInl" alt="$e_i$" src="form_14.png"/> the expected value of that bin; then under typical assumptions, $ <img class="formulaInl" alt="$\Sum_i^N (o_i-e_i)^2/e_i \sim \Chi^2_{N-1}$" src="form_15.png"/>.</p>
<p>If you send two histograms, I assume that the histograms are synced: for PMFs, you've used <a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a> to generate two histograms using the same binspec, or you've used <a class="el" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> to guarantee that each observation value appears exactly once in each data set.</p>
<p>In any case, all values in the <code>observed</code> set must appear in the <code>expected</code> set with nonzero weight; otherwise this will return a <img class="formulaInl" alt="$\chi^2$" src="form_16.png"/> statistic of <code>GSL_POSINF</code>, indicating that it is impossible for the <code>observed</code> data to have been drawn from the <code>expected</code> distribution.</p>
<ul>
<li>If an observation row has weight zero, I skip it. if <code>apop_opts.verbose &gt;=1 </code> I will show a warning. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga8a85afbb18d256bcc8942d2eca7470ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_jackknife_cov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give me a data set and a model, and I'll give you the jackknifed covariance matrix of the model parameters.</p>
<p>The basic algorithm for the jackknife (glossing over the details): create a sequence of data sets, each with exactly one observation removed, and then produce a new set of parameter estimates using that slightly shortened data set. Then, find the covariance matrix of the derived parameters.</p>
<ul>
<li>Jackknife or bootstrap? As a broad rule of thumb, the jackknife works best on models that are closer to linear. The worse a linear approximation does (at the given data), the worse the jackknife approximates the variance.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set. An <a class="el" href="gentle.html#apop_data">apop_data</a> set where each row is a single data point. </td></tr>
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>, that will be used internally by <a class="el" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='n'</td><td><code>NULL</code> input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set whose matrix element is the estimated covariance matrix of the parameters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a></dd></dl>
<p>For example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">int</span> draw_ct = 1000;</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *m = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 1, 3);</div>
<div class="line">    <span class="keywordtype">double</span> sigma = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(m-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>, 1);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(m, draw_ct);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *out = <a class="code" href="group__all__public.html#ga8a85afbb18d256bcc8942d2eca7470ed">apop_jackknife_cov</a>(d, m);</div>
<div class="line">    <span class="keywordtype">double</span> error = fabs(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(out, 0,0)-gsl_pow_2(sigma)/draw_ct) <span class="comment">//var(mu)</span></div>
<div class="line">                + fabs(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(out, 1,1)-gsl_pow_2(sigma)/(2*draw_ct))<span class="comment">//var(sigma)</span></div>
<div class="line">                +fabs(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(out, 0,1)) +fabs(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(out, 1,0));<span class="comment">//cov(mu,sigma); should be 0.</span></div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(d);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(out);</div>
<div class="line">    assert(error &lt; 1e-2);<span class="comment">//Not very accurate.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa56d1f280fa5774300d10616cf24a3c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_kl_divergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draw_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Kullback-Leibler divergence.</p>
<p>This measure of the divergence of one distribution from another has the form <img class="formulaInl" alt="$ D(p,q) = \sum_i \ln(p_i/q_i) p_i $" src="form_80.png"/>. Notice that it is not a distance, because there is an asymmetry between <img class="formulaInl" alt="$p$" src="form_17.png"/> and <img class="formulaInl" alt="$q$" src="form_81.png"/>, so one can expect that <img class="formulaInl" alt="$D(p, q) \neq D(q, p)$" src="form_82.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the <img class="formulaInl" alt="$p$" src="form_17.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">to</td><td>the <img class="formulaInl" alt="$q$" src="form_81.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">draw_ct</td><td>If I do the calculation via random draws, how many? (Default = 1e5) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>. If <code>NULL</code> or number of threads is greater than 1, I'll take care of the RNG; see <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>. (Default = <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function can take empirical histogram-type models (<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>) or continuous models like <a class="el" href="group__models.html#gaf7d01cc4076c9319036a0cce882dac62">apop_loess</a> or <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>.</p>
<p>If there is a PMF (I'll try <code>from</code> first, under the presumption that you are measuring the divergence of a fitted model from an observed data distribution), then I'll step through it for the points in the summation.</p>
<ul>
<li>If you have two empirical distributions in the form of <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>, they must be synced: if <img class="formulaInl" alt="$p_i>0$" src="form_83.png"/> but <img class="formulaInl" alt="$q_i=0$" src="form_84.png"/>, then the function returns <code>GSL_NEGINF</code>. If <code>apop_opts.verbose &gt;=1</code> I print a message as well.</li>
</ul>
<p>If neither distribution is a PMF, then I'll take <code>draw_ct</code> random draws from <code>from</code> and evaluate at those points.</p>
<ul>
<li>Set <code>apop_opts.verbose = 3</code> for observation-by-observation info.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gad490e5b31d1bbc99223c2cbfac7c1782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_linear_constraint </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>margin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is designed to be called from within the constraint method of your <a class="el" href="structapop__model.html">apop_model</a>. Just write the constraint vector+matrix and this will do the rest. See <a class="el" href="maxipage.html#constr">Setting Constraints</a> for detailed discussion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>The proposed vector about to be tested. No default, must not be <code>NULL</code>.</td></tr>
    <tr><td class="paramname">constraint</td><td>A vector/matrix pair [v | m1 m2 ... mn] where each row is interpreted as a less-than inequality: <img class="formulaInl" alt="$v < m1x1+ m2x2 + ... + mnxn$" src="form_35.png"/>. For example, say your constraints are <img class="formulaInl" alt="$3 < 2x + 4y - 7z$" src="form_36.png"/> and <img class="formulaInl" alt="$y$" src="form_37.png"/> is positive, i.e. <img class="formulaInl" alt="$0 < y$" src="form_38.png"/>. Allocate and fill the matrix representing these two constraints via: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *constr = apop_data_falloc((2,2,3), 3,  2, 4, 7,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                                              0,  0, 1, 0);</div>
</div><!-- fragment --> . Default: each elements is greater than zero. For three parameters this would be equivalent to setting <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *constr = apop_data_falloc((3,3,3), 0,  1, 0, 0,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                                              0,  0, 1, 0,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                                              0,  0, 0, 1);</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">margin</td><td>If zero, then this is a &gt;= constraint, otherwise I will return a point this amount within the borders. You could try <code>GSL_DBL_EPSILON</code>, which is the smallest value a <code>double</code> can hold, or something like 1e-3. Default = 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The penalty: the distance between beta and the closest point that meets the constraints. If the constraint is met, the penalty is zero. If the constraint is not met, this <code>beta</code> is shifted by <code>margin</code> (Euclidean distance) to meet the constraints. <pre class="fragment">\li If your \ref apop_data has more structure than a vector, try \ref apop_data_pack to pack it
</pre> into a vector. This is what <a class="el" href="group__all__public.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> does. <ul>
<li>The function doesn't check for odd cases like coplanar constraints. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5e160c8d0a0ee660c89fb3f6de2af89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_log_likelihood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the log likelihood of a data/parametrized model pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data </td></tr>
    <tr><td class="paramname">m</td><td>The parametrized model, which must have either a <code>log_likelihood</code> or a <code>p</code> method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaacff3707e418a067104c77c410b43f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_d *&#160;</td>
          <td class="paramname"><em>fn_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_v *&#160;</td>
          <td class="paramname"><em>fn_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_r *&#160;</td>
          <td class="paramname"><em>fn_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dp *&#160;</td>
          <td class="paramname"><em>fn_dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vp *&#160;</td>
          <td class="paramname"><em>fn_vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rp *&#160;</td>
          <td class="paramname"><em>fn_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dpi *&#160;</td>
          <td class="paramname"><em>fn_dpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vpi *&#160;</td>
          <td class="paramname"><em>fn_vpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rpi *&#160;</td>
          <td class="paramname"><em>fn_rpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_di *&#160;</td>
          <td class="paramname"><em>fn_di</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vi *&#160;</td>
          <td class="paramname"><em>fn_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ri *&#160;</td>
          <td class="paramname"><em>fn_ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to every element of a data set, matrix or vector; or, apply a vector-taking function to every row or column of a matrix.</p>
<p>Your function could take any combination of a <code>gsl_vector</code>, a <code>double</code>, an <a class="el" href="gentle.html#apop_data">apop_data</a>, a parameter set, and the position of the element in the vector or matrix. As such, the function takes twelve function inputs, one for each combination of vector/matrix, params/no params, index/no index. Fortunately, because this function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs, you will specify only one.</p>
<p>For example, here is a function that will cut off each element of the input data to between <img class="formulaInl" alt="$(-1, +1)$" src="form_39.png"/>. It takes in a lone <code>double</code> and a parameter in a <code>void*</code>, so it gets sent to <a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> via <code>.fn_dp=cutoff</code>. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;double cutoff(double in, void *limit_in){ </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    double *limit = limit_in;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return GSL_MAX(-*limit, GSL_MIN(*limit, in)); </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;double param = 1;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;apop_map(your_data, .fn_dp=cutoff, .param=&amp;param, .inplace=&#39;y&#39;);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn_v</td><td>A function of the form <code>double your_fn(gsl_vector *in)</code> </td></tr>
    <tr><td class="paramname">fn_d</td><td>A function of the form <code>double your_fn(double in)</code> </td></tr>
    <tr><td class="paramname">fn_r</td><td>A function of the form <code>double your_fn(apop_data *in)</code> </td></tr>
    <tr><td class="paramname">fn_vp</td><td>A function of the form <code>double your_fn(gsl_vector *in, void *param)</code> </td></tr>
    <tr><td class="paramname">fn_dp</td><td>A function of the form <code>double your_fn(double in, void *param)</code> </td></tr>
    <tr><td class="paramname">fn_rp</td><td>A function of the form <code>double your_fn(apop_data *in, void *param)</code> </td></tr>
    <tr><td class="paramname">fn_vpi</td><td>A function of the form <code>double your_fn(gsl_vector *in, void *param, int index)</code> </td></tr>
    <tr><td class="paramname">fn_dpi</td><td>A function of the form <code>double your_fn(double in, void *param, int index)</code> </td></tr>
    <tr><td class="paramname">fn_rpi</td><td>A function of the form <code>double your_fn(apop_data *in, void *param, int index)</code> </td></tr>
    <tr><td class="paramname">fn_vi</td><td>A function of the form <code>double your_fn(gsl_vector *in, int index)</code> </td></tr>
    <tr><td class="paramname">fn_di</td><td>A function of the form <code>double your_fn(double in, int index)</code> </td></tr>
    <tr><td class="paramname">fn_ri</td><td>A function of the form <code>double your_fn(apop_data *in, int index)</code></td></tr>
    <tr><td class="paramname">in</td><td>The input data set. If <code>NULL</code>, I'll return <code>NULL</code> immediately. </td></tr>
    <tr><td class="paramname">param</td><td>A pointer to the parameters to be passed to those function forms taking a <code>*param</code>.</td></tr>
    <tr><td class="paramname">part</td><td>Which part of the <code><a class="el" href="structapop__data.html">apop_data</a></code> struct should I use?<br />
 'v'==Just the vector<br />
 'm'==Every element of the matrix, in turn<br />
 'a'==Both 'v' and 'm'<br />
 'r'==Apply a function <code>gsl_vector</code> <img class="formulaInl" alt="$\to$" src="form_40.png"/> <code>double</code> to each row of the matrix<br />
 'c'==Apply a function <code>gsl_vector</code> <img class="formulaInl" alt="$\to$" src="form_40.png"/> <code>double</code> to each column of the matrix<br />
 Default is 'a', but notice that I'll ignore a <code>NULL</code> vector or matrix, so if your data set has only a vector or only a matrix, that's what I'll use.</td></tr>
    <tr><td class="paramname">all_pages</td><td>If <code>'y'</code>, then follow the <code>more</code> pointer to subsequent pages. If <code>'n'</code>, handle only the first page of data. Default: <code>'n'</code>.</td></tr>
    <tr><td class="paramname">inplace</td><td>If 'n' (the default), generate a new <a class="el" href="gentle.html#apop_data">apop_data</a> set for output, which will contain the mapped values (and the names from the original set).<br />
 If 'y', modify in place. The <code>double</code> <img class="formulaInl" alt="$\to$" src="form_40.png"/> <code>double</code> versions, <code>'v'</code>, <code>'m'</code>, and <code>'a'</code>, write to exactly the same location as before. The <code>gsl_vector</code> <img class="formulaInl" alt="$\to$" src="form_40.png"/> <code>double</code> versions, <code>'r'</code>, and <code>'c'</code>, will write to the vector. Be careful: if you are writing in place and there is already a vector there, then the original vector is lost.<br />
 If 'v' (as in void), return <code>NULL</code>. (Default = 'n')</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='p'</td><td>missing or mismatched parts error, such as <code>NULL</code> matrix when you sent a function acting on the matrix element. <pre class="fragment">\li The function forms with &lt;tt&gt;r&lt;/tt&gt; in them, like \c fn_ri, are row-by-row. I'll use
</pre> <a class="el" href="group__all__public.html#ga401dbc60c9915be8e4c4def68b22d755">Apop_r</a> to get each row in turn, and send it to the function. The first implication is that your function should be expecting a <a class="el" href="gentle.html#apop_data">apop_data</a> set with exactly one row in it. The second is that <code>part</code> is ignored: it only makes sense to go row-by-row. <ul>
<li>For these <code>r</code> functions, if you set <code>inplace='y'</code>, then you will be modifying your input data set, row by row; if you set <code>inplace='n'</code>, then I will return an <a class="el" href="gentle.html#apop_data">apop_data</a> set whose <code>vector</code> element is as long as your data set (i.e., as long as the longest of your text, vector, or matrix parts). </li>
<li>If you set <code>apop_opts.thread_count</code> to a value greater than one, I will split the data set into as many chunks as you specify, and process them simultaneously. You need to watch out for the usual hang-ups about multithreaded programming, but if your data is iid, and each row's processing is independent of the others, you should have no problems. Bear in mind that generating threads takes some small overhead, so simple cases like adding a few hundred numbers will actually be slower when threading. </li>
<li>See <a class="el" href="dataoverview.html#mapply">Map/apply</a> for many more examples and notes. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga30601e357a1e21648f8d8db3c9ed6f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_map_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_d *&#160;</td>
          <td class="paramname"><em>fn_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_v *&#160;</td>
          <td class="paramname"><em>fn_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_r *&#160;</td>
          <td class="paramname"><em>fn_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dp *&#160;</td>
          <td class="paramname"><em>fn_dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vp *&#160;</td>
          <td class="paramname"><em>fn_vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rp *&#160;</td>
          <td class="paramname"><em>fn_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dpi *&#160;</td>
          <td class="paramname"><em>fn_dpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vpi *&#160;</td>
          <td class="paramname"><em>fn_vpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rpi *&#160;</td>
          <td class="paramname"><em>fn_rpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_di *&#160;</td>
          <td class="paramname"><em>fn_di</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vi *&#160;</td>
          <td class="paramname"><em>fn_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ri *&#160;</td>
          <td class="paramname"><em>fn_ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function that effectively calls <a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> and returns the sum of the resulting elements. Thus, this function returns a <code>double</code>. See the <a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> page for details of the inputs, which are the same here, except that <code>inplace</code> doesn't make sense&mdash;this function will always just add up the input function outputs. </p><pre class="fragment">\li I don't copy the input data to send to your input function. Therefore, if your
</pre><p> function modifies its inputs as a side-effect, your data set will be modified as this function runs. </p><ul>
<li>The sum of zero elements is zero, so that is what is returned if the input <a class="el" href="gentle.html#apop_data">apop_data</a> set is <code>NULL</code>. If <code>apop_opts.verbose &gt;= 2</code> print a warning. </li>
<li>See <a class="el" href="dataoverview.html#mapply">Map/apply</a> for many more examples and notes. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5c4ae58b861199bbc1a460719942d98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_apply </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(gsl_vector *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to every row of a matrix. The function that you input takes in a <code>gsl_vector</code> and returns nothing. <code>apop_matrix_apply</code> will produce a vector view of each row, and send each row to your function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>void fn(gsl_vector* in)</code> which may modify the data at the <code>in</code> pointer in place.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the matrix is <code>NULL</code>, this is a no-op and returns immediately. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga163589e9f5cb08f88f2032fc1229ec6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_apply_all </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies a function to every element in a matrix (as opposed to every row)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix whose elements will be inputs to the function </td></tr>
    <tr><td class="paramname">fn</td><td>A function with a form like <code>void f(double *in)</code> which may modify the data at the <code>in</code> pointer in place.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the matrix is <code>NULL</code>, this is a no-op and returns immediately. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga45bb322b9f491c46feb1e24025b6301f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_copy </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <code>gsl_matrix</code> to another. That is, all data are duplicated. Unlike <code>gsl_matrix_memcpy</code>, this function allocates and returns the destination, so you can use it like this: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_matrix *a_copy = apop_matrix_copy(original);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A structure that this function will allocate and fill. If <code>gsl_matrix_alloc</code> fails, returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03038130e4ba55228f9e164dba513961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_determinant </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the determinant of a matrix. The <code>in</code> matrix is not destroyed in the process.</p>
<p>See also <a class="el" href="group__all__public.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> , or <a class="el" href="group__all__public.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> to do both at once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga185243be2d8a93686c68263cc3318f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_inverse </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverts a matrix. The <code>in</code> matrix is not destroyed in the process. You may want to call <a class="el" href="group__all__public.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> first to check that your input is invertible, or use <a class="el" href="group__all__public.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> to do both at once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its inverse. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc7707d44884aa63c298510a0662956a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_matrix_is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>semi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the input matrix is positive semidefinite (PSD).</p>
<p>A covariance matrix will always be PSD, so this function can tell you whether your matrix is a valid covariance matrix.</p>
<p>Consider the 1x1 matrix in the upper left of the input, then the 2x2 matrix in the upper left, on up to the full matrix. If the matrix is PSD, then each of these has a positive determinant. This function thus calculates <img class="formulaInl" alt="$N$" src="form_6.png"/> determinants for an <img class="formulaInl" alt="$N$" src="form_6.png"/>x <img class="formulaInl" alt="$N$" src="form_6.png"/> matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to test. If <code>NULL</code>, I will return zero&mdash;not PSD. </td></tr>
    <tr><td class="paramname">semi</td><td>If anything but <code>'s'</code>, check for positive definite, not semidefinite. (default 's')</td></tr>
  </table>
  </dd>
</dl>
<p>See also <a class="el" href="group__all__public.html#gaf1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a>, which will change the input to something PSD.</p>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5da5091a11c37d3501d678b8ecec466f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_matrix_map </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(gsl_vector *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a function onto every row of a matrix. The function that you input takes in a <code>gsl_vector</code> and returns a <code>double</code>. This function will produce a sequence of vector views of each row of the input matrix, and send each to your function. It will output a <code>gsl_vector</code> holding your function's output for each row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>double fn(gsl_vector* in)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>gsl_vector</code> with the corresponding value for each row.</dd></dl>
<ul>
<li>If you input a <code>NULL</code> matrix, I return <code>NULL</code>. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gab1df9cb7fdd56e48593d99f5122224d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_map_all </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps a function to every element in a matrix (as opposed to every row).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix whose elements will be inputs to the function </td></tr>
    <tr><td class="paramname">fn</td><td>A function with a form like <code>double f(double in)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix of the same size as the original, with the function applied.</dd></dl>
<ul>
<li>If you input a <code>NULL</code> matrix, I return <code>NULL</code>. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gae04bc576579bfb2e14d5004d4af7bb88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_map_all_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>apop_matrix_map_all</code>, but returns the sum of the resulting mapped function. For example, <code>apop_matrix_map_all_sum(v, isnan)</code> returns the number of elements of <code>m</code> that are <code>NaN</code>.</p>
<ul>
<li>If you input a <code>NULL</code> matrix, I return the sum of zero items: zero. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga4f0c51a046140b563c8e12a6032e9a16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_map_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(gsl_vector *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>apop_matrix_map</code>, but returns the sum of the resulting mapped vector. For example, let <code>log_like</code> be a function that returns the log likelihood of an input vector; then <code>apop_matrix_map_sum(m, log_like)</code> returns the total log likelihood of the rows of <code>m</code>.</p>
<ul>
<li>If you input a <code>NULL</code> matrix, I return the sum of zero items: zero. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga040b9e9fea1abe105de86081bf396d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_mean </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mean of all elements of a matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The matrix to be averaged. If <code>NULL</code>, return zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean of all cells of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf794cc2491ef147e0c67eb05feed7a87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_mean_and_var </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mean and population variance of all elements of a matrix.</p>
<ul>
<li>If <code>NULL</code>, return <img class="formulaInl" alt="$\mu=0, \sigma^2=NaN$" src="form_71.png"/>. </li>
<li>Gives the population variance (sum of squares divided by <img class="formulaInl" alt="$N$" src="form_6.png"/>). If you want sample variance, multiply the result by <img class="formulaInl" alt="$N/(N-1)$" src="form_72.png"/>: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;double mu, var;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data *data= apop_query_to_data(&quot;select * from indata&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_matrix_mean_and_var(data-&gt;matrix, &amp;mu, &amp;var);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;var *= (data-&gt;size1*data-&gt;size2)/(data-&gt;size1*data-&gt;size2-1.0);</div>
</div><!-- fragment --></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. </td></tr>
    <tr><td class="paramname">mean</td><td>where to put the mean to be calculated. </td></tr>
    <tr><td class="paramname">var</td><td>where to put the variance to be calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1715c468336800a21ca86971323ae3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_matrix_pca </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>dimensions_we_want</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Principal component analysis: hand in a matrix and (optionally) a number of desired dimensions, and I'll return a data set where each column of the matrix is an eigenvector. The columns are sorted, so column zero has the greatest weight. The vector element of the data set gives the weights.</p>
<p>You may also specify the number of elements your principal component space should have. If this is equal to the rank of the space in which the input data lives, then the sum of weights will be one. If the dimensions desired is less than that (probably so you can prepare a plot), then the weights will be accordingly smaller, giving you an indication of how much variation these dimensions explain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input matrix. I modify int in place so that each column has mean zero. (No default. If <code>NULL</code>, return <code>NULL</code> and print a warning iff <code>apop_opts.verbose &gt;= 1</code>.)</td></tr>
    <tr><td class="paramname">dimensions_we_want</td><td>The singular value decomposition will return this many of the eigenvectors with the largest eigenvalues. (default: the size of the covariance matrix, i.e. <code>data-&gt;size2</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="gentle.html#apop_data">apop_data</a> set whose matrix is the principal component space. Each column of the returned matrix will be another eigenvector; the columns will be ordered by the eigenvalues.</dd></dl>
<p>The data set's vector will be the largest eigenvalues, scaled by the total of all eigenvalues (including those that were thrown out). The sum of these returned values will give you the percentage of variance explained by the factor analysis. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50915e9992a7cc880807cc266e9f5166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_print </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_declares&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a <code>gsl_matrix</code> to the screen, a file, a pipe, or a database table. You may want to set <a class="el" href="structapop__opts__type.html">apop_opts.output_delimiter</a>.</p>
<ul>
<li>See <a class="el" href="group__all__public.html#ga4748bf59f5441cd27e5b93056c7ec1c7">apop_prep_output</a> for more on how printing settings are set. </li>
<li>See also <a class="el" href="c.html#Legi">Legible output</a> for more details and examples. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaa06b6ab6ec9f78f305b1dacc8ec2efd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_realloc </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will resize a <code>gsl_matrix</code> to a new height or width.</p>
<p>Data in the matrix will be retained. If the new height or width is smaller than the old, then data in the later rows/columns will be cropped away (in a non&ndash;memory-leaking manner). If the new height or width is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill new rows/columns before use.</p>
<ul>
<li>A large number of <code>realloc</code>s can take a noticeable amount of time. You are encouraged to determine the size of your data beforehand and avoid writing <code>for</code> loops that reallocate the matrix at every iteration.</li>
</ul>
<ul>
<li>The <code>gsl_matrix</code> is a versatile struct that can represent submatrices and other cuts from parent data. Resizing a subset of a parent matrix makes no sense, so return <code>NULL</code> and print a warning if asked to resize a view of a matrix.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The already-allocated matrix to resize. If you give me <code>NULL</code>, this becomes equivalent to <code>gsl_matrix_alloc</code> </td></tr>
    <tr><td class="paramname">newheight,newwidth</td><td>The height and width you'd like the matrix to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e30501a20450f8e68f151844c3fbd78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_stack </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix const *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the first matrix either on top of or to the right of the second matrix. Returns a new matrix, meaning that at the end of this function, until you <code>gsl_matrix_free()</code> the original matrices, you will be taking up twice as much memory. Plan accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost matrix (default: <code>NULL</code>, in which case this copies <code>m2</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix (default: <code>NULL</code>, in which case <code>m1</code> is returned) </td></tr>
    <tr><td class="paramname">posn</td><td>If <code>'r'</code>, stack rows on top of other rows. If <code>'c'</code> stack columns next to columns. (default: <code>'r'</code>) </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, use <a class="el" href="group__all__public.html#gaa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> to modify <code>m1</code> in place; see the caveats on that function. Otherwise, allocate a new matrix, leaving <code>m1</code> undisturbed. (default: <code>'n'</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stacked data, either in a new matrix or a pointer to <code>m1</code>.</dd></dl>
<p>For example, here is a function to merge four matrices into a single two-part-by-two-part matrix. The original matrices are unchanged. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_matrix *apop_stack_two_by_two(gsl_matrix *ul, gsl_matrix *ur, gsl_matrix *dl, gsl_matrix *dr){</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  gsl_matrix *output, *t;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    output = apop_matrix_stack(ul, ur, &#39;c&#39;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    t = apop_matrix_stack(dl, dr, &#39;c&#39;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    apop_matrix_stack(output, t, &#39;r&#39;, .inplace=&#39;y&#39;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    gsl_matrix_free(t);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    return output;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga369c774aac917e56d8e32f9c66d9c2a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_matrix_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the elements of a matrix. Occasionally convenient. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to be summed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1fc93322ffcb4e20cfc0b9af9e2aea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes in a matrix and converts it in place to the `closest' positive semidefinite matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>On input, any matrix; on output, a positive semidefinite matrix. If <code>NULL</code>, return <code>NaN</code> and print an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the original and new matrices.</dd></dl>
<ul>
<li>See also the test function <a class="el" href="group__all__public.html#gafc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a>. </li>
<li>This function can be used as the core of a model constraint. </li>
<li>Adapted from the R Matrix package's nearPD, which is Copyright (2007) Jens Oehlschlägel [under the GPL]. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae9f092d1786034dd2ab22c63de5c955c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_maximum_likelihood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the likelihood-maximizing parameters of a model given data.</p>
<ul>
<li>I assume that <a class="el" href="group__all__public.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> has been called on your model. The easiest way to guarantee this is to use <a class="el" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>, which calls this function if the input model has no <code>estimate</code> method.</li>
</ul>
<ul>
<li>All of the settings are specified by adding a <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> struct to your model, so see the many notes there. Notably, the default method is the Fletcher-Reeves conjugate gradient method, and if your model does not have a dlog likelihood function, then a numeric gradient will be calculated via <a class="el" href="group__all__public.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a>. Add an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group to your model to set tuning parameters or select other methods, including the Nelder-Mead simplex, simulated annealing, and root-finding.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set.</td></tr>
    <tr><td class="paramname">dist</td><td>The <a class="el" href="structapop__model.html">apop_model</a> object: <a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">apop_gamma</a>, <a class="el" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a>, <a class="el" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, &amp;c. You can add an <code><a class="el" href="structapop__mle__settings.html">apop_mle_settings</a></code> struct to it (<code>Apop_model_add_group(your_model, apop_mle, .verbose=1, .method="PR cg", and_so_on)</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None, but the input model is modified to include the parameter estimates, &amp;c.</dd></dl>
<ul>
<li>There is auxiliary info in the <code>-&gt;info</code> element of the post-estimation struct. Get elements via, e.g.: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_model *est = apop_estimate(your_data, apop_probit);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int status = apop_data_get(est-&gt;info, .rowname=&quot;status&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if (status)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    //trouble</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;else</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    //optimum found</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    apop_data_print(est-&gt;parameters); //Here are the estimated parameters</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>During the search for an optimum, ctrl-C (SIGINT) will halt the search, and the function will return whatever parameters the search was on at the time. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2a184259c139f1fdd970ef6b43f6274e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_ml_impute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>mvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Impute the most likely data points to replace NaNs in the data, and insert them into the given data. That is, the data set is modified in place.</p>
<p>How it works: this uses the machinery for <a class="el" href="group__all__public.html#gab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>. The only difference is that this searches over the data space and takes the parameter space as fixed, while basic fix params model searches parameters and takes data as fixed. So this function just does the necessary data-parameter switching to make that happen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set. It comes in with NaNs and leaves entirely filled in. </td></tr>
    <tr><td class="paramname">mvn</td><td>A parametrized <a class="el" href="structapop__model.html">apop_model</a> from which you expect the data was derived. if <code>NULL</code>, then I'll use the Multivariate Normal that best fits the data after listwise deletion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An estimated <a class="el" href="structapop__model.html">apop_model</a>. Also, the data input will be filled in and ready to use. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa86381a72949fd3ffafefa87e3f51a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up the <code>parameters</code> and <code>info</code> elements of the <code><a class="el" href="structapop__model.html">apop_model</a>:</code> </p>
<p>At close, the input model has parameters of the correct size.</p>
<ul>
<li>This is the default action for <a class="el" href="group__all__public.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a>, and many models with a custom prep routine call <a class="el" href="group__all__public.html#gaa86381a72949fd3ffafefa87e3f51a4f">apop_model_clear</a> at the end. Also, <a class="el" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> calls this function internally, which means that you robably never have to call this function directly. </li>
<li>If the model has already been prepped, this function should be a no-op.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>If your params vary with the size of the data set, then the function needs a data set to calibrate against. Otherwise, it's OK to set this to <code>NULL</code>. </td></tr>
    <tr><td class="paramname">model</td><td>The model whose output elements will be modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the same model, should you need it. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">outmodel-&gt;error=='d'</td><td>dimension error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87d3a65f43071b9d61d9edd59249c629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs a copy of the <a class="el" href="structapop__model.html">apop_model</a> input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The model to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the original. Includes copies of all settings groups, and the <code>parameters</code> (if not <code>NULL</code>, copied via <a class="el" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>).</dd></dl>
<ul>
<li>If <code>in.more_size &gt; 0</code> I <code>memcpy</code> the <code>more</code> pointer from the original data set. </li>
<li>The data set at <code>in-&gt;data</code> is not copied, but is also pointed to.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. In extreme cases, where there aren't even a few hundred bytes available, I will return <code>NULL</code>. </td></tr>
    <tr><td class="paramname">out-&gt;error=='s'</td><td>Error copying settings groups. </td></tr>
    <tr><td class="paramname">out-&gt;error=='p'</td><td>Error copying parameters or info page; the given <a class="el" href="gentle.html#apop_data">apop_data</a> struct may be <code>NULL</code> or may have its own <code>-&gt;error</code> element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e204cdc7429bef3ca2efb83453fe77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_model_draws </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>draws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a set of random draws from a model and write them to an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model from which draws will be made. Must already be prepared and/or estimated.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to make. If <code>draw_matrix</code> is not <code>NULL</code>, then this is ignored and <code>count=draw_matrix-&gt;matrix-&gt;size1</code>. default=1000.</td></tr>
    <tr><td class="paramname">draws</td><td>If not <code>NULL</code>, a pre-allocated data set whose <code>matrix</code> element will be filled with draws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with the matrix filled with <code>size</code> draws. If <code>draw_matrix!=NULL</code>, then return a pointer to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='m'</td><td>Input model isn't good for making draws: it is <code>NULL</code>, or <code>m-&gt;dsize=0</code>.</td></tr>
    <tr><td class="paramname">out-&gt;error=='s'</td><td>You gave me a <code>draws</code> matrix, but its size is less than the size of a single draw from the data, <code>model-&gt;dsize</code>.</td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Trouble drawing from the distribution for at least one row. That row is set to all <code>NAN</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Prints a warning if you send in a non-<code>NULL <a class="el" href="structapop__data.html">apop_data</a></code> set, but its <code>matrix</code> element is <code>NULL</code>, when <code>apop_opts.verbose&gt;=1</code>. </li>
<li>See also <a class="el" href="group__all__public.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a>, which makes a single draw. </li>
<li>Random numbers are generated using RNGs from <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>, qv.</li>
</ul>
<p>Here is a two-line program to draw a different set of ten Standard Normals on every run (provided runs are more than a second apart):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.rng_seed = time(NULL);</div>
<div class="line">    <a class="code" href="group__all__public.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(</div>
<div class="line">            <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(</div>
<div class="line">                <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1), </div>
<div class="line">                .count=10, </div>
<div class="line">            )</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga4d8310d52c11bcb7a8d32656a21c44cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_model_entropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the entropy of a model: <img class="formulaInl" alt="$\int -\ln(p(x))p(x)dx$" src="form_78.png"/>, which is the expected value of <img class="formulaInl" alt="$-\ln(p(x))$" src="form_79.png"/>.</p>
<p>The default method is to make draws using <a class="el" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>, then evaluate the log likelihood at those points using the model's <code>log_likelihood</code> method.</p>
<p>There are a number of routines for specific models, inlcuding the <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> and <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> models.</p>
<ul>
<li>If you want the entropy of a data set, see <a class="el" href="group__all__public.html#gabd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>. </li>
<li>The entropy is calculated using natural logs. If you prefer base-2 logs, just divide by <img class="formulaInl" alt="$\ln(2)$" src="form_77.png"/>: <code>apop_model_entropy(my_model)/log(2)</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A parameterized <a class="el" href="structapop__model.html">apop_model</a>. That is, you have already used <a class="el" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> or <a class="el" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a> to estimate/set the model parameters. </td></tr>
    <tr><td class="paramname">draws</td><td>If using the default method of making random draws, how many random draws to make (default=1,000)</td></tr>
  </table>
  </dd>
</dl>
<p>Sample code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define Diff(left, right, eps) Apop_stopif(fabs((left)-(right))&gt;(eps), \</span></div>
<div class="line"><span class="preprocessor">        abort(), 0, &quot;%g is too different from %g (abitrary limit=%g).&quot;, \</span></div>
<div class="line"><span class="preprocessor">        (double)(left), (double)(right), eps)</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* The entropy function, like some other functions (including apop_update) has a lookup</span></div>
<div class="line"><span class="comment"> table for known models like the Normal distribution. If the input model has</span></div>
<div class="line"><span class="comment"> \c log_likelihood, \c p, and \c draw functions that are the ones found in \ref</span></div>
<div class="line"><span class="comment"> apop_nomrmal, then use a known calculation to report entropy; else report based on</span></div>
<div class="line"><span class="comment"> random draws from the model.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">If we make a copy of the \ref apop_normal model and replace the log likelihood with</span></div>
<div class="line"><span class="comment">a new function that produces identical values, the lookup table will not find the</span></div>
<div class="line"><span class="comment">modified model, and the calculation via random draws will be done. Of course, the</span></div>
<div class="line"><span class="comment">final entropy as calculated using both methods should differ only by a small amount.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">double</span> mask(<a class="code" href="structapop__data.html">apop_data</a> *d, <a class="code" href="structapop__model.html">apop_model</a> *m){</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>-&gt;log_likelihood(d, m);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> i=0.1; i&lt; 10; i+=.2){</div>
<div class="line">        <a class="code" href="structapop__model.html">apop_model</a> *n = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 8, i);</div>
<div class="line">        <span class="keywordtype">long</span> <span class="keywordtype">double</span> v= <a class="code" href="group__all__public.html#ga4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a>(n);</div>
<div class="line">        n-&gt;<a class="code" href="structapop__model.html#a25bf144576642b48097e764318a6ce28">log_likelihood</a> = mask;</div>
<div class="line">        <span class="keywordtype">long</span> <span class="keywordtype">double</span> w= <a class="code" href="group__all__public.html#ga4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a>(n, 50000);</div>
<div class="line">        Diff(v, w, 5e-2);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab4f6ca7e042ac7c09c3c01d29702a739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_fix_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a model based on another model, but with some of the parameters fixed at a given value.</p>
<p>You will send me the model whose parameters you want fixed, with the <code>parameters</code> element set as follows. For the fixed parameters, simply give the values to which they will be fixed. Set the free parameters to <code>NaN</code>.</p>
<p>For example, here is a Binomial distribution with a fixed <img class="formulaInl" alt="$n=30$" src="form_185.png"/> but <img class="formulaInl" alt="$p_1$" src="form_179.png"/> allowed to float freely:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_model *bi30 = apop_model_fix_params(apop_model_set_parameters(apop_binomial, 30, NAN));</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Apop_model_add_group(bi30, apop_mle, .starting_pt=(double[]){.5}); // The Binomial doesn&#39;t like the</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                                                                   //  default starting point of 1.</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;apop_model *out = apop_estimate(your_data, bi30);</div>
</div><!-- fragment --><p>The output is an <code><a class="el" href="structapop__model.html">apop_model</a></code> that can be estimated, Bayesian updated, et cetera.</p>
<ul>
<li>Rather than using this model, you may simply want a now-filled-in copy of the original model. Use <a class="el" href="group__all__public.html#gaf676505faea1c7e30ffbd8690a092ed8">apop_model_fix_params_get_base</a> to retrieve the original model's parameters. </li>
<li>The <code>estimate</code> method always uses an MLE, and it never calls the base model's <code>estimate</code> method. </li>
<li>If the input model has an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group attached, I'll use them for the <code>estimate</code> method. Otherwise, I'll set my own. </li>
<li>If the parameter input has non-NaN values at the free parameters, then I'll use those as the starting point for any MLE search; the defaults for the variables without fixed values starts from <b>1</b> as usual. </li>
<li>I do check the <code>more</code> pointer of the <code>parameters</code> for additional pages and <code>NaN</code>s on those pages.</li>
</ul>
<p>Here is a sample program. It produces a few thousand draws from a Multivariate Normal distribution, and then tries to recover the means given a var/covar matrix fixed at the correct variance.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">size_t</span> ct = 5e4;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//set up the model &amp; params</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *params = <a class="code" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((2,2,2), 8,  1, 0.5,</div>
<div class="line">                                                  2,  0.5, 1);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *pvm = <a class="code" href="group__all__public.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga3a4389e6e2a1a2ea606f89d55ec558d3">apop_multivariate_normal</a>);</div>
<div class="line">    pvm-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a> = <a class="code" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(params);</div>
<div class="line">    pvm-&gt;<a class="code" href="structapop__model.html#a5e31343782fe36a70e60e6d0808c64b5">dsize</a> = 2;</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(pvm, ct);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//set up and estimate a model with fixed covariance matrix but free means</span></div>
<div class="line">    gsl_vector_set_all(pvm-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, GSL_NAN);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *mep1 = <a class="code" href="group__all__public.html#gab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(pvm);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *e1 = <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, mep1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//compare results, via assert for the test suite, or on-screen for human use.</span></div>
<div class="line"><span class="preprocessor">#ifdef Testing</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(params-&gt;vector, e1-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector)&lt;1e-2);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;original params: &quot;</span>);</div>
<div class="line">    apop_vector_show(params-&gt;vector);</div>
<div class="line">    printf(<span class="stringliteral">&quot;estimated params: &quot;</span>);</div>
<div class="line">    apop_vector_show(e1-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model_in</td><td>The base model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a model that can be used like any other, with the given params fixed or free. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf676505faea1c7e30ffbd8690a092ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_fix_params_get_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>fixed_model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__all__public.html#gab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> function produces a model that has only the non-fixed parameters of the model. After estimation of the fixed-parameter model, this function fills the <code>parameters</code> element of the base model and returns a pointer to the base model. </p>

</div>
</div>
<a class="anchor" id="gab29755a86b82dfe31cdd01d55431cc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_model_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>free_me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an <a class="el" href="structapop__model.html">apop_model</a> structure.</p>
<ul>
<li>The <code>parameters</code> and <code>settings</code> are freed. These are the elements that are copied by <code>apop_model_copy</code>. </li>
<li>The <code>data</code> element is not freed, because the odds are you still need it. </li>
<li>If <code>free_me-&gt;more_size</code> is positive, the function runs <code>free(free_me-&gt;more)</code>. But it has no idea what the <code>more</code> element contains; if it points to other structures (like an <a class="el" href="gentle.html#apop_data">apop_data</a> set), you need to free them before calling this function. </li>
<li>If <code>free_me</code> is <code>NULL</code>, this does nothing.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_me</td><td>A pointer to the model to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a55a20880947e289767aad6e5b0117c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_model_hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Numerically estimate the matrix of second derivatives of the parameter values, via a series of re-evaluations at small differential steps. [Therefore, it may be expensive to do this for a very computationally-intensive model.]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> at which the model was estimated (default: <code>NULL</code>) </td></tr>
    <tr><td class="paramname">model</td><td>The <a class="el" href="structapop__model.html">apop_model</a>, with parameters already estimated (no default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">delta</td><td>the step size for the differentials. (default: 1e-3, but see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix of estimated second derivatives at the given data and parameter values.</dd></dl>
<ul>
<li>If you do not set delta as an input, I first look for an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group attached to the input model, and check that for a <code>delta</code> element. If that is also missing, use the default of 1e-3. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga733c60eab5b69d89729565a3aeeb15d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_metropolis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use <a href="https://en.wikipedia.org/wiki/Metropolis-Hastings">Metropolis-Hastings Markov chain Monte Carlo</a> to make draws from the given model.</p>
<p>The basic storyline is that draws are made from a proposal distribution, and the likelihood of your model given your data and the drawn parameters evaluated. At each step, a new set of proposal parameters are drawn, and if they are more likely than the previous set the new proposal is accepted as the next step, else with probability (prob of new params)/(prob of old params), they are accepted as the next step anyway. Otherwise the last accepted proposal is repeated.</p>
<p>The output is an <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model with a data set listing the draws that were accepted, including those repetitions. The output model is modified so that subsequent draws are one more step from the Markov chain, via <a class="el" href="group__all__public.html#gaa28fc59f2675fd5bcd530cb7325b6c60">apop_model_metropolis_draw</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set used for evaluating the likelihood of a proposed parameter set.</td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, probably allocated via <a class="el" href="group__all__public.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>. (Default: an RNG from <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>)</td></tr>
    <tr><td class="paramname">m</td><td>The <a class="el" href="structapop__model.html">apop_model</a> from which parameters are being drawn. (No default; must not be <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A modified <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model representing the results of the search. It has a specialized <code>draw</code> method that returns another step from the Markov chain with each draw.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='c'</td><td>Proposal was outside of a constraint; see below.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If a proposal fails to meet the <code>constraint</code> element of the model you input, then the proposal is thrown out and a new one selected. By the default proposal distribution, this is not mathematically correct (it breaks detailed balance), and values near the constraint will be oversampled. The output model will have <code>outmodel-&gt;error=='c'</code>. It is up to you to decide whether the resulting distribution is good enough for your purposes or whether to take the time to write a custom proposal and step function to accommodate the constraint.</li>
</ul>
<p>Attach an <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group to your model to specify the proposal distribution, burnin, and other details of the search. See the <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> documentation for details. </p><pre class="fragment">\li The default proposal includes an adaptive step: you specify a target accept rate
</pre><p> (default: .35), and if the accept rate is currently higher the variance of the proposals is widened to explore more of the space; if the accept rate is currently lower the variance is narrowed to stay closer to the last accepted proposal. Technically, this breaks ergodicity of the Markov chain, but the consensus seems to be that this is not a serious problem. If it does concern you, you can set the <code>base_adapt_fn</code> in the <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group to a do-nothing function, or one that damps its adaptation as <img class="formulaInl" alt="$n\to\infty$" src="form_41.png"/>. </p><ul>
<li>If you have a univariate model, <a class="el" href="group__all__public.html#ga0492d6f5ae8a73a60b651cadb113d643">apop_arms_draw</a> may be a suitable simpler alternative. </li>
<li>Note the <code>gibbs_chunks</code> element of the <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group. If you set <code>gibbs_chunks='a'</code>, all parameters are drawn as a set, and accepted/rejected as a set. The variances are adapted at an identical rate. If you set <code>gibbs_chunks='i'</code>, then each scalar parameter is assigned its own proposal distribution, which is adapted at its own pace. With <code>gibbs_chunks='b'</code> (the default), then each of the vector, matrix, and weights of your model's parameters are drawn/accepted/adapted as a block (and so on to additional chunks if your model has <code>-&gt;more</code> pages). This works well for complex models which naturally break down into subsets of parameters. </li>
<li>Each chunk counts as a step in the Markov chain. Therefore, if there are several chunks, you can expect chunks to repeat from step to step. If you want a draw after cycling through all chunks, try using <a class="el" href="group__all__public.html#gaa28fc59f2675fd5bcd530cb7325b6c60">apop_model_metropolis_draw</a>, which has that behavior. </li>
<li>If the likelihood model has <code>NULL</code> parameters, I will allocate them. That means you can use one of the stock models that ship with Apophenia. If I need to run the model's prep routine to get the size of the parameters, then I will make a copy of the likelihood model, run prep, and then allocate parameters for that copy of a model. </li>
<li>On exit, the <code>parameters</code> element of your likelihood model has the last accepted parameter proposal. </li>
<li>If you set <code>apop_opts.verbose=2</code> or greater, I will report the accept rate of the M-H sampler. It is a common rule of thumb to select a proposal so that this is between 20% and 50%. Set <code>apop_opts.verbose=3</code> to see the stream of proposal points, their likelihoods, and the acceptance odds. You may want to set <code>apop_opts.log_file=fopen("yourlog", "w")</code> first.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaa28fc59f2675fd5bcd530cb7325b6c60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_model_metropolis_draw </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The draw method for models estimated via <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a>.</p>
<p>That method produces an <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>, typically with a few thousand draws from the model in a batch. If you want to get a single next step from the Markov chain, use this.</p>
<p>A Markov chain works by making a new draw and then accepting or rejecting the draw. If the draw is rejected, the last value is reported as the next step in the chain. Users sometimes mitigate this repetition by making a batch of draws (say, ten at a time) and using only the last.</p>
<p>If you run this without first running <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a>, I will run it for you, meaning that there will be an initial burn-in period before the first draw that can be reported to you. That run is done using <code>model-&gt;data</code> as input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array of <code>doubles</code>, which will hold the draw, in the style of <a class="el" href="group__all__public.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a>. </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, already initialized, probably via <a class="el" href="group__all__public.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>. </td></tr>
    <tr><td class="paramname">model</td><td>A model which was probably already run through <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On return, <code>out</code> is filled with the next step in the Markov chain. The <code>-&gt;data</code> element of the PMF model is extended to include the additional steps in the chain. If a proposal failed the model constraints, then return 1; else return 0. See the notes in the documentation for <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a>. <pre class="fragment">\li After pulling the attached settings group, the parent model is ignored. One expects
</pre> that <code>base_model</code> in the mcmc settings group == the parent model. <ul>
<li>If your settings break the model parameters into several chunks, this function returns after stepping through all chunks. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0f2784b69175d1ecd3833d228d2294e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_model_numerical_covariance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce the covariance matrix for the parameters of an estimated model via the derivative of the score function at the parameter. I.e., I find the second derivative via <a class="el" href="group__all__public.html#ga1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> , and take the negation of the inverse.</p>
<p>I follow Efron and Hinkley in using the estimated information matrix&mdash;the value of the information matrix at the estimated value of the score&mdash;not the expected information matrix that is the integral over all possible data. See Pawitan 2001 (who cribbed a little off of Efron and Hinkley) or Klemens 2008 (who directly cribbed off of both) for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data by which your model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>A model whose parameters have been estimated. </td></tr>
    <tr><td class="paramname">delta</td><td>The differential by which to step for sampling changes. (default: 1e-3, but see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A covariance matrix for the data. Also, if the data does not have a <code>"&lt;Covariance&gt;"</code> page, I'll set it to the result as well [i.e., I won't overwrite an existing covariance page].</dd></dl>
<ul>
<li>If you do not set delta as an input, I first look for an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group attached to the input model, and check that for a <code>delta</code> element. If that is also missing, use the default of 1e-3. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gadb1e9f6fbed5357e6446211a1dabb804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_model_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>print_me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the results of an estimation for a human to look over.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_me</td><td>The model whose information should be displayed </td></tr>
    <tr><td class="paramname">ap</td><td>The output stream. If <code>NULL</code>, use <code>stdout</code>. If you'd like something else, use <code>fopen</code>. E.g.: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;FILE *out =fopen(&quot;outfile.txt&quot;, &quot;w&quot;); //or &quot;a&quot; to append.</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_model_print(the_model, out);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;fclose(out);  //optional in many cases.</div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The default prints the name, parameters, info, &amp;c. but I check a vtable for alternate methods you define; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. The typedef new functions must conform to and the hash used for lookups are:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;typedef void (*apop_model_print_type)(apop_model *params, FILE *out);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define apop_model_print_hash(m1) ((m1)-&gt;log_likelihood ? (size_t)(m1)-&gt;log_likelihood : \</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            (m1)-&gt;p ? (size_t)(m1)-&gt;p*33 : \</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            (m1)-&gt;estimate ? (size_t)(m1)-&gt;estimate*33*33 : \</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            (m1)-&gt;draw ? (size_t)(m1)-&gt;draw*33*27  : \</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            (m1)-&gt;cdf ? (size_t)(m1)-&gt;cdf*27*27 : 27)</div>
</div><!-- fragment --><p>When building a special print method, all output should <code>fprintf</code> to the input <code>FILE*</code> handle. Apophenia's output routines also accept a file handle; e.g., if the file handle is named <code>out</code>, then if the <code>thismodel</code> print method uses <code>apop_data_print</code> to print the parameters, it must do so via a form like <code>apop_data_print(thismodel-&gt;parameters, .output_pipe=ap)</code>.</p>
<p>Your <code>print</code> method can use both by masking itself for a few lines: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void print_method(apop_model *in, FILE* ap){</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  void *temp = in-&gt;estimate;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  in-&gt;estimate = NULL;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  apop_model_print(in, ap);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  in-&gt;estimate = temp;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  printf(&quot;Additional info:\n&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  ...</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
</div><!-- fragment --><ul>
<li>Print methods are intended for human consumption and are subject to change. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga313527fa21f9a9686be8dd73579950f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_to_pmf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>binspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>draws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make random draws from an <a class="el" href="structapop__model.html">apop_model</a>, and bin them using a binspec in the style of <a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a>. If you have a data set that used the same binspec, you now have synced histograms, which you can plot or sensibly test hypotheses about.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binspec</td><td>A description of the bins in which to place the draws; see <a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a>. (default: as in <a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a>.) </td></tr>
    <tr><td class="paramname">model</td><td>The model to be drawn from. Because this function works via random draws, the model needs to have a <code>draw</code> method. (No default) </td></tr>
    <tr><td class="paramname">draws</td><td>The number of random draws to make. (arbitrary default = 10,000) </td></tr>
    <tr><td class="paramname">bin_count</td><td>If no bin spec, the number of bins to use (default: as per <a class="el" href="group__all__public.html#gad60f2beb7836119d364676a361cb5e42">apop_data_to_bins</a>, <img class="formulaInl" alt="$\sqrt(N)$" src="form_11.png"/>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model, with a new binned data set attached (which you may have to <code>apop_data_free(output_model-&gt;data)</code> to prevent memory leaks). The weights on the data set are normalized to sum to one.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2c76ad8792959b6605402a1d71a1b6c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_multivariate_gamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The multivariate generalization of the Gamma distribution. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_p(a)= \pi^{p(p-1)/4}\prod_{j=1}^p \Gamma\left[ a+(1-j)/2\right]. \]" src="form_85.png"/>
</p>
<p>Because <img class="formulaInl" alt="$\Gamma(x)$" src="form_86.png"/> is undefined for <img class="formulaInl" alt="$x\in\{0, -1, -2, ...\}$" src="form_87.png"/>, this function returns <code>NAN</code> when <img class="formulaInl" alt="$a+(1-j)/2$" src="form_88.png"/> takes on one of those values.</p>
<p>See also <a class="el" href="group__all__public.html#ga180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a>, which is more numerically stable in most cases. </p>

</div>
</div>
<a class="anchor" id="ga180b231acc3c64d07664ed2b1a8ad0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_multivariate_lngamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The log of the multivariate generalization of the Gamma; see also <a class="el" href="group__all__public.html#ga2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a>. </p>

</div>
</div>
<a class="anchor" id="gae32d4f48cff7788b617d40155703ae64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_name_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>add_me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a name to the <a class="el" href="structapop__name.html">apop_name</a> structure. Puts it at the end of the given list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>An existing, allocated <a class="el" href="structapop__name.html">apop_name</a> structure. </td></tr>
    <tr><td class="paramname">add_me</td><td>A string. If <code>NULL</code>, do nothing; return -1. </td></tr>
    <tr><td class="paramname">type</td><td>'r': add a row name<br />
 'c': add a matrix column name<br />
 't': add a text column name<br />
 'h': add a title (i.e., a header).<br />
 'v': add (or overwrite) the vector name<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of rows/cols/depvars after you have added the new one. But if <code>add_me</code> is <code>NULL</code>, return -1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29ff289eb3d86e1ba5b06e5064a3286f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* apop_name_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a name structure </p><dl class="section return"><dt>Returns</dt><dd>An allocated, empty name structure. In the very unlikely event that <code>malloc</code> fails, return <code>NULL</code>.</dd></dl>
<p>Because <a class="el" href="group__all__public.html#gac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> uses this to set up its output, you will rarely if ever need to call this function explicitly. You may want to use it if wrapping a <code>gsl_matrix</code> into an <a class="el" href="gentle.html#apop_data">apop_data</a> set. For example, to put a title on a vector:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *d = &amp;(apop_data){.vector=your_vector, .names=apop_name_alloc()};</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_name_add(d-&gt;names, &quot;A column of numbers&quot;, &#39;v&#39;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_data_print(d);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;apop_name_free(d-&gt;names); //but d itself is auto-allocated; no need to free it.</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad865208febeeb8cfce2f1d90e13db07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* apop_name_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <a class="el" href="structapop__name.html">apop_name</a> structure to another. That is, all data is duplicated.</p>
<p>Used internally by <a class="el" href="group__all__public.html#gadd67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>, but sometimes useful by itself. For example, say that we have an <a class="el" href="gentle.html#apop_data">apop_data</a> struct named <code>d</code> and a gsl_matrix of the same dimensions named <code>m</code>; we could give <code>m</code> the labels from <code>d</code> for printing: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *wrapped = &amp;(apop_data){.matrix=m, .names=apop_name_copy(d)};</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_print(wrapped);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_name_free(wrapped-&gt;names); //wrapped itself is auto-allocated; do not free.</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structapop__name.html">apop_name</a> struct with copies of all input names. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb1398925a93b7c2c502af8fb2abc49e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_name_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the position of an element in a list of names.</p>
<p>The function uses POSIX's <code>strcasecmp</code>, and so does case-insensitive search the way that function does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="structapop__name.html">apop_name</a> object to search. </td></tr>
    <tr><td class="paramname">name</td><td>the name you seek; see above. </td></tr>
    <tr><td class="paramname">type</td><td><code>'c'</code> (=column), <code>'r'</code> (=row), or <code>'t'</code> (=text). Default is <code>'c'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of <code>findme</code>. If <code>'c'</code>, then this may be -1, meaning the vector name. If not found, returns -2. On error, e.g. <code>name==NULL</code>, returns -2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62a9c548fc646f28518bb1edb84dafc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_name_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>free_me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the memory used by an <a class="el" href="structapop__name.html">apop_name</a> structure. </p>

</div>
</div>
<a class="anchor" id="gaf7220e4b2fe43c56593af0ceb2c7001a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_name_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the given list of names to stdout. Useful for debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The <a class="el" href="structapop__name.html">apop_name</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4fd369dba75ec4782400cf7378e56ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_name_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>nadd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>typeadd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append one list of names to another.</p>
<p>If the first list is empty, then this is a copy function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>The first set of names (no default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">nadd</td><td>The second set of names, which will be appended after the first. (no default. If <code>NULL</code>, a no-op.) </td></tr>
    <tr><td class="paramname">type1</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, text, or vector. If 'v', then ignore <code>typeadd</code> and just overwrite the target vector name with the source name. (default: 'r') </td></tr>
    <tr><td class="paramname">typeadd</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then overwrite the target with the source vector name. (default: type1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b6ecb8702153658c29369dc2e7cfba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_numerical_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper around the GSL's one-dimensional <code>gsl_deriv_central</code> to find a numeric differential for each dimension of the input <a class="el" href="structapop__model.html">apop_model</a>'s log likelihood (or <code>p</code> if <code>log_likelihood</code> is <code>NULL</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set to use for all evaluations. </td></tr>
    <tr><td class="paramname">model</td><td>The <a class="el" href="structapop__model.html">apop_model</a>, expressing the function whose derivative is sought. The gradient is taken via small changes along the model parameters. </td></tr>
    <tr><td class="paramname">delta</td><td>The size of the differential. (default: 1e-3, but see below)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_vector *gradient = apop_numerical_gradient(data, your_parametrized_model);</div>
</div><!-- fragment --><ul>
<li>If you do not set delta as an input, I first look for an <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group attached to the input model, and check that for a <code>delta</code> element. If that is also missing, use the default of 1e-3. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2510c7df8ccd834732ee208005738b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the probability of a data/parametrized model pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data </td></tr>
    <tr><td class="paramname">m</td><td>The parametrized model, which must have either a <code>log_likelihood</code> or a <code>p</code> method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ae576fb823e38f7b6f2ce1892e4b014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_paired_t_test </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Answers the question: with what confidence can I say that the mean difference between the two columns is zero?</p>
<p>If <code>apop_opts.verbose &gt;=2</code>, then display some information, like the mean/var/count for both vectors and the t statistic, to stderr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A column of data </td></tr>
    <tr><td class="paramname">b</td><td>A matched column of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the following elements: <code>mean left - right</code>: the difference in means; if positive, first vector has larger mean, and one-tailed test is testing <img class="formulaInl" alt="$L > R$" src="form_89.png"/>, else reverse if negative.<br />
 <code>t statistic</code>: used for the test<br />
 <code>df</code>: degrees of freedom<br />
 <code>p value, 1 tail</code>: the p-value for a one-tailed test that one vector mean is greater than the other.<br />
 <code>confidence, 1 tail</code>: 1- p value.<br />
 <code>p value, 2 tail</code>: the p-value for the two-tailed test that left mean = right mean.<br />
 <code>confidence, 2 tail</code>: 1-p value</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga65c94b79fe91308dc97829741acc9322">apop_t_test</a> for an example, and for when the element-by-element difference between the vectors has no sensible interpretation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92355da54ab91a8dee22192ae68a37d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_parameter_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a model describing the distribution of the given parameter estimates.</p>
<p>For many models, the parameter estimates are well-known, such as the <img class="formulaInl" alt="$t$" src="form_43.png"/>-distribution of the parameters for OLS.</p>
<p>For models where the distribution of <img class="formulaInl" alt="$\hat{p}$" src="form_44.png"/> is not known, if you give me data, I will return an <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> or <a class="el" href="group__models.html#ga3a4389e6e2a1a2ea606f89d55ec558d3">apop_multivariate_normal</a> model, using the parameter estimates as mean and <a class="el" href="group__all__public.html#ga4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a> for the variances.</p>
<p>If you don't give me data, then I will assume that this is a stochastic model where re-running the model will produce different parameter estimates each time. In this case, I will run the model 1e4 times and return a <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model with the resulting parameter distributions.</p>
<p>Before calling this, I expect that you have already run <a class="el" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> to produce <img class="formulaInl" alt="$\hat{p}$" src="form_44.png"/>.</p>
<p>The <a class="el" href="structapop__pm__settings.html">apop_pm_settings</a> structure dictates details of how the model is generated. For example, if you want only the distribution of the third parameter, and you know the distribution will be a PMF generated via random draws, then set settings and call the model via: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_model_group_add(your_model, apop_pm, .index =3, .draws=3e5);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_model *dist = apop_parameter_model(your_data, your_model);</div>
</div><!-- fragment --><p>Some useful parts of apop_pm_settings: </p><ul>
<li><code>index</code> gives the position of the parameter (in <a class="el" href="group__all__public.html#ga90feb5dd661cfe0f0b53a85295b8b56e">apop_data_pack</a> order) in which you are interested. Thus, if this is zero or more, then you will get a univariate output distribution describing a single parameter. If <code>index == -1</code>, then I will give you the multivariate distribution across all parameters. The default is zero (i.e. the univariate distribution of the zeroth parameter). </li>
<li><code>draws</code> If there is no closed-form solution and bootstrap is inappropriate, then the last resort is a large numbr of random draws of the model, summarized into a PMF. Default: 1,000 draws. </li>
<li><code>rng</code> If the method requires random draws, then use this. If you provide <code>NULL</code> and one is needed, I provide one for you via <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>.</li>
</ul>
<p>The default is via resampling as above, but special-case calculations for certain models are held in a vtable; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. The typedef new functions must conform to and the hash used for lookups are:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;typedef apop_model* (*apop_parameter_model_type)(apop_data *, apop_model *);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define apop_parameter_model_hash(m1) ((size_t)((m1).log_likelihood ? (m1).log_likelihood : (m1).p)*33 + (m1).estimate ? (size_t)(m1).estimate: 27)</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga867f0b8df261866bb18e9040871c51f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_predict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A prediction supplies E(a missing value | original data, already-estimated parameters, and other supplied data elements ).</p>
<p>For a regression, one would first estimate the parameters of the model, then supply a row of predictors <b>X</b>. The value of the dependent variable <img class="formulaInl" alt="$y$" src="form_37.png"/> is unknown, so the system would predict that value.</p>
<p>For a univariate model (i.e. a model in one-dimensional data space), there is only one variable to omit and fill in, so the prediction problem reduces to the expected value: E(a missing value | original data, already-estimated parameters). [In some models, this may not be the expected value, but is a best value for the missing item using some other meaning of `best'.]</p>
<p>In other cases, prediction is the missing data problem: for three-dimensional data, you may supply the input (34, <code>NaN</code>, 12), and the parameterized model provides the most likely value of the middle parameter given the parameters and known data.</p>
<ul>
<li>If you give me a <code>NULL</code> data set, I will assume you want all values filled in, for most models with the expected value.</li>
</ul>
<ul>
<li>If you give me data with <code>NaNs</code>, I will take those as the points to be predicted given the provided data.</li>
</ul>
<p>If the model has no <code>predict</code> method, the default is to use the <a class="el" href="group__all__public.html#ga2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> function to do the work. That function does a maximum-likelihood search for the best parameters.</p>
<dl class="section return"><dt>Returns</dt><dd>If you gave me a non-<code>NULL</code> data set, I will return that, with the <code>NaNs</code> filled in. If <code>NULL</code> input, I will allocate an <a class="el" href="gentle.html#apop_data">apop_data</a> set and fill it with the expected values.</dd></dl>
<p>There may be a second page (i.e., a <a class="el" href="gentle.html#apop_data">apop_data</a> set attached to the <code>-&gt;more</code> pointer of the main) listing confidence and standard error information. See your specific model documentation for details.</p>
<ul>
<li>Special-case calculations for certain models are held in a vtable; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. The typedef new functions must conform to and the hash used for lookups are:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;typedef apop_data * (*apop_predict_type)(apop_data *d, apop_model *params);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define apop_predict_hash(m1) ((size_t)((m1).log_likelihood ? (m1).log_likelihood : (m1).p)*33 + (m1).estimate ? (size_t)(m1).estimate: 27)</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga373ccc4cb87b162d62d07a2685ccd8ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_prep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and initialize the <code>parameters</code>, <code>info</code>, and other requisite parts of a <a class="el" href="structapop__model.html">apop_model</a>.</p>
<p>Some models have associated prep routines that also attach settings groups to the model, and set up additional special-case functions in vtables.</p>
<ul>
<li>The input model is modified in place. </li>
<li>If called repeatedly, subsequent calls to <a class="el" href="group__all__public.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> are no-ops. Thus, a model can not be re-prepped using a new data set or other conditions. </li>
<li>The default prep is to simply call <a class="el" href="group__all__public.html#gaa86381a72949fd3ffafefa87e3f51a4f">apop_model_clear</a>. If the input <a class="el" href="structapop__model.html">apop_model</a> has a prep method, then that gets called instead. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga4748bf59f5441cd27e5b93056c7ec1c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_prep_output </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>output_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE **&#160;</td>
          <td class="paramname"><em>output_pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you're reading this, it is probably because you were referred by another function that uses this internally. You should never call this function directly, but do read this documentation.</p>
<p>There are four settings that affect how output happens, which can be set when you call the function that sent you to this documentation, e.g:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data_print(your_data, .output_type =&#39;f&#39;, .output_append = &#39;w&#39;);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_name</td><td>The name of the output file, if any. For a database, the table to write. </td></tr>
    <tr><td class="paramname">output_pipe</td><td>If you have already opened a file and have a <code>FILE*</code> on hand, use this instead of giving the file name. </td></tr>
    <tr><td class="paramname">output_type</td><td><code>'p'</code> = pipe, <code>'f'=</code> file, <code>'d'</code> = database </td></tr>
    <tr><td class="paramname">output_append</td><td><code>'a'</code> = append (default), <code>'w'</code> = write over.</td></tr>
  </table>
  </dd>
</dl>
<p>At the end, <code>output_name</code>, <code>output_pipe</code>, and <code>output_type</code> are all set. Notably, the local <code>output_pipe</code> will have the correct location for the calling function to <code>fprintf</code> to.</p>
<ul>
<li>See legi for more discussion.</li>
</ul>
<ul>
<li>The default is output to stdout. For example, <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data_print(your_data);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;//is equivalent to</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_data_print(your_data, .output_type=&#39;p&#39;, .output_pipe=stdout);</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Tip: if writing to the database, you can get a major speed boost by wrapping the call in a begin/commit wrapper:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_query(&quot;begin;&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_print(your_data, .output_name=&quot;dbtab&quot;, .output_type=&#39;d&#39;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_query(&quot;commit;&quot;);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga02cf6319da103f9bfe55dfbbc7675536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a query to the database that returns no data.</p>
<ul>
<li>As with functions like the <code>apop_query_to_data</code>, the query can include printf-style format specifiers, such as <code>apop_query("create table %s(id, name,
age);", tablename)</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gade862993166c6482f53562fb77721db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_query_to_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the database and dumps the result into an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If no rows are returned, <code>NULL</code>; else an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the data in place. Most data will be in the <code>matrix</code> element of the output. Column names are appropriately placed. If <a class="el" href="structapop__opts__type.html">apop_opts.db_name_column</a> matches one of the fields in your query's output (default: <code>row_names</code>), then that column will be used for row names (and therefore will not appear in the <code>matrix</code>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='q'</td><td>Query error. A valid query that returns no rows is not an error; in that case, you get <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The query can include printf-style format specifiers, such as <code>apop_query_to_data("select age from %s where id=%i;", tablename, id_number)</code>. </li>
<li>Blanks in the database (i.e., <code> NULL</code>s) and elements that match <a class="el" href="structapop__opts__type.html">apop_opts.nan_string</a> are filled with <code>NAN</code>s in the matrix. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1ad75f9dfba696a3741e28896ed5b75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_query_to_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the database, and dumps the result into a single double-precision floating point number.</p>
<ul>
<li>This calls <a class="el" href="group__all__public.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> and returns the (0,0)th element of the returned matrix. Thus, if your query returns multiple lines, you will get no warning, and the function will return the first in the list (which is not always well-defined; maybe use an <code>order by</code> clause in your query if you expect multiple lines).</li>
</ul>
<ul>
<li>If <code>apop_opts.db_name_column</code> is set, then I'll ignore that column. It gets put into the names of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then thrown away when I look at only the <code>gsl_matrix</code> element of that set. </li>
<li>If the query produces a blank table, returns <code>NAN</code>, and if <code>apop_opts.verbose&gt;=2</code>, prints an error. </li>
<li>The query can include printf-style format specifiers, such as <code>apop_query_to_float("select age from %s where id=%i;", tablename, id_number)</code>. </li>
<li>If the query produces an error, returns <code>NAN</code>, and if <code>apop_opts.verbose&gt;=0</code>, prints an error. If you need to distinguish between blank tables, NaNs in the data, and query errors, use <a class="el" href="group__all__public.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>double</code>, actually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f06db34e05b5afb63112f83ad2317b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_query_to_mixed_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query data to an <code><a class="el" href="structapop__data.html">apop_data</a></code> set, but a mix of names, vectors, matrix elements, and text.</p>
<p>If you are querying to a matrix and maybe a name, use <code>apop_query_to_data</code> (and set <a class="el" href="structapop__opts__type.html">apop_opts.db_name_column</a> if desired). If querying only text, use <a class="el" href="group__all__public.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>. But if your data is a mix of text and numbers, use this.</p>
<p>The first argument is a character string consisting of the letters <code>nvmtw</code>, one for each column of the SQL output, indicating whether the column is a name, vector, matrix column, text column, or weight vector. You can have only one <code>n</code>, one <code>v</code>, and one <code>w</code>.</p>
<p>If the query produces more columns than there are elements in the column specification, then the remainder are dumped into the text section. If there are fewer columns produced than given in the spec, the additional elements will be allocated but not filled (i.e., they are uninitialized and will have garbage).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typelist</td><td>A string consisting of the letters <code>nvmtw</code>. For example, if your query columns should go into a text column, the vector, the weights, and two matrix columns, this would be "tvwmm". </td></tr>
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Dimension error. Your count of matrix parts didn't match what the query returned. </td></tr>
    <tr><td class="paramname">out-&gt;error=='q'</td><td>Query error. A valid query that returns no rows is not an error; in that case, you get <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="structapop__opts__type.html">apop_opts.db_name_column</a> is ignored. Use the <code>'n'</code> character to indicate the output column with row names. </li>
<li>As with the other <code>apop_query_to_</code>... functions, the query can include printf-style format specifiers, such as <code>apop_query_to_mixed_data("tv", "select name, age from </code></li>
</ul>

</div>
</div>
<a class="anchor" id="ga2fbd580cd71f481ae04ee03b5cf64ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_query_to_text </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the results of a query into an array of strings.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> structure with the <code>text</code> element filled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='q'</td><td>The database engine was unable to run the query (e.g., invalid SQL syntax). Again, a valid query that returns zero rows is not an error, and <code>NULL</code> is returned. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Database error.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If <code>apop_opts.db_name_column</code> matches a column of the output table, then that column is used for row names, and therefore will not be included in the <code>text</code>. </li>
<li><code>query_output-&gt;text</code> is always a 2-D array of strings, even if the query returns a single column. In that case, use <code>returned_tab-&gt;text[i][0]</code> (or equivalently, <code>*returned_tab-&gt;text[i]</code>) to refer to row <code>i</code>. </li>
<li>If an element in the database is <code>NULL</code>, the corresponding cell in the output table will be filled with the text given by <code>apop_opts.nan_string</code>. The default is <code>"NaN"</code>, but you can set <code>apop_opts.nan_string = "whatever you like"</code> to change the text to whatever you like. </li>
<li>Returns <code>NULL</code> if your query is valid but returns zero rows. </li>
<li>The query can include printf-style format specifiers, such as <code>apop_query_to_text("select name from %s where id=%i;", tablename, id_number)</code>.</li>
</ul>
<p>For example, the following function will list the tables in an SQLite database (much like you could do from the command line using <code>sqlite3 dbname.db ".table"</code>).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_table_list(<span class="keywordtype">char</span> *db_file){</div>
<div class="line">    <a class="code" href="group__all__public.html#ga4d81aff912df2982697038c51795e358">apop_db_open</a>(db_file);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *tab_list= <a class="code" href="group__all__public.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>(<span class="stringliteral">&quot;select name &quot;</span></div>
<div class="line">                    <span class="stringliteral">&quot;from sqlite_master where type==&#39;table&#39;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; tab_list-&gt;textsize[0]; i++)</div>
<div class="line">        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, tab_list-&gt;text[i][0]);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv){</div>
<div class="line">    <span class="keywordflow">if</span> (argc == 1){</div>
<div class="line">        printf(<span class="stringliteral">&quot;Give me a database name, and I will print out &quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;the list of tables contained therein.\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 0; </div>
<div class="line">    }</div>
<div class="line">    print_table_list(argv[1]);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga830703db838855b8abd636069c7145de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_query_to_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the database and dumps the first column of the result into a <code>gsl_vector</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>gsl_vector</code> holding the first column of the returned matrix. Thus, if your query returns multiple lines, you will get no warning, and the function will return the first in the list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='q'</td><td>Query error. A valid query that returns no rows is not an error; in that case, you get <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Uses <a class="el" href="group__all__public.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> internally, then throws away all but the first column of the matrix. </li>
<li>If <code>apop_opts.db_name_column</code> is set, then I'll ignore that column. It gets put into the names of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then thrown away when I look at only the <code>gsl_matrix</code> part of that set. </li>
<li>If the query returns zero rows of data or no columns, the function returns <code>NULL</code>. </li>
<li>The query can include printf-style format specifiers, such as <code>apop_query_to_vector("select age from %s where id=%i;", tablename, id_number)</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1a3980c42be0495f001a5b296097682f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_rake </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>margin_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const *&#160;</td>
          <td class="paramname"><em>contrasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contrast_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>structural_zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fit a log-linear model via iterative proportional fitting, aka raking.</p>
<p>Raking has many uses. The <a href="http://modelingwithdata.org/arch/00000138.htm">Modeling with Data blog</a> presents a series of discussions of uses of raking, including some worked examples.</p>
<p>Or see Wikipedia for an overview of Log linear models, aka <a href="http://en.wikipedia.org/wiki/Poisson_regression">Poisson regressions</a>. One approach toward log-linear modeling is a regression form; let there be four categories, A, B, C, and D, from which we can produce a model positing, for example, that cell count is a function of a form like <img class="formulaInl" alt="$g_1(A) + g_2(BC) + g_3(CD)$" src="form_45.png"/>. In this case, we would assign a separate coefficient to every possible value of A, every possible value of (B, C), and every value of (C, D). Raking is the technique that searches for that large set of parameters.</p>
<p>The combinations of categories that are considered to be relevant are called <em>contrasts</em>, after ANOVA terminology of the 1940s.</p>
<p>The other constraint on the search are structural zeros, which are values that you know can never be non-zero, due to field-specific facts about the variables. For example, U.S. Social Security payments are available only to those age 65 or older, so "age &lt;65 and
gets_soc_security=1" is a structural zero.</p>
<p>Because there is one parameter for every combination, there may be millions of parameters to estimate, so the search to find the most likely value requires some attention to technique. For over half a century, the consensus method for searching has been raking, which iteratively draws each category closer to the mean in a somewhat simple manner (this was first developed circa 1940 and had to be feasible by hand), but which is guaranteed to eventually arrive at the maximum likelihood estimate for all cells.</p>
<p>Another complication is that the table is invariably sparse. One can easily construct tables with millions of cells, but the corresponding data set may have only a few thousand observations.</p>
<p>This function uses the database to resolve the sparseness problem. It constructs a query requesting all combinations of categories the could possibly be non-zero after raking, given all of the above constraints. Then, raking is done using only that subset. This means that the work is done on a number of cells proportional to the number of data points, not to the full cross of all categories. Set <code>apop_opts.verbose</code> to 2 or greater to show the query on <code>stderr</code>.</p>
<ul>
<li>One could use raking to generate `fully synthetic' data: start with observation-level data in a margin table. Begin the raking with a starting data set of all-ones. Then rake until the all-ones set transforms into something that conforms to the margins and (if any) structural zeros. You now have a data set which matches the marginal totals but does not use any other information from the observation-level data. If you do not specify an <code>.init_table</code>, then an all-ones default table will be used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">margin_table</td><td>The name of the table in the database to use for calculating the margins. The table should have one observation per row. (No default)</td></tr>
    <tr><td class="paramname">var_list</td><td>The full list of variables to search. A list of strings, e.g., <code>(char *[]){"var1", "var2", ..., "var15"}</code></td></tr>
    <tr><td class="paramname">var_ct</td><td>The count of the full list of variables to search.</td></tr>
    <tr><td class="paramname">contrasts</td><td>The contrasts describing your model. Like the <code>var_list</code> input, a list of strings like <code>(char *[]){"var1", "var7", "var13"}</code> contrast is a pipe-delimited list of variable names. (No default)</td></tr>
    <tr><td class="paramname">contrast_ct</td><td>The number of contrasts in the list of contrasts. (No default)</td></tr>
    <tr><td class="paramname">structural_zeros</td><td>a SQL clause indicating combinations that can never take a nonzero value. This will go into a <code>where</code> clause, so anything you could put there is OK, e.g. "age &lt;65 and gets_soc_security=1 or age &lt;15 and married=1". Your margin data is not checked for structural zeros. (default: no structural zeros)</td></tr>
    <tr><td class="paramname">max_iterations</td><td>Number of rounds of raking at which the algorithm halts. (default: 1000)</td></tr>
    <tr><td class="paramname">tolerance</td><td>I calculate the change for each cell from round to round; if the largest cell change is smaller than this, I stop. (default: 1e-5)</td></tr>
    <tr><td class="paramname">count_col</td><td>This column gives the count of how many observations are represented by each row. If <code>NULL</code>, ech row represents one person. (default: <code>NULL</code>)</td></tr>
    <tr><td class="paramname">init_table</td><td>The default is to initially set all table elements to one and then rake from there. This is effectively the `fully synthetic' approach, which uses only the information in the margins and derives the data set closest to the all-ones data set that is consistent with the margins. Care is taken to maintan sparsity in this case. If you specify an <code>init_table</code>, then I will get the initial cell counts from it. (default: the fully-synthetic approach, using a starting point of an all-ones grid.)</td></tr>
    <tr><td class="paramname">init_count_col</td><td>The column in <code>init_table</code> with the cell counts.</td></tr>
    <tr><td class="paramname">nudge</td><td>There is a common hack of adding a small value to every zero entry, because a zero entry will always scale to zero, while a small value could eventually scale to anything. Recall that this function works on sparse sets, so I first filter out those cells that could possibly have a nonzero value given the observations, then I add <code>nudge</code> to any zero cells within that subset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set where every row is a single combination of variable values and the <code>weights</code> vector gives the most likely value for each cell.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='i'</td><td>Input was somehow wrong. </td></tr>
    <tr><td class="paramname">out-&gt;error='c'</td><td>Raking did not converge, reached max. iteration count.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Set <code>apop_opts.verbose=3</code> to see the intermediate tables at the end of each round of raking. </li>
<li>If you want all cells to have nonzero value, then you can do that via pre-processing: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_query(&quot;update data_table set count_col = 1e-3 where count_col = 0&quot;);</div>
</div><!-- fragment --> </li>
<li>This function is thread-safe. To make this happen, temp database tables are named using a number built with <code>omp_get_thread_num</code>. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaa9ec5e7ed223c09bec044ced54f24fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_regex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> **&#160;</td>
          <td class="paramname"><em>substrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>use_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract subsets from a string via regular expressions.</p>
<p>This function takes a regular expression and repeatedly applies it to an input string. It returns the count of matches, and optionally returns the matches themselves organized into the <code>text</code> grid of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<ul>
<li>There are three common flavors of regular expression: Basic, Extended, and Perl-compatible (BRE, ERE, PCRE). I use EREs, as per the specs of your C library, which should match POSIX's ERE specification.</li>
</ul>
<p>For example, "p.val" will match "P value", "p.value", "p values" (and even "tempeval", so be careful).</p>
<p>If you give a non-<code>NULL</code> address in which to place a table of paren-delimited substrings, I'll return them as a row in the text element of the returned <a class="el" href="gentle.html#apop_data">apop_data</a> set. I'll return <em>all</em> the matches, filling the first row with substrings from the first application of your regex, then filling the next row with another set of matches (if any), and so on to the end of the string. Useful when parsing a list of items, for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to search (no default) </td></tr>
    <tr><td class="paramname">regex</td><td>The regular expression (no default) </td></tr>
    <tr><td class="paramname">substrings</td><td>Parens in the regex indicate that I should return matching substrings. Give me the <em>address</em> of an <a class="el" href="gentle.html#apop_data">apop_data</a>* set, and I will allocate and fill the text portion with matches. Default= <code>NULL</code>, meaning do not return substrings (even if parens exist in the regex). If no match, return an empty <a class="el" href="gentle.html#apop_data">apop_data</a> set, so <code>output-&gt;textsize[0]==0</code>. </td></tr>
    <tr><td class="paramname">use_case</td><td>Should I be case sensitive, <code>'y'</code> or <code>'n'</code>? (default = <code>'n'</code>, which is not the POSIX default.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of matches found. 0 == no match. <code>substrings</code> may be allocated and filled if needed.</dd></dl>
<ul>
<li>If <code>apop_opts.stop_on_warning='n'</code> returns -1 on error (e.g., regex <code>NULL</code> or didn't compile). </li>
<li>If <code>strings==NULL</code>, I return 0&mdash;no match&mdash;and if <code>substrings</code> is provided, set it to <code>NULL</code>.</li>
</ul>
<ul>
<li>Here is the test function. Notice that the substring-pulling function call passes <code>&amp;subs</code>, not plain <code>subs</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">char</span> string1[] = <span class="stringliteral">&quot;Hello. I am a string.&quot;</span>;</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;hell&quot;</span>));</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *subs;</div>
<div class="line">    <a class="code" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;(e).*I.*(xxx)*(am)&quot;</span>, .substrings = &amp;subs);</div>
<div class="line">    <span class="comment">//apop_data_show(subs);</span></div>
<div class="line">    assert(!strcmp(subs-&gt;text[0][0], <span class="stringliteral">&quot;e&quot;</span>));</div>
<div class="line">    assert(!strlen(subs-&gt;text[0][1])); <span class="comment">//The non-match to (xx)* has a zero-length blank</span></div>
<div class="line">    assert(!strcmp(subs-&gt;text[0][2], <span class="stringliteral">&quot;am&quot;</span>));</div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Split a comma-delimited list, throwing out white space.</span></div>
<div class="line">    <span class="comment">//Notice that the regex includes only one instance of a non-comma blob </span></div>
<div class="line">    <span class="comment">//ending in a non-space followed by a comma, but the function keeps </span></div>
<div class="line">    <span class="comment">//applying it until the end of string.</span></div>
<div class="line">    <span class="keywordtype">char</span> string2[] = <span class="stringliteral">&quot; one, two , three ,four&quot;</span>;</div>
<div class="line">    <a class="code" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string2, <span class="stringliteral">&quot; *([^,]*[^ ]) *(,|$) *&quot;</span>, &amp;subs);</div>
<div class="line">    assert(!strcmp(*subs-&gt;text[0], <span class="stringliteral">&quot;one&quot;</span>));</div>
<div class="line">    assert(!strcmp(*subs-&gt;text[1], <span class="stringliteral">&quot;two&quot;</span>));</div>
<div class="line">    assert(!strcmp(*subs-&gt;text[2], <span class="stringliteral">&quot;three&quot;</span>));</div>
<div class="line">    assert(!strcmp(*subs-&gt;text[3], <span class="stringliteral">&quot;four&quot;</span>));</div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Get a parenthetical. For EREs, \( \) match plain parens in the text.</span></div>
<div class="line">    <span class="keywordtype">char</span> string3[] = <span class="stringliteral">&quot; one (but secretly, two)&quot;</span>;</div>
<div class="line">    <a class="code" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string3, <span class="stringliteral">&quot;(\\([^)]*\\))&quot;</span>, &amp;subs);</div>
<div class="line">    assert(!strcmp(*subs-&gt;text[0], <span class="stringliteral">&quot;(but secretly, two)&quot;</span>));</div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//NULL input string ==&gt; no-op.</span></div>
<div class="line">    <span class="keywordtype">int</span> match_count = <a class="code" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(NULL, <span class="stringliteral">&quot; *([^,]*[^ ]) *(,|$) *&quot;</span>, &amp;subs);</div>
<div class="line">    assert(!match_count);</div>
<div class="line">    assert(!subs);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Each set of matches will be one row of the output data. E.g., given the regex <code>([A-Za-z])([0-9])</code>, the column zero of <code>outdata</code> will hold letters, and column one will hold numbers. Use <a class="el" href="group__all__public.html#ga82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> to reverse this so that the letters are in <code>outdata-&gt;text[0]</code> and numbers in <code>outdata-&gt;text[1]</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="gada044cf02135422a9f9292b6054c86dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_rng* apop_rng_alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a <code>gsl_rng</code>.</p>
<p>Uses the Tausworth routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed. No need to get funny with it: 0, 1, and 2 will produce wholly different streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RNG ready for your use.</dd></dl>
<ul>
<li>If you are confident that your code is debugged and would like a new stream of values every time your program runs (provided your runs are more than a second apart), seed with the time:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.rng_seed = time(NULL);</div>
<div class="line">    <a class="code" href="group__all__public.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(</div>
<div class="line">            <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(</div>
<div class="line">                <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1), </div>
<div class="line">                .count=10, </div>
<div class="line">            )</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaaf0d5d65f514d9894a4ca5b0e8755873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_rng_GHgB3 </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RNG from a Generalized Hypergeometric type B3.</p>
<p>Devroye uses this as the base for many of his distribution-generators, including the Waring.</p>
<ul>
<li>If one of the inputs is &lt;=0, error; return NaN and print a warning. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga228b013bc80f308900882312cab93eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_score </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the vector of first derivatives (aka the gradient) of the log likelihood of a data/parametrized model pair.</p>
<p>On input, the model <code>m</code> must already be sufficiently prepped that the log likelihood can be evaluated; see <a class="el" href="modeldetails.html#psubsection">p, log_likelihood</a> for details.</p>
<p>On output, the <code>gsl_vector</code> input to the function will be filled with the gradients (or <code>NaN</code>s on errors). If the model parameters have a more complex shape than a simple vector, then the vector will be in <code>apop_data_pack</code> order; use <code>apop_data_unpack</code> to reformat to the preferred shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set at which the score is being evaluated. </td></tr>
    <tr><td class="paramname">out</td><td>The score to be returned. I expect you to have allocated this already. </td></tr>
    <tr><td class="paramname">m</td><td>The parametrized model, which must have either a <code>log_likelihood</code> or a <code>p</code> method.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The default is to use <a class="el" href="group__all__public.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a>, but special-case calculations for certain models are held in a vtable; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. The typedef new functions must conform to and the hash used for lookups are:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;typedef void (*apop_score_type)(apop_data *d, gsl_vector *gradient, apop_model *m);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define apop_score_hash(m1) ((size_t)((m1).log_likelihood ? (m1).log_likelihood : (m1).p))</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0dc44b7dfc3c125d19c1db3bef3a80a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_settings_copy_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>outm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>inm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>copyme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a settings group with the given name from the second model to the first (i.e., the arguments are in memcpy order).</p>
<p>You probably won't need this often&mdash;just use <a class="el" href="group__all__public.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outm</td><td>The model that will receive a copy of the settings group. </td></tr>
    <tr><td class="paramname">inm</td><td>The model that will provide the original. </td></tr>
    <tr><td class="paramname">copyme</td><td>The string naming the group. For example, for an <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group, this would be <code>"apop_mcmc"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">outm-&gt;error=='s'</td><td>Error copying settings group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga153362f8a4c7f64e0c8dad893edadea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_system </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <code>system()</code>, but with <code>printf</code>-style arguments. E.g.,</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char filenames[] = &quot;apop_asst.c apop_asst.o&quot;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_system(&quot;ls -l %s&quot;, filenames);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The return value of the <code>system()</code> call. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65c94b79fe91308dc97829741acc9322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_t_test </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Answers the question: with what confidence can I say that the means of these two columns of data are different?</p>
<p>If <code>apop_opts.verbose</code> is &gt;=1, then display some information to stdout, like the mean/var/count for both vectors and the t statistic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one column of data </td></tr>
    <tr><td class="paramname">b</td><td>another column of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the following elements: <code>mean left - right</code>: the difference in means; if positive, first vector has larger mean, and one-tailed test is testing <img class="formulaInl" alt="$L > R$" src="form_89.png"/>, else reverse if negative.<br />
 <code>t statistic</code>: used for the test<br />
 <code>df</code>: degrees of freedom<br />
 <code>p value, 1 tail</code>: the p-value for a one-tailed test that one vector mean is greater than the other.<br />
 <code>confidence, 1 tail</code>: 1- p value.<br />
 <code>p value, 2 tail</code>: the p-value for the two-tailed test that left mean = right mean.<br />
 <code>confidence, 2 tail</code>: 1-p value</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_vector *L = apop_query_to_vector(&quot;select * from data where sex=&#39;M&#39;&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;gsl_vector *R = apop_query_to_vector(&quot;select * from data where sex=&#39;F&#39;&quot;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_data *test_out = apop_t_test(L, R);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;printf(&quot;Reject the null hypothesis of no difference between M and F with %g%% confidence\n&quot;, apop_data_get(test_out, .rowname=&quot;confidence, 2 tail&quot;));</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga0ae576fb823e38f7b6f2ce1892e4b014">apop_paired_t_test</a>, which answers the question: with what confidence can I say that the mean difference between the two columns is zero? </dd></dl>

</div>
</div>
<a class="anchor" id="ga01d501ca84ade92bc72fd4f67a617f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_table_exists </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for the existence of a table, and maybe delete it.</p>
<p>Recreating a table which already exists can cause errors, so it is good practice to check for existence first. Also, this is the stylish way to delete a table, since just calling <code>"drop table"</code> will give you an error if the table doesn't exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the table name (no default) </td></tr>
    <tr><td class="paramname">remove</td><td>'d' ==&gt;delete table so it can be recreated in main.<br />
 'n' ==&gt;no action. Return result so program can continue. (default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = table does not exist<br />
 1 = table was found, and if remove=='d', has been deleted -1 = processing error</dd></dl>
<ul>
<li>In the SQLite engine, this function considers table views to be tables. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga650d1ecf6f78c3bdb85c8fce71dfae05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_test </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a convenience function to do the lookup of a given statistic along a given distribution. You give me a statistic, its (hypothesized) distribution, and whether to use the upper tail, lower tail, or both. I will return the odds of a Type I error given the model&mdash;in statistician jargon, the <img class="formulaInl" alt="$p$" src="form_17.png"/>-value. [Type I error: odds of rejecting the null hypothesis when it is true.]</p>
<p>For example, </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_test(1.3);</div>
</div><!-- fragment --><p>will return the density of the standard Normal distribution that is more than 1.3 from zero. If this function returns a small value, we can be confident that the statistic is significant. Or, </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_test(1.3, &quot;t&quot;, 10, .tail=&#39;u&#39;);</div>
</div><!-- fragment --><p>will give the appropriate odds for an upper-tailed test using the <img class="formulaInl" alt="$t$" src="form_43.png"/>-distribution with 10 degrees of freedom (e.g., a <img class="formulaInl" alt="$t$" src="form_43.png"/>-test of the null hypothesis that the statistic is less than or equal to zero).</p>
<p>Several more distributions are supported; see below.</p>
<ul>
<li>For a two-tailed test (the default), this returns the density outside the range. I'll only do this for symmetric distributions. </li>
<li>For an upper-tail test ('u'), this returns the density above the cutoff </li>
<li>For a lower-tail test ('l'), this returns the density below the cutoff</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statistic</td><td>The scalar value to be tested. </td></tr>
    <tr><td class="paramname">distribution</td><td>The name of the distribution; see below. </td></tr>
    <tr><td class="paramname">p1</td><td>The first parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">p2</td><td>The second parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">tail</td><td>'u' = upper tail; 'l' = lower tail; anything else = two-tailed. (default = two-tailed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The odds of a Type I error given the model (the <img class="formulaInl" alt="$p$" src="form_17.png"/>-value).</dd></dl>
<p>Here are the distributions you can use and their parameters.</p>
<p><code>"normal"</code> or <code>"gaussian"</code> </p><ul>
<li>p1= <img class="formulaInl" alt="$\mu$" src="form_74.png"/>, p2= <img class="formulaInl" alt="$\sigma$" src="form_69.png"/> </li>
<li>default (0, 1)</li>
</ul>
<p><code>"lognormal"</code> </p><ul>
<li>p1= <img class="formulaInl" alt="$\mu$" src="form_74.png"/>, p2= <img class="formulaInl" alt="$\sigma$" src="form_69.png"/> </li>
<li>default (0, 1) </li>
<li>Remember, <img class="formulaInl" alt="$\mu$" src="form_74.png"/> and <img class="formulaInl" alt="$\sigma$" src="form_69.png"/> refer to the Normal one would get after exponentiation </li>
<li>One-tailed tests only</li>
</ul>
<p><code>"uniform"</code> </p><ul>
<li>p1=lower edge, p2=upper edge </li>
<li>default (0, 1) </li>
<li>two-tailed tests are run relative to the center, (p1+p2)/2.</li>
</ul>
<p><code>"t"</code> </p><ul>
<li>p1=df </li>
<li>no default</li>
</ul>
<p><code>"chi squared"</code>, <code>"chi"</code>, <code>"chisq"</code>: </p><ul>
<li>p1=df </li>
<li>no default </li>
<li>One-tailed tests only; default='u' ( <img class="formulaInl" alt="$p$" src="form_17.png"/>-value for typical cases)</li>
</ul>
<p><code>"f"</code> </p><ul>
<li>p1=df1, p2=df2 </li>
<li>no default </li>
<li>One-tailed tests only</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga12b92b7494f4e24d2f47244e3792d566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_test_anova_independence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a Chi-squared test on an ANOVA table, i.e., an NxN table with the null hypothesis that all cells are equally likely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The input data, which is a crosstab of various elements. They don't have to sum to one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="gentle.html#apop_data">apop_data</a> set including elements named <code>"chi squared statistic"</code>, <code>"df"</code>, and <code>"p value"</code>. Retrieve via, e.g., <code>apop_data_get(out, .rowname="p value")</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8627a1eebf904699e90e66adc8b4b021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_test_fisher_exact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>intab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the Fisher exact test on an input contingency table.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with two rows:<br />
 "probability of table": Probability of the observed table for fixed marginal totals. <br />
 "p value": Table p-value. The probability of a more extreme table, where `extreme' is in a probabilistic sense.</dd></dl>
<ul>
<li>If there are processing errors, these values will be NaN.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='p'</td><td>Processing error in the test.</td></tr>
  </table>
  </dd>
</dl>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">/* This test is thanks to Nick Eriksson, who sent it to me in the form of a bug report. */</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> * testdata = <a class="code" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((2, 3),</div>
<div class="line">                              30, 50, 45, </div>
<div class="line">                              34, 12, 17 );</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> * t2 = <a class="code" href="group__all__public.html#ga8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a>(testdata);</div>
<div class="line">    assert(fabs(<a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(t2,.rowname=<span class="stringliteral">&quot;p value&quot;</span>) - 0.0001761) &lt; 1e-6);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga98ccaa9de7cb16e60a435c56eaf3400d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_test_kolmogorov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the Kolmogorov-Smirnov test to determine whether two distributions are identical.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>A sorted PMF model. I.e., a model estimated via something like <code><a class="el" href="structapop__model.html">apop_model</a> *m1 = apop_estimate(apop_data_sort(input_data), apop_pmf);</code></td></tr>
    <tr><td class="paramname">m2</td><td>Another <a class="el" href="structapop__model.html">apop_model</a>. If it is a PMF, then I will use a two-sample test, which is different from the one-sample test used if this is not a PMF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set including the <img class="formulaInl" alt="$p$" src="form_17.png"/>-value from the Kolmogorov-Smirnov test that the two distributions are equal.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='m'</td><td>Model error: <code>m1</code> is not an <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>. I verify this by checking whether <code>m1-&gt;cdf == apop_pmf-&gt;cdf</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If you are using a <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model, the data set(s) must be sorted before you set up the model, as per the example below. See <a class="el" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a> and the discussion of CDFs in the <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> documentation. If you don't do this, the test will almost certainly reject the null hypothesis that <code>m1</code> and <code>m2</code> are identical. A future version of Apophenia may implement a mechanism to allow this function to test for sorted data, but it currently can't.</li>
</ul>
<p>Here is an example, which tests whether a set of draws from a Normal(0, 1) matches a sequence of Normal distributions with increasing mean.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"><span class="comment">//This program finds the p-value of a K-S test between</span></div>
<div class="line"><span class="comment">//500 draws from a N(0, 1) and a N(x, 1), where x grows from 0 to 1.</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structapop__model.html">apop_model</a> * model_to_pmfs(<a class="code" href="structapop__model.html">apop_model</a> *m1, <span class="keywordtype">int</span> size){</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *outd1 = <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(m1, size);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(<a class="code" href="group__all__public.html#gacefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(outd1), <a class="code" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef Testing</span></div>
<div class="line"><span class="preprocessor">#define cprintf(...) printf(__VA_ARGS__)</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define cprintf(...)</span></div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *n1 = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *pmf1 = model_to_pmfs(n1, 5e2);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *ktest;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//first, there should be zero divergence between a PMF and itself:</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *pmf2 = <a class="code" href="group__all__public.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(pmf1);</div>
<div class="line">    ktest = <a class="code" href="group__all__public.html#ga98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a>(pmf1, pmf2);</div>
<div class="line">    <span class="keywordtype">double</span> pval = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(ktest, .rowname=<span class="stringliteral">&quot;p value, 2 tail&quot;</span>);</div>
<div class="line">    assert(pval &gt; .999);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//as the mean m drifts, the pval for a comparison</span></div>
<div class="line">    <span class="comment">//between a N(0, 1) and N(m, 1) gets smaller.</span></div>
<div class="line">    cprintf(<span class="stringliteral">&quot;mean\tpval\n&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> prior_pval = 18;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">double</span> i=0; i&lt;= .6; i+=0.2){</div>
<div class="line">        <a class="code" href="structapop__model.html">apop_model</a> *n11 = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, i, 1);</div>
<div class="line">        ktest = <a class="code" href="group__all__public.html#ga98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a>(pmf1, n11);</div>
<div class="line"><span class="preprocessor">        #ifndef Testing</span></div>
<div class="line">            apop_data_show(ktest);</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line">        <span class="keywordtype">double</span> pval = <a class="code" href="group__all__public.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(ktest, .rowname=<span class="stringliteral">&quot;p value, 2 tail&quot;</span>);</div>
<div class="line">        assert(pval &lt; prior_pval);</div>
<div class="line">        cprintf(<span class="stringliteral">&quot;%g\t%g\n&quot;</span>, i, pval);</div>
<div class="line">        prior_pval = pval;</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="group__all__public.html#gab29755a86b82dfe31cdd01d55431cc09">apop_model_free</a>(pmf1);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga9fba0f07c262a433133f6f3362617da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_text_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This allocates or resizes the <code>text</code> element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>If the <code>text</code> element already exists, then this is effectively a <code>realloc</code> function, reshaping to the size you specify.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. It's OK to send in <code>NULL</code>, in which case an <a class="el" href="structapop__data.html">apop_data</a> set with <code>NULL</code> <code>matrix</code> and <code>vector</code> elements is returned. </td></tr>
    <tr><td class="paramname">row</td><td>the number of rows of text. </td></tr>
    <tr><td class="paramname">col</td><td>the number of columns of text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the relevant <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the input was not <code>NULL</code>, then this is a repeat of the input pointer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65386d7b37c2eaf37d1eb4e3ae7a7554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_text_free </td>
          <td>(</td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>freeme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a matrix of chars* (i.e., a char***). This is what <code>apop_data_free</code> uses internally to deallocate the <code>text</code> element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. You may never need to use it directly.</p>
<p>Sample usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_text_free(yourdata-&gt;text, yourdata-&gt;textsize[0], yourdata-&gt;textsize[1]);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6270ad55c566140e0d7962cb4d5daacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* apop_text_paste </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> const *&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_riip&#160;</td>
          <td class="paramname"><em>prune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prune_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Join together the <code>text</code> grid of an <a class="el" href="gentle.html#apop_data">apop_data</a> set into a single string.</p>
<p>For example, say that we have a data set with some text: row 0 has <code>"a0"</code>, <code>"b0"</code>, <code>"c0"</code>; row 2 has <code>"a1"</code>, <code>"b1"</code>, <code>"c1"</code>; and so on. We would like to produce</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;insert into tab values (&#39;a0&#39;, &#39;b0&#39;, &#39;c0&#39;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;insert into tab values (&#39;a1&#39;, &#39;b1&#39;, &#39;c1&#39;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;...</div>
</div><!-- fragment --><p>This could be sent to an SQL engine to copy the data to a database (but this is just an example for demonstration&mdash;use <a class="el" href="group__all__public.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a> to write to a database table).</p>
<p>To construct this single string from the text grid, we would need to add: </p><ul>
<li>before the text, <code>Insert into tab values ('</code>. </li>
<li>between each element on a row: <code>', '</code> </li>
<li>between rows: <code>'); \ninsert into tab values('</code> </li>
<li>at the tail end: <code>');'</code></li>
</ul>
<p>Thus, do the conversion via: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char *insert_string = apop_text_paste(indata,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    .before=&quot;Insert into tab values (&#39;&quot;,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    .between=&quot;&#39;, &#39;&quot;,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    .between_cols=&quot;&#39;); \\ninsert into tab values(&#39;,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    .after=&quot;&#39;);&#39;&quot;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;);</div>
</div><!-- fragment --><p><code></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a grid of text to be combined into a single string </td></tr>
    <tr><td class="paramname">between</td><td>The text to put in between the rows of the table, such as ", ". (Default is a single space: " ") </td></tr>
    <tr><td class="paramname">before</td><td>The text to put at the head of the string. For the query example, this would be <code>.before="select "</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">after</td><td>The text to put at the tail of the string. For the query example, <code>.after=" from data_table"</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">between_cols</td><td>The text to insert between columns of text. See below for an example (Default is set to equal <code>.between</code>) </td></tr>
    <tr><td class="paramname">prune</td><td>If you don't want to use the entire text set, you can provide a function to indicate which elements should be pruned out. Some examples: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;//Just use column 3</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int is_not_col_3(apop_data *indata, int row, int col, void *ignore){</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return col!=3;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;//Jump over blanks as if they don&#39;t exist.</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;int is_blank(apop_data *indata, int row, int col, void *ignore){</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    return strlen(indata-&gt;text[row][col])==0;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramname">prune_parameter</td><td>A void pointer to pass to your <code>prune</code> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single string with the elements of the <code>strings</code> table joined as per your specification. Allocated by the function, to be freed by you if desired. <pre class="fragment">\li If the table of strings is \c NULL or has no text, the output string will have
</pre> only the <code>.before</code> and <code>.after</code> parts with nothing in between. <ul>
<li>if <code> apop_opts.verbose &gt;=3</code>, then print the pasted text to stderr. </li>
<li>It is sometimes useful to use <code>Apop_r</code> and <code>Apop_rs</code> to get a view of only one or a few rows in conjunction with this function. <pre class="fragment">\li This function uses the \ref designated syntax for inputs.
</pre></li>
</ul>
This sample snippet generates the SQL for a query using a list of column names (where the query begins with <code>select </code>, ends with <code>from datatab</code>, and has commas in between each element), re-processes the same list to produce the head of an HTML table, then produces the body of the table with the query result.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="group__all__public.html#ga02cf6319da103f9bfe55dfbbc7675536">apop_query</a>(<span class="stringliteral">&quot;create table datatab(name, age, sex);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 23, &#39;m&#39;);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 32, &#39;f&#39;);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 41, &#39;f&#39;);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 14, &#39;m&#39;);&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *cols = <a class="code" href="group__all__public.html#ga9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(NULL, 3, 1);</div>
<div class="line">    <a class="code" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a>(cols, 0, 0, <span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">    <a class="code" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a>(cols, 1, 0, <span class="stringliteral">&quot;age&quot;</span>);</div>
<div class="line">    <a class="code" href="group__all__public.html#gae987ac014cda5e483f8c16bfd59147ae">apop_text_set</a>(cols, 2, 0, <span class="stringliteral">&quot;sex&quot;</span>);</div>
<div class="line">    <span class="keywordtype">char</span> *query= <a class="code" href="group__all__public.html#ga6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;select &quot;</span>, .between=<span class="stringliteral">&quot;, &quot;</span>);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>(<span class="stringliteral">&quot;%s from datatab&quot;</span>, query);</div>
<div class="line">    <span class="keywordtype">char</span> *html_head = <a class="code" href="group__all__public.html#ga6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&quot;</span>,</div>
<div class="line">                                .between=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>, .after=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>);</div>
<div class="line">    <span class="keywordtype">char</span> *html_table = <a class="code" href="group__all__public.html#ga6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a>(d, .before=html_head, .after=<span class="stringliteral">&quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\n&quot;</span>,</div>
<div class="line">                                .between=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>, .between_cols=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);</div>
<div class="line">    FILE *outfile = fopen(<span class="stringliteral">&quot;yourdata.html&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);</div>
<div class="line">    fprintf(outfile, <span class="stringliteral">&quot;%s&quot;</span>, html_table);</div>
<div class="line">    fclose(outfile);</div>
<div class="line">}</div>
</div><!-- fragment --><p> </code></p>

</div>
</div>
<a class="anchor" id="gae987ac014cda5e483f8c16bfd59147ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_text_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a string to the text element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you send me a <code>NULL</code> string, I will write the value of <code>apop_opts.nan_string</code> in the given slot. If there is already something in that slot, that string is freed, preventing memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set, that already has an allocated <code>text</code> element. </td></tr>
    <tr><td class="paramname">row</td><td>The row </td></tr>
    <tr><td class="paramname">col</td><td>The column </td></tr>
    <tr><td class="paramname">fmt</td><td>The text to write. </td></tr>
    <tr><td class="paramname">...</td><td>You can use a printf-style fmt and follow it with the usual variables to fill in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0=OK, -1=error (probably out-of-bounds) <pre class="fragment">\li UTF-8 or ASCII text is correctly handled.
\li Apophenia follows a general rule of not reallocating behind your back: if
</pre> your text matrix is currently of size (3,3) and you try to put an item in slot (4,4), then I display an error rather than reallocating the text matrix. <ul>
<li>The string added is a copy (via <code>asprintf</code>), not a pointer to the input(s). </li>
<li>If there had been a string at the grid point you are writing to, the old one is freed to prevent leaks. Remember this if you had other pointers aliasing that string. </li>
<li><a class="el" href="group__all__public.html#ga9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> will reallocate to a new size if you need. For example, this code will fill the diagonals of the text array with a message, resizing as it goes:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *list = (something already allocated.);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;for (int n=0; n &lt; 10; n++){</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    apop_text_alloc(list, n+1, n+1);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    apop_text_set(list, n, n, &quot;This is cell (%i, %i)&quot;, n, n);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga630de5d4fcbe9ef13373029f5d813a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_text_to_data </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>text_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>has_row_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>has_col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const *&#160;</td>
          <td class="paramname"><em>field_ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>delimiters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a delimited or fixed-wisdth text file into the matrix element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>See <a class="el" href="text_format.html">Input text file formatting</a>.</p>
<p>See also <a class="el" href="group__all__public.html#gabd00e16791a970631c3ed4ac3487da46">apop_text_to_db</a>, which handles text data, and may othewise be a perferable approach to data management.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text_file</td><td>= "-" The name of the text file to be read in. If "-" (the default), use stdin. </td></tr>
    <tr><td class="paramname">has_row_names</td><td>Does the lines of data have row names? <code>'y'</code> =yes; <code>'n'</code> =no (default: 'n') </td></tr>
    <tr><td class="paramname">has_col_names</td><td>Is the top line a list of column names? See <a class="el" href="text_format.html">Input text file formatting</a> for notes on dimension (default: 'y') </td></tr>
    <tr><td class="paramname">field_ends</td><td>If fields have a fixed size, give the end of each field, e.g. <code>.field_ends=(int[]){3, 8 11}</code>. (default: <code>NULL</code>, indicating not fixed width) </td></tr>
    <tr><td class="paramname">delimiters</td><td>A string listing the characters that delimit fields. (default: <code>"|,\t"</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="structapop__data.html">apop_data</a> set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error </td></tr>
    <tr><td class="paramname">out-&gt;error=='t'</td><td>text-reading error</td></tr>
  </table>
  </dd>
</dl>
<p><b>example:</b> See <a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>.</p>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gabd00e16791a970631c3ed4ac3487da46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_text_to_db </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>text_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>has_row_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>has_col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>field_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const *&#160;</td>
          <td class="paramname"><em>field_ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>field_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>if_table_exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a delimited or fixed-wisdth text file into a database table. See <a class="el" href="text_format.html">Input text file formatting</a>.</p>
<p>For purely numeric data, you may be able to bypass the database by using <a class="el" href="group__all__public.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a>.</p>
<p>See the <a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a> page for an example that uses this function to read in sample data (also listed on that page).</p>
<p>Apophenia ships with an <code>apop_text_to_db</code> command-line utility, which is a wrapper for this function.</p>
<p>Especially if you are using a pre-2007 version of SQLite, there may be a speedup to putting this function in a begin/commit wrapper: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_query(&quot;begin;&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_print(dataset, .output_name=&quot;dbtab&quot;, .output_type=&#39;d&#39;);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;apop_query(&quot;commit;&quot;);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text_file</td><td>The name of the text file to be read in. If <code>"-"</code>, then read from <code>STDIN</code>. (default: "-") </td></tr>
    <tr><td class="paramname">tabname</td><td>The name to give the table in the database (default: <code>text_file</code> up to the first dot, e.g., <code>text_file=="pant_lengths.csv"</code> gives <code>tabname=="pant_lengths"</code>) </td></tr>
    <tr><td class="paramname">has_row_names</td><td>Does the lines of data have row names? (default: 0) </td></tr>
    <tr><td class="paramname">has_col_names</td><td>Is the top line a list of column names? (default: 1) </td></tr>
    <tr><td class="paramname">field_names</td><td>The list of field names, which will be the columns for the table. If <code>has_col_names==1</code>, read the names from the file (and just set this to <code>NULL</code>). If has_col_names == 1 &amp;&amp; field_names !=NULL, I'll use the field names. (default: NULL) </td></tr>
    <tr><td class="paramname">field_ends</td><td>If fields have a fixed size, give the end of each field, e.g. <code>.field_ends=(int[]){3, 8 11}</code>. (default: <code>NULL</code>, indicating not fixed width) </td></tr>
    <tr><td class="paramname">field_params</td><td>There is an implicit <code>create table</code> in setting up the database. If you want to add a type, constraint, or key, put that here. The relevant part of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set is the <code>text</code> grid, which should be <img class="formulaInl" alt="$N \times 2$" src="form_9.png"/>. The first item in each row (<code>your_params-&gt;text[n][0]</code>, for each <img class="formulaInl" alt="$n$" src="form_10.png"/>) is a regular expression to match against the variable names; the second item (<code>your_params-&gt;text[n][1]</code>) is the type, constraint, and/or key (i.e., what comes after the name in the <code>create</code> query). Not all variables need be mentioned; the default type if nothing matches is <code>numeric</code>. I go in order until I find a regex that matches the given field, so if you don't like the default, then set the last row to have name <code>.*</code>, which is a regex guaranteed to match anything that wasn't matched by an earlier row, and then set the associated type to your preferred default. See <a class="el" href="group__all__public.html#gaa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> on details of matching. (default: NULL) </td></tr>
    <tr><td class="paramname">table_params</td><td>There is an implicit <code>create table</code> in setting up the database. If you want to add a table constraint or key, such as <code>not null primary key (age, sex)</code>, put that here. </td></tr>
    <tr><td class="paramname">delimiters</td><td>A string listing the characters that delimit fields. default = <code>"|,\t"</code> </td></tr>
    <tr><td class="paramname">if_table_exists</td><td>What should I do if the table exists?<br />
 <code>'n'</code> Do nothing; exit this function. (default)<br />
 <code>'d'</code> Retain the table but delete all data; refill with the new data (i.e., call <code>"delete * from your_table"</code>).<br />
 <code>'o'</code> Overwrite the table from scratch; deleting the previous table entirely.<br />
 <code>'a'</code> Append new data to the existing table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of rows on success, -1 on error.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga77c937ea4764d3da2ed9968273fa4544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_text_unique_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give me a column of text, and I'll give you a sorted list of the unique elements. This is basically running <code>select distinct * from datacolumn</code>, but without the aid of the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a text component </td></tr>
    <tr><td class="paramname">col</td><td>The text column you want me to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a single sorted column of text, where each unique text input appears once. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac7c0ddb63673ddd40ba69f7dc8bff800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take in a prior and likelihood distribution, and output a posterior distribution.</p>
<ul>
<li>This function first checks a table of conjugate distributions for the pair you sent in. If the models are listed on the table, then the function returns a corresponding closed-form model with updated parameters.</li>
</ul>
<ul>
<li>If the parameters aren't in the table of conjugate, and the prior distribution has a <code>p</code> or <code>log_likelihood</code> element, then use <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a> to generate the posterior. If you expect MCMC to run, you may add an <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group to your prior to control the details of the search. See also the <a class="el" href="group__all__public.html#ga733c60eab5b69d89729565a3aeeb15d9">apop_model_metropolis</a> documentation.</li>
</ul>
<ul>
<li>If the prior does not have a <code>p</code> or <code>log_likelihood</code> but does have a <code>draw</code> element, then make draws from the prior and weight them by the <code>p</code> given by the likelihood distribution. This is not a rejection sampling method, so the burnin is ignored.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data, that will be used by the likelihood function (default = <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">prior</td><td>The prior <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>log_likelihood</code> or <code>p</code> method. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">likelihood</td><td>The likelihood <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>log_likelihood</code> or <code>p</code> method (ll preferred). (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, already initialized (e.g., via <a class="el" href="group__all__public.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>). (default: an RNG from <a class="el" href="group__all__public.html#ga1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="structapop__model.html">apop_model</a> struct representing the posterior, with updated parameters.</dd></dl>
<ul>
<li>In all cases, the output is a <a class="el" href="structapop__model.html">apop_model</a> that can be used as the input to this function, so you can chain Bayesian updating procedures. </li>
<li>Here are the conjugate distributions currently defined:</li>
</ul>
<table class="doxtable">
<tr>
<td>Prior </td><td>Likelihood </td><td>Notes   </td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">Binomial</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">Bernoulli</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#ga76b45a5681d30906572263eeef35aeff">Exponential</a> </td><td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td>Gamma likelihood represents the distribution of <img class="formulaInl" alt="$\lambda^{-1}$" src="form_98.png"/>, not plain <img class="formulaInl" alt="$\lambda$" src="form_99.png"/>   </td></tr>
<tr>
<td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td>Assumes prior with fixed <img class="formulaInl" alt="$\sigma$" src="form_69.png"/>; updates distribution for <img class="formulaInl" alt="$\mu$" src="form_74.png"/>  </td></tr>
<tr>
<td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td><a class="el" href="group__models.html#ga9c67838a4761452cc2c9113557f2a070">Poisson</a> </td><td>Uses sum and size of the data  </td></tr>
</table>
<p>Here is a test function that compares the output via conjugate table and via Metropolis-Hastings sampling: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//For the test suite.</span></div>
<div class="line"><span class="keywordtype">void</span> distances(gsl_vector *v1, gsl_vector *v2, <span class="keywordtype">double</span> tol){</div>
<div class="line">    <span class="keywordtype">double</span> error = <a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v2, .metric=<span class="charliteral">&#39;m&#39;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> updated_size = <a class="code" href="group__all__public.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(v1);</div>
<div class="line">    <a class="code" href="group__all__public.html#gabd17601e642688d033f62d346f3dace6">Apop_stopif</a>(error/updated_size &gt; tol, exit(1), 0, <span class="stringliteral">&quot;The error is %g, which is too big.&quot;</span>, error/updated_size);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keywordtype">double</span> binom_start = 0.6;</div>
<div class="line">    <span class="keywordtype">double</span> beta_start_a = 0.3;</div>
<div class="line">    <span class="keywordtype">double</span> beta_start_b = 0.5;</div>
<div class="line">    <span class="keywordtype">double</span> n = 4000;</div>
<div class="line">    <span class="comment">//First, the easy estimation using the conjugate distribution table.</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *bin = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, binom_start);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *beta = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, beta_start_a, beta_start_b);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *updated = <a class="code" href="group__all__public.html#gac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(.prior= beta, .likelihood=bin);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Now estimate via MCMC. </span></div>
<div class="line">    <span class="comment">//Requires a one-parameter binomial, with n fixed,</span></div>
<div class="line">    <span class="comment">//and a data set of n data points with the right p.</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *bcopy = <a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, GSL_NAN);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *bin_draws = <a class="code" href="group__all__public.html#gacb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((1,2), n*(1-binom_start), n*binom_start);</div>
<div class="line">    bin = <a class="code" href="group__all__public.html#gab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(bcopy);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga8fb1877a3cc29edd685a68dd6b4a35dc">Apop_settings_add_group</a>(beta, apop_mcmc, .burnin=.2, .periods=1e5);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *out_h = <a class="code" href="group__all__public.html#gac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(bin_draws, beta, bin, NULL);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *out_beta = <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(out_h-&gt;<a class="code" href="structapop__model.html#a076635fcdacf54e685c4715c07c1183c">data</a>, <a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Finally, we can compare the conjugate and Gibbs results:</span></div>
<div class="line">    distances(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, 0.01);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//The apop_update function used apop_model_metropolis to generate</span></div>
<div class="line">    <span class="comment">//a batch of draws, so the draw method for out_h is apop_model_metropolis_draw.</span></div>
<div class="line">    <span class="comment">//So, here we make more draws using metropolis, and compare the beta</span></div>
<div class="line">    <span class="comment">//distribution that fits to those draws to the beta distribution output above.</span></div>
<div class="line">    <span class="keywordtype">int</span> i, draws = 1.3e5;</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(out_h, draws);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *drawn = <a class="code" href="group__all__public.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, <a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>);</div>
<div class="line">    distances(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, drawn-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, 0.02);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>The conjugate table is stored using a vtable; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. If you are writing a new vtable entry, the typedef new functions must conform to and the hash used for lookups are:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;typedef apop_model *(*apop_update_type)(apop_data *, apop_model , apop_model);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define apop_update_hash(m1, m2) ((size_t)(m1).draw + (size_t)((m2).log_likelihood ? (m2).log_likelihood : (m2).p)*33)</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga51964750c64d327e52e2230019e44f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_apply </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to every row of a matrix. The function that you input takes in a <code>gsl_vector</code> and returns nothing. This function will send a pointer to each element of your vector to your function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>void fn(double in)</code></td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the vector is <code>NULL</code>, this is a no-op. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga136ded2b6d190739deca064701cf5ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_vector_bounded </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for a situation when a vector is diverging, so you can preempt a procedure that is about to break on infinite values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> </td></tr>
    <tr><td class="paramname">max</td><td>An upper and lower bound to the elements of the vector. (default: INFINITY) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if everything is bounded: not Inf, -Inf, or NaN, and <img class="formulaInl" alt="$-\max < x < \max$" src="form_22.png"/>;<br />
 0 otherwise.</dd></dl>
<ul>
<li>A <code>NULL</code> vector has no unbounded elements, so <code>NULL</code> input returns 1. You get a warning if <code>apop_opts.verbosity &gt;=2</code>. </li>
<li>Set <code>max</code> to <code>INFINITY</code> to test whether all of the matrix's elements are finite. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5baf0e8717a30fdcfba350da904c1825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_copy </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <code>gsl_vector</code> to another. That is, all data is duplicated. Unlike <code>gsl_vector_memcpy</code>, this function allocates and returns the destination, so you can use it like this: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_vector *a_copy = apop_vector_copy(original);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A structure that this function will allocate and fill. If <code>gsl_vector_alloc</code> fails, returns <code>NULL</code> and print a warning. </dd></dl>

</div>
</div>
<a class="anchor" id="ga105323d45e054e608d284e7efb9c0950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_correlation </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>ina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>inb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the correlation coefficient of two vectors: <img class="formulaInl" alt="$ {\hbox{cov}(a,b)\over \sqrt(\hbox{var}(a)) \sqrt(\hbox{var}(b))}.$" src="form_61.png"/></p>
<p>An example </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_matrix *m = [fill matrix here];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Apop_matrix_row(m, 2, rowtwo);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Apop_matrix_row(m, 3, rowthree);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;printf(&quot;The correlation coefficient between rows two &quot;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;       &quot;and three is %g.\n&quot;, apop_vector_correlation(rowtwo, rowthree));</div>
</div><!-- fragment --> <pre class="fragment">\li \c ina and \c inb are mandatory and must be non-NULL, but you can leave the weights
</pre><p> vector off in the typical case of uniform weights. </p><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga7c0881e9b640f6c6448014f44f5ac1f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_cov </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the sample covariance of a pair of vectors, with an optional weighting. This only makes sense if the weightings are identical, so the function takes only one weighting vector for both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1,v2</td><td>The data vectors (no default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. (default equal weights for all elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sample covariance</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga44a77f5e6867c627fd313f3f6e252ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_distance </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>ina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>inb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance between two vectors, where distance is defined based on the third (optional) parameter:</p>
<ul>
<li>'e' or 'E' (the default): scalar distance (standard Euclidean metric) between two vectors. <img class="formulaInl" alt="$\sqrt{\sum_i{(a_i - b_i)^2}},$" src="form_62.png"/> where <img class="formulaInl" alt="$i$" src="form_13.png"/> iterates over dimensions.</li>
<li>'m' or 'M' Returns the Manhattan metric distance between two vectors: <img class="formulaInl" alt="$\sum_i{|a_i - b_i|},$" src="form_63.png"/> where <img class="formulaInl" alt="$i$" src="form_13.png"/> iterates over dimensions.</li>
<li>'d' or 'D' The discrete norm: if <img class="formulaInl" alt="$a = b$" src="form_64.png"/>, return zero, else return one.</li>
<li>'s' or 'S' The sup norm: find the dimension where <img class="formulaInl" alt="$|a_i - b_i|$" src="form_65.png"/> is largest, return the distance along that one dimension.</li>
<li>'l' or 'L' The <img class="formulaInl" alt="$L_p$" src="form_66.png"/> norm, <img class="formulaInl" alt="$\left(\sum_i{|a_i - b_i|^2}\right)^{1/p}$" src="form_67.png"/>. The value of <img class="formulaInl" alt="$p$" src="form_17.png"/> is set by the fourth (optional) argument.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ina</td><td>First vector (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">inb</td><td>Second vector (Default = zero) </td></tr>
    <tr><td class="paramname">metric</td><td>The type of metric, as above. </td></tr>
    <tr><td class="paramname">norm</td><td>If you are using an <img class="formulaInl" alt="$L_p$" src="form_66.png"/> norm, this is <img class="formulaInl" alt="$p$" src="form_17.png"/>. Must be strictly greater than zero. (default = 2)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The defaults are such that <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_vector_distance(v);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_vector_distance(v, .metric = &#39;s&#39;);</div>
</div><!-- fragment --> gives you the standard Euclidean length of <code>v</code> and its longest element.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* Test distance calculations using a 3-4-5 triangle */</span></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    gsl_vector *v1 = gsl_vector_alloc(2);</div>
<div class="line">    gsl_vector *v2 = gsl_vector_alloc(2);</div>
<div class="line">    <a class="code" href="group__all__public.html#gaf9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a>(v1, 2, 2);</div>
<div class="line">    <a class="code" href="group__all__public.html#gaf9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a>(v2, 5, 6);</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v1, <span class="charliteral">&#39;d&#39;</span>) == 0);     <span class="comment">//discrete: if vectors are equal d==0;</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v2, <span class="charliteral">&#39;d&#39;</span>) == 1);     <span class="comment">//          if vectors differ d ==1</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, NULL, <span class="charliteral">&#39;m&#39;</span>) == 4.);  <span class="comment">//length of v1, Manhattan metric</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2) == 5.);          <span class="comment">//the hypotenuse of the 3-4-5 triangle</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v2, NULL, <span class="charliteral">&#39;s&#39;</span>) == 6);   <span class="comment">//length of v2, sup norm</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;m&#39;</span>) == 7.);     <span class="comment">//distance v1 to v2 in Manhattan</span></div>
<div class="line">    assert(<a class="code" href="group__all__public.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;L&#39;</span>, 2) == 5.);  <span class="comment">//L_2 norm == Euclidean</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gabd5c77978dc6972e4ba52f77fb8dfef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_vector_entropy </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector representing a probability distribution of observations, calculate the entropy, <img class="formulaInl" alt="$\sum_i -\ln(v_i)v_i$" src="form_76.png"/>.</p>
<ul>
<li>The input vector need not be normalized to sum to one. You may input a vector giving frequencies.</li>
</ul>
<ul>
<li>The entropy of a data set depends only on the frequency with which elements are observed, not the value of the elements themselves. The <a class="el" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> function will reduce an input <a class="el" href="gentle.html#apop_data">apop_data</a> set to one weighted line per observation, and the weights would determine the entropy:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_data *data = apop_text_to_data(&quot;indata&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_data_pmf_compress(data);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;data_entropy = apop_vector_entropy(d-&gt;weights);</div>
</div><!-- fragment --><ul>
<li>The entropy is calculated using natural logs. To convert to base 2, divide by <img class="formulaInl" alt="$\ln(2)$" src="form_77.png"/>; see the example.</li>
</ul>
<ul>
<li>The entropy of an empty data set (<code>NULL</code> or a total weight of zero) is zero. Print a warning when given <code>NULL</code> input and <code>apop_opts.verbose &gt;=1</code>.</li>
</ul>
<ul>
<li>If the input vector has negative elements, return <code>NaN</code>; print a warning when <code>apop_opts.verbose &gt;= 0</code>.</li>
</ul>
<p>Sample code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define Diff(left, right, eps) Apop_stopif(fabs((left)-(right))&gt;(eps), abort(), 0, &quot;%g is too different from %g (abitrary limit=%g).&quot;, (double)(left), (double)(right), eps)</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">double</span> entropy_base_2(gsl_vector *x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__all__public.html#gabd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(x)/log(2);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="structapop__data.html">apop_data</a> *flip_a_coin(<span class="keywordtype">int</span> how_many){</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__all__public.html#ga4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(<a class="code" href="group__all__public.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">apop_bernoulli</a>, .5), how_many);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="comment">//zero data =&gt; entropy zero</span></div>
<div class="line">    gsl_vector *v = gsl_vector_calloc(1);</div>
<div class="line">    assert(<a class="code" href="group__all__public.html#gabd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(v) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//negative data =&gt; NaN</span></div>
<div class="line">    gsl_vector_set(v, 0, -1);</div>
<div class="line">    <span class="keywordtype">int</span> v1 = <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a>;</div>
<div class="line">    <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> = -1;</div>
<div class="line">    assert(isnan(<a class="code" href="group__all__public.html#gabd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(v)));</div>
<div class="line">    <a class="code" href="group__all__public.html#ga7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> = v1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//N equiprobable bins =&gt; entropy = log(N)</span></div>
<div class="line">    v = <a class="code" href="group__all__public.html#gaf4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a>(v, 100);</div>
<div class="line">    gsl_vector_set_all(v, 1./100);</div>
<div class="line">    Diff(log(100), <a class="code" href="group__all__public.html#gabd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(v), 1e-5);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//flip two coins.</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *coin_flips = flip_a_coin(10000);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *c2         = flip_a_coin(10000);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>(c2, coin_flips, <span class="charliteral">&#39;c&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//entropy of one coin flip in base2 == 1</span></div>
<div class="line">    <a class="code" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(coin_flips);</div>
<div class="line">    Diff(entropy_base_2(coin_flips-&gt;weights), 1, 1e-3);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//entropy of two coin flips in base2 == 2</span></div>
<div class="line">    <a class="code" href="group__all__public.html#gacc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(c2);</div>
<div class="line">    Diff(entropy_base_2(c2-&gt;weights), 2, 1e-3);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(coin_flips);</div>
<div class="line">    <a class="code" href="group__all__public.html#ga459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(c2);</div>
<div class="line">    gsl_vector_free(v);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga032dcecb67155c527c884dd2c1cc6a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_exp </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace every vector element <img class="formulaInl" alt="$v_i$" src="form_20.png"/> with exp <img class="formulaInl" alt="$(v_i)$" src="form_21.png"/>.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf5740c698174b1a265d182f4af1c0252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_kurtosis </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sample kurtosis of the data in the given vector. Corrections are made to produce an unbiased result as per <a href="http://modelingwithdata.org/pdfs/moments.pdf">Appendix M</a> (PDF) of <em>Modeling with data</em>.</p>
<ul>
<li>This is an estimate of the fourth central moment without normalization. The kurtosis of a <img class="formulaInl" alt="${\cal N}(0,1)$" src="form_55.png"/> is <img class="formulaInl" alt="$3 \sigma^4$" src="form_56.png"/>, not three, one, or zero. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaabe3183e8a6a496f3fd6ab316687381e">apop_vector_kurtosis_pop</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gaabe3183e8a6a496f3fd6ab316687381e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_kurtosis_pop </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the population kurtosis [ <img class="formulaInl" alt="$\sum_i (x_i - \mu)^4/n)$" src="form_60.png"/>] of the data in the given vector, with an optional weighting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weighted kurtosis. <pre class="fragment">\li Some people like to normalize the fourth central moment by dividing by variance
</pre> squared, or by subtracting three; those things are not done here, so you'll have to do them separately if need be. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a> for the unbiased sample version. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a622b8360eba63795a6049c30ac54a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_log </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the natural log of every element in a vector.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1a4a67e0b0bec8205cfe75bd3786c30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_log10 </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the log (base ten) of every element in a vector.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf30eadf8772ecb9a2689ddf104902ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_map </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a function onto every element of a vector. <code>apop_vector_map</code> will send each element to your function, and will output a <code>gsl_vector</code> holding your function's output for each row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>double fn(double in)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>gsl_vector</code> (allocated by this function) with the corresponding value for each row.</dd></dl>
<ul>
<li>If you input a <code>NULL</code> vector, I return <code>NULL</code>. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gaa1a135fcdd8ea6f9cbc0d518773d6c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_map_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>apop_vector_map</code>, but returns the sum of the resulting mapped function. For example, <code>apop_vector_map_sum(v, isnan)</code> returns the number of elements of <code>v</code> that are <code>NaN</code>.</p>
<ul>
<li>If you input a <code>NULL</code> vector, I return the sum of zero items: zero. </li>
<li>See <a class="el" href="dataoverview.html#mapply">the map/apply page</a> for details. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>, <a class="el" href="group__all__public.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gab20e5ad95df0f24a1ea06294695031a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_mean </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the mean, weighted or unweighted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. Default: assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weighted mean <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga61185af7877b709c8b257b342c24edbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_moving_average </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bandwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new vector that is the moving average of the input vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector, unsmoothed </td></tr>
    <tr><td class="paramname">bandwidth</td><td>An integer <img class="formulaInl" alt="$\geq 1$" src="form_19.png"/> giving the number of elements to be averaged to produce one number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smoothed vector of size <code>v-&gt;size - (bandwidth/2)*2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga194ad92b1bc632ba1d13d9958c7b5b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_normalize </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will normalize a vector, either such that it has mean zero and variance one, or ranges between zero and one, or sums to one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> with the un-normalized data. <code>NULL</code> input gives <code>NULL</code> output. (No default)</td></tr>
    <tr><td class="paramname">out</td><td>If normalizing in place, <code>NULL</code>. If not, the address of a <code>gsl_vector*</code>. Do not allocate. (default = <code>NULL</code>.)</td></tr>
    <tr><td class="paramname">normalization_type</td><td><code>'p'</code>: normalized vector will sum to one. E.g., start with a set of observations in bins, end with the percentage of observations in each bin. (the default)<br />
 <code>'r'</code>: normalized vector will range between zero and one. Replace each X with (X-min) / (max - min).<br />
 <code>'s'</code>: normalized vector will have mean zero and (sample) variance one. Replace each X with <img class="formulaInl" alt="$(X-\mu) / \sigma$" src="form_68.png"/>, where <img class="formulaInl" alt="$\sigma$" src="form_69.png"/> is the sample standard deviation.<br />
 <code>'m'</code>: normalize to mean zero: Replace each X with <img class="formulaInl" alt="$(X-\mu)$" src="form_70.png"/><br />
</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"></div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gafb838084f967543fa8a03e460180d53b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* apop_vector_percentiles </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rounding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of size 101, where <code>returned_vector</code>[95] gives the value of the 95th percentile, for example. <code>Returned_vector</code>[100] is always the maximum value, and <code>returned_vector</code>[0] is always the min (regardless of rounding rule).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a <code>gsl_vector</code> of data. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rounding</td><td>This will either be <code>'u'</code>, <code>'d'</code>, or <code>'a'</code>. Unless your data is exactly a multiple of 101, some percentiles will be ambiguous. If <code>'u'</code>, then round up (use the next highest value); if <code>'d'</code> (or anything else), round down to the next lowest value; if <code>'a'</code>, take the mean of the two nearest points. (Default = <code>'d'</code>.) <ul>
<li>If the rounding method is <code>'u'</code> or <code>'a'</code>, then you can say "5% or more  of
the sample is below returned_vector[5]"; if <code>'d'</code> or <code>'a'</code>, then you can say "5%
or more of the sample is above returned_vector[5]". </li>
<li>You may eventually want to <code>free()</code> the array returned by this function. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e68deb42339cf6068ab6e741237918d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_print </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_declares&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a vector to the screen, a file, a pipe, or the database You may want to set <a class="el" href="structapop__opts__type.html">apop_opts.output_delimiter</a>; the default is a tab, which puts the vector on one line, but a newline would print the vector vertically.</p>
<ul>
<li>See <a class="el" href="group__all__public.html#ga4748bf59f5441cd27e5b93056c7ec1c7">apop_prep_output</a> for more on how printing settings are set. </li>
<li>See also <a class="el" href="c.html#Legi">Legible output</a> for more details and examples. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf4658a3ecc0acfd17f610bc162fa5556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_realloc </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will resize a <code>gsl_vector</code> to a new length.</p>
<p>Data in the vector will be retained. If the new height is smaller than the old, then data at the end of the vector will be cropped away (in a non&ndash;memory-leaking manner). If the new height is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill them before use.</p>
<ul>
<li>A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data and do one allocation, rather than writing <code>for</code> loops that resize a vector at every increment.</li>
</ul>
<ul>
<li>The <code>gsl_vector</code> is a versatile struct that can represent subvectors, matrix columns and other cuts from parent data. Resizing a portion of a parent matrix makes no sense, so return <code>NULL</code> and print an error if asked to resize a view.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The already-allocated vector to resize. If you give me <code>NULL</code>, this is equivalent to <code>gsl_vector_alloc</code> </td></tr>
    <tr><td class="paramname">newheight</td><td>The height you'd like the vector to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>v, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="gac9d269f1dc62b038c0da72085cac1c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_skew </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an unbiased estimate of the sample skew of the data in the given vector. </p>

</div>
</div>
<a class="anchor" id="gafb284d668d567de4810620962043f827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_skew_pop </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the population skew <img class="formulaInl" alt="$(\sum_i (x_i - \mu)^3/n))$" src="form_57.png"/> of the data in the given vector. Observations may be weighted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. Default: equal weights for all observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weighted skew.</dd></dl>
<ul>
<li>Some people like to normalize the skew by dividing by variance <img class="formulaInl" alt="$^{3/2}$" src="form_58.png"/>; that's not done here, so you'll have to do so separately if need be.</li>
</ul>
<ul>
<li>Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_59.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_10.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga294d0269c4cbe36709130bebd893938d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_stack </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the first vector on top of the second vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the upper vector (default=<code>NULL</code>, in which case this basically copies <code>v2</code>) </td></tr>
    <tr><td class="paramname">v2</td><td>the second vector (default=<code>NULL</code>, in which case nothing is added) </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'y', use <a class="el" href="group__all__public.html#gaf4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>v1</code> in place; see the caveats on that function. Otherwise, allocate a new vector, leaving <code>v1</code> undisturbed. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stacked data, either in a new vector or a pointer to <code>v1</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf6182181dd424bc4de98b4bfbd349b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_vector_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the data in the given vector. </p>

</div>
</div>
<a class="anchor" id="ga604388dc6d7d08d95bbaa4422085db9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_vector_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>row_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mathematically, a vector of size <img class="formulaInl" alt="$N$" src="form_6.png"/> and a matrix of size <img class="formulaInl" alt="$N \times 1 $" src="form_7.png"/> are equivalent, but they're two different types to the GSL. This function copies the data in a vector to a new one-column (or one-row) matrix and returns the newly-allocated and filled matrix.</p>
<p>For the reverse, try <a class="el" href="group__all__public.html#ga90feb5dd661cfe0f0b53a85295b8b56e">apop_data_pack</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a <code>gsl_vector</code> (No default. If <code>NULL</code>, I return <code>NULL</code>, with a warning if <code>apop_opts.verbose &gt;=1 </code>) </td></tr>
    <tr><td class="paramname">row_col</td><td>If <code>'r'</code>, then this will be a row (1 x N) instead of the default, a column (N x 1). (default: <code>'c'</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated <code>gsl_matrix</code> with one column (or row).</dd></dl>
<ul>
<li>If you send in a <code>NULL</code> vector, you get a <code>NULL</code> pointer in return. I warn you of this if <code>apop_opts.verbosity &gt;=1 </code>. </li>
<li>If <code>gsl_matrix_alloc</code> fails you get a <code>NULL</code> pointer in return. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga6d68bacc086420a382366f9118cf5bc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_unique_elements </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give me a vector of numbers, and I'll give you a sorted list of the unique elements. This is basically running "select distinct datacol from data order by datacol", but without the aid of the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of items </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sorted vector of the distinct elements that appear in the input. <ul>
<li>NaNs appear at the end of the sort order. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadcc397ab90933d79b3062206301a0aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_var </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the sample variance of a vector, weighted or unweighted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. If NULL (the default), assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weighted sample variance. <pre class="fragment">\li This uses (n-1) in the denominator of the sum; i.e., it corrects for the bias
</pre> introduced by using <img class="formulaInl" alt="$\bar x$" src="form_73.png"/> instead of <img class="formulaInl" alt="$\mu$" src="form_74.png"/>. <ul>
<li>At the moment, there is no var_pop function. Just multiply this by (n-1)/n if you need that. </li>
<li>Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_59.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_10.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#ga2446385225c68c62ade26402c63600a4">apop_vector_var_m</a> for the case where you already have the vector's mean. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2446385225c68c62ade26402c63600a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_var_m </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the variance of the data in the given vector, given that you've already calculated the mean. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the vector in question </td></tr>
    <tr><td class="paramname">mean</td><td>the mean, which you've already calculated using <a class="el" href="group__all__public.html#gab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__all__public.html#gadcc397ab90933d79b3062206301a0aa0">apop_vector_var</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga7975faa07196cf463ec261ff0ddc3ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__opts__type.html">apop_opts_type</a> apop_opts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Here are where the options are initially set. See the <a class="el" href="structapop__opts__type.html">apop_opts_type</a> documentation for details. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</body></html>

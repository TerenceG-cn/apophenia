<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">apop_mle.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrad__params.html">grad_params</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinfostruct.html">infostruct</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__model__for__infomatrix__struct.html">apop_model_for_infomatrix_struct</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa927b4dbd7ec67eaec805be6af71df58"></a><!-- doxytag: member="apop_mle.c::Onecheck" ref="aa927b4dbd7ec67eaec805be6af71df58" args="(str)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Onecheck</b>(str)&#160;&#160;&#160;if (!strcasecmp(m, #str)) return 0;</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a118b64f34c44090080bdce6d8b8ddbbd"></a><!-- doxytag: member="apop_mle.c::apop_fn_with_params" ref="a118b64f34c44090080bdce6d8b8ddbbd" args=")(apop_data *, apop_model *)" -->
typedef long double(*&#160;</td><td class="memItemRight" valign="bottom"><b>apop_fn_with_params</b> )(<a class="el" href="structapop__data.html">apop_data</a> *, <a class="el" href="structapop__model.html">apop_model</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad49359d686094c4d703b70b5a6fa1f8a"></a><!-- doxytag: member="apop_mle.c::apop_df_with_void" ref="ad49359d686094c4d703b70b5a6fa1f8a" args=")(const gsl_vector *beta, void *d, gsl_vector *gradient)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>apop_df_with_void</b> )(const gsl_vector *beta, void *d, gsl_vector *gradient)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada7e9db6a6c75da55e12e812c9a5eb5c"></a><!-- doxytag: member="apop_mle.c::apop_fdf_with_void" ref="ada7e9db6a6c75da55e12e812c9a5eb5c" args=")(const gsl_vector *beta, void *d, double *f, gsl_vector *df)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>apop_fdf_with_void</b> )(const gsl_vector *beta, void *d, double *f, gsl_vector *df)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a5d5ac307679f87428389ed0b6dea7"></a><!-- doxytag: member="apop_mle.c::Apop_settings_copy" ref="aa1a5d5ac307679f87428389ed0b6dea7" args="(Apop_settings_free(apop_parts_wanted)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_settings_copy</b> (<a class="el" href="apop_8h.html#a833e962fb042462eeadada7484671f07">Apop_settings_free</a>(apop_parts_wanted)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__mle_8c.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__mle_8c.html#a0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26cdf8ffbd8508760493d050912d4db7"></a><!-- doxytag: member="apop_mle.c::add_info_criteria" ref="a26cdf8ffbd8508760493d050912d4db7" args="(apop_data *d, apop_model *m, apop_model *est, double ll, int param_ct)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_info_criteria</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m, <a class="el" href="structapop__model.html">apop_model</a> *est, double ll, int param_ct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58ca4d3f885902fd098164784933ca81"></a><!-- doxytag: member="apop_mle.c::get_desires" ref="a58ca4d3f885902fd098164784933ca81" args="(apop_model *m, infostruct *info)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_desires</b> (<a class="el" href="structapop__model.html">apop_model</a> *m, <a class="el" href="structinfostruct.html">infostruct</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae63a95bb30181d8f6533a6421e130fb"></a><!-- doxytag: member="apop_mle.c::check_method" ref="aae63a95bb30181d8f6533a6421e130fb" args="(char *m)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_method</b> (char *m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mle.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *dist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> (<a class="el" href="structapop__model.html">apop_model</a> *e, <a class="el" href="structapop__model.html">apop_model</a> *copy, char *starting_pt, double boundary)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1edb6b92c9ab09f0c9195796ff3bd9c"></a><!-- doxytag: member="apop_mle.c::default_delta" ref="ac1edb6b92c9ab09f0c9195796ff3bd9c" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>default_delta</b> = 1e-3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_model_for_infomatrix</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ad8c78475de735d471aae82741113b3"></a><!-- doxytag: member="apop_mle.c::anneal_jump" ref="a8ad8c78475de735d471aae82741113b3" args="" -->
jmp_buf&#160;</td><td class="memItemRight" valign="bottom"><b>anneal_jump</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The MLE functions. Call them with an <a class="el" href="structapop__model.html">apop_model</a>.</p>
<p>This file includes a number of distributions and models whose parameters one would estimate using maximum likelihood techniques.</p>
<p>It has (more-or-less) a single public function: <a class="el" href="group__mle.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a>, and you don't even need to use that one, because the <code>apop_estimate</code> function defaults to using it if there is no model-specific estimation routine provided.</p>
<p>At the bottom are the maximum likelihood procedures themselves. There are four: Newton-type derivative methods, the no-derivative version, the with-derivative version, and the simulated annealing routine. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1a55a20880947e289767aad6e5b0117c"></a><!-- doxytag: member="apop_mle.c::apop_model_hessian" ref="a1a55a20880947e289767aad6e5b0117c" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__mle_8c.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Numerically estimate the matrix of second derivatives of the parameter values. The math is simply a series of re-evaluations at small differential steps. [Therefore, it may be expensive to do this for a very computationally-intensive model.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data at which the model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>The model, with parameters already estimated </td></tr>
    <tr><td class="paramname">delta</td><td>the step size for the differentials. The current default is around 1e-3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matrix of estimated second derivatives at the given data and parameter values.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2784b69175d1ecd3833d228d2294e7"></a><!-- doxytag: member="apop_mle.c::apop_model_numerical_covariance" ref="a0f2784b69175d1ecd3833d228d2294e7" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__mle_8c.html#a0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce the covariance matrix for the parameters of an estimated model via the derivative of the score function at the parameter. I.e., I find the second derivative via <a class="el" href="apop__mle_8c.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> , and take the negation of the inverse.</p>
<p>I follow Efron and Hinkley in using the estimated information matrix---the value of the information matrix at the estimated value of the score---not the expected information matrix that is the integral over all possible data. See Pawitan 2001 (who cribbed a little off of Efron and Hinkley) or Klemens 2008 (who directly cribbed off of both) for further details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data by which your model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>A model whose parameters have been estimated. </td></tr>
    <tr><td class="paramname">delta</td><td>The differential by which to step for sampling changes. (default currently = 1e-3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A covariance matrix for the data. Also, if the data does not have a <code>"Covariance"</code> page, I'll set it to the result as well [i.e., I won't overwrite an existing covar].</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a73a89f595f61fc0f3a5fcea77ef2a862"></a><!-- doxytag: member="apop_mle.c::apop_model_for_infomatrix" ref="a73a89f595f61fc0f3a5fcea77ef2a862" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_for_infomatrix</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> &amp;(<a class="code" href="apop_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a>){<span class="stringliteral">&quot;Ad hoc model for working out the information matrix.&quot;</span>, 
                                                .log_likelihood = apop_fn_for_infomatrix}
</pre></div>
</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Fri Oct 24 2014.</div></body></html>

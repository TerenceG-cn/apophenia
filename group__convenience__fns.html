<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>
    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Things to make life easier with the GSL</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7f85a98b61078ba3dc273f17eddd34a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(in)&#160;&#160;&#160;<a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(in)</td></tr>
<tr class="separator:ga7f85a98b61078ba3dc273f17eddd34a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gada044cf02135422a9f9292b6054c86dd"><td class="memItemLeft" align="right" valign="top">gsl_rng *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> (int seed)</td></tr>
<tr class="separator:gada044cf02135422a9f9292b6054c86dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baf0e8717a30fdcfba350da904c1825"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)</td></tr>
<tr class="separator:ga5baf0e8717a30fdcfba350da904c1825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bb322b9f491c46feb1e24025b6301f"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)</td></tr>
<tr class="separator:ga45bb322b9f491c46feb1e24025b6301f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4a67e0b0bec8205cfe75bd3786c30e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> (gsl_vector *v)</td></tr>
<tr class="separator:ga1a4a67e0b0bec8205cfe75bd3786c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a622b8360eba63795a6049c30ac54a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> (gsl_vector *v)</td></tr>
<tr class="separator:ga5a622b8360eba63795a6049c30ac54a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032dcecb67155c527c884dd2c1cc6a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> (gsl_vector *v)</td></tr>
<tr class="separator:ga032dcecb67155c527c884dd2c1cc6a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae603a7d511cf40b022f99dc69faa616a"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gae603a7d511cf40b022f99dc69faa616a">apop_vector_stack</a> (gsl_vector *v1, gsl_vector *v2, char inplace)</td></tr>
<tr class="separator:gae603a7d511cf40b022f99dc69faa616a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50bc918e0d8b6ee913596f68ab731a8"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a> (gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)</td></tr>
<tr class="separator:gae50bc918e0d8b6ee913596f68ab731a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136ded2b6d190739deca064701cf5ca1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> (const gsl_vector *in, long double max)</td></tr>
<tr class="separator:ga136ded2b6d190739deca064701cf5ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6182181dd424bc4de98b4bfbd349b4e"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)</td></tr>
<tr class="separator:gaf6182181dd424bc4de98b4bfbd349b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a77f5e6867c627fd313f3f6e252ff8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)</td></tr>
<tr class="separator:ga44a77f5e6867c627fd313f3f6e252ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369c774aac917e56d8e32f9c66d9c2a0"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)</td></tr>
<tr class="separator:ga369c774aac917e56d8e32f9c66d9c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040b9e9fea1abe105de86081bf396d40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)</td></tr>
<tr class="separator:ga040b9e9fea1abe105de86081bf396d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf794cc2491ef147e0c67eb05feed7a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)</td></tr>
<tr class="separator:gaf794cc2491ef147e0c67eb05feed7a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7f85a98b61078ba3dc273f17eddd34a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_sum</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(in)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>. Returns the sum of the data in the given vector. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga45bb322b9f491c46feb1e24025b6301f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_copy </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <code>gsl_matrix</code> to another. That is, all data is duplicated. Unlike <code>gsl_matrix_memcpy</code>, this function allocates and returns the destination, so you can use it like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_matrix *a_copy = apop_matrix_copy(original);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure that this function will allocate and fill. If <code>gsl_matrix_alloc</code> fails, returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga040b9e9fea1abe105de86081bf396d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_mean </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mean of all elements of a matrix.</p>
<p>Calculated with an eye toward avoiding overflow errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. If <code>NULL</code>, return zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf794cc2491ef147e0c67eb05feed7a87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_mean_and_var </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mean and population variance of all elements of a matrix.</p>
<ul>
<li>If you want sample variance, multiply the result returned by <code>(data-&gt;size1*data-&gt;size2)/(data-&gt;size1*data-&gt;size2-1.0)</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. </td></tr>
    <tr><td class="paramname">mean</td><td>where to put the mean to be calculated. </td></tr>
    <tr><td class="paramname">var</td><td>where to put the variance to be calculated.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If <code>NULL</code>, return (zero, NaN). </li>
</ul>

</div>
</div>
<a class="anchor" id="gae50bc918e0d8b6ee913596f68ab731a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_stack </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the first matrix either on top of or to the right of the second matrix. The fn returns a new matrix, meaning that at the end of this function, until you gsl_matrix_free() the original matrices, you will be taking up twice as much memory. Plan accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost matrix (default=<code>NULL</code>, in which case this basically copies <code>m2</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix (default = <code>NULL</code>, in which case <code>m1</code> is returned) </td></tr>
    <tr><td class="paramname">posn</td><td>if 'r', stack rows on top of other rows, else, e.g. 'c' stack columns next to columns. (default ='r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'y', use <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> to modify <code>m1</code> in place; see the caveats on that function. Otherwise, allocate a new matrix, leaving <code>m1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stacked data, either in a new matrix or a pointer to <code>m1</code>.</dd></dl>
<p>For example, here is a little function to merge four matrices into a single two-part-by-two-part matrix. The original matrices are unchanged. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_matrix *apop_stack_two_by_two(gsl_matrix *ul, gsl_matrix *ur, gsl_matrix *dl, gsl_matrix *dr){</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  gsl_matrix *output, *t;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    output = apop_matrix_stack(ul, ur, &#39;c&#39;);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    t = apop_matrix_stack(dl, dr, &#39;c&#39;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    apop_matrix_stack(output, t, &#39;r&#39;, .inplace=&#39;y&#39;);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    gsl_matrix_free(t);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    return output;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga369c774aac917e56d8e32f9c66d9c2a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_matrix_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the elements of a matrix. Occasionally convenient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to be summed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada044cf02135422a9f9292b6054c86dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_rng* apop_rng_alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a <code>gsl_rng</code>.</p>
<p>Uses the Tausworth routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed. No need to get funny with it: 0, 1, and 2 will produce wholly different streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RNG ready for your use.</dd></dl>
<ul>
<li>If you are confident that your code is debugged and would like a new stream of values every time your program runs (provided your runs are more than a second apart), seed with the time:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.rng_seed = time(NULL);</div>
<div class="line">    <a class="code" href="group__apop__print.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(</div>
<div class="line">            <a class="code" href="apop_8h.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(</div>
<div class="line">                <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1), </div>
<div class="line">                .count=10, </div>
<div class="line">            )</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga136ded2b6d190739deca064701cf5ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_vector_bounded </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for a situation when a vector is diverging, so you can preempt a procedure that is about to break on infinite values.</p>
<p>Alternatively, set <code>max</code> to <code>INFINITY</code> (or <code>GSL_INF</code>) to just test whether all of the matrix's elements are finite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> </td></tr>
    <tr><td class="paramname">max</td><td>An upper and lower bound to the elements of the vector. (default: GSL_POSINF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if everything is bounded: not Inf, -Inf, or NaN, and <img class="formulaInl" alt="$-\max < x < \max$" src="form_22.png"/>; zero otherwise.</dd></dl>
<ul>
<li>A <code>NULL</code> vector has no unbounded elements, so <code>NULL</code> input returns 1. You get a warning if <code>apop_opts.verbosity &gt;=1</code>. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5baf0e8717a30fdcfba350da904c1825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_copy </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <code>gsl_vector</code> to another. That is, all data is duplicated. Unlike <code>gsl_vector_memcpy</code>, this function allocates and returns the destination, so you can use it like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gsl_vector *a_copy = apop_vector_copy(original);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure that this function will allocate and fill. If <code>gsl_vector_alloc</code> fails, returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44a77f5e6867c627fd313f3f6e252ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_distance </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>ina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>inb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance between two vectors, where distance is defined based on the third (optional) parameter:</p>
<ul>
<li>'e' or 'E' (the default): scalar distance (standard Euclidean metric) between two vectors. Simply <img class="formulaInl" alt="$\sqrt{\sum_i{(a_i - b_i)^2}},$" src="form_64.png"/> where <img class="formulaInl" alt="$i$" src="form_65.png"/> iterates over dimensions.</li>
<li>'m' or 'M' Returns the Manhattan metric distance between two vectors: <img class="formulaInl" alt="$\sum_i{|a_i - b_i|},$" src="form_66.png"/> where <img class="formulaInl" alt="$i$" src="form_65.png"/> iterates over dimensions.</li>
<li>'d' or 'D' The discrete norm: if <img class="formulaInl" alt="$a = b$" src="form_67.png"/>, return zero, else return one.</li>
<li>'s' or 'S' The sup norm: find the dimension where <img class="formulaInl" alt="$|a_i - b_i|$" src="form_68.png"/> is largest, return the distance along that one dimension.</li>
<li>'l' or 'L' The <img class="formulaInl" alt="$L_p$" src="form_69.png"/> norm, <img class="formulaInl" alt="$\left(\sum_i{(a_i - b_i)^2}\right)^{1/p},$" src="form_70.png"/>. The value of <img class="formulaInl" alt="$p$" src="form_19.png"/> is set by the fourth (optional) argument.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ina</td><td>First vector (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">inb</td><td>Second vector (Default = zero) </td></tr>
    <tr><td class="paramname">metric</td><td>The type of metric, as above. </td></tr>
    <tr><td class="paramname">norm</td><td>If you are using an <img class="formulaInl" alt="$L_p$" src="form_69.png"/> norm, this is <img class="formulaInl" alt="$p$" src="form_19.png"/>. Must be strictly greater than zero. (default = 2)</td></tr>
  </table>
  </dd>
</dl>
<p>Notice that the defaults are such that </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;apop_vector_distance(v);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;apop_vector_distance(v, .metric = &#39;s&#39;);</div>
</div><!-- fragment --><p> gives you the standard Euclidean length of <code>v</code> and its longest element.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* Test distance calculations using a 3-4-5 triangle */</span></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    gsl_vector *v1 = gsl_vector_alloc(2);</div>
<div class="line">    gsl_vector *v2 = gsl_vector_alloc(2);</div>
<div class="line">    gsl_vector_set(v1, 0,2);</div>
<div class="line">    gsl_vector_set(v1, 1,2);</div>
<div class="line">    gsl_vector_set(v2, 0,5);</div>
<div class="line">    gsl_vector_set(v2, 1,6);</div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v1, <span class="charliteral">&#39;d&#39;</span>) == 0);     <span class="comment">//discrete: if vectors are equal d==0;</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v2, <span class="charliteral">&#39;d&#39;</span>) == 1);     <span class="comment">//          if vectors differ d ==1</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, NULL, <span class="charliteral">&#39;m&#39;</span>) == 4.);  <span class="comment">//length of v1, Manhattan metric</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2) == 5.);          <span class="comment">//the hypotenuse of the 3-4-5 triangle</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v2, NULL, <span class="charliteral">&#39;s&#39;</span>) == 6);   <span class="comment">//length of v2, sup norm</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;m&#39;</span>) == 7.);     <span class="comment">//distance v1 to v2 in Manhattan</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;L&#39;</span>, 2) == 5.);  <span class="comment">//L_2 norm == Euclidean</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga032dcecb67155c527c884dd2c1cc6a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_exp </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace every vector element <img class="formulaInl" alt="$v_i$" src="form_21.png"/> with exp( <img class="formulaInl" alt="$v_i$" src="form_21.png"/>).</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5a622b8360eba63795a6049c30ac54a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_log </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the natural log of every element in a vector.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1a4a67e0b0bec8205cfe75bd3786c30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_log10 </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the log (base ten) of every element in a vector.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae603a7d511cf40b022f99dc69faa616a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_stack </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the first vector on top of the second vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the upper vector (default=<code>NULL</code>, in which case this basically copies <code>v2</code>) </td></tr>
    <tr><td class="paramname">v2</td><td>the second vector (default=<code>NULL</code>, in which case nothing is added) </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'y', use <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>v1</code> in place; see the caveats on that function. Otherwise, allocate a new vector, leaving <code>v1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stacked data, either in a new vector or a pointer to <code>v1</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf6182181dd424bc4de98b4bfbd349b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_vector_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the data in the given vector. </p>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Apr 20 2015.</div></body></html>

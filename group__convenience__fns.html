<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Things to make life easier with the GSL</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(in)&#160;&#160;&#160;<a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(in)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_rng *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> (int seed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> (gsl_vector *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> (gsl_vector *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> (gsl_vector *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gae603a7d511cf40b022f99dc69faa616a">apop_vector_stack</a> (gsl_vector *v1, gsl_vector *v2, char inplace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a> (gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> (const gsl_vector *in, long double max)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga7f85a98b61078ba3dc273f17eddd34a7"></a><!-- doxytag: member="apop.h::apop_sum" ref="ga7f85a98b61078ba3dc273f17eddd34a7" args="(in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(in)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An alias for <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>. Returns the sum of the data in the given vector. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga45bb322b9f491c46feb1e24025b6301f"></a><!-- doxytag: member="apop_conversions.c::apop_matrix_copy" ref="ga45bb322b9f491c46feb1e24025b6301f" args="(const gsl_matrix *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <code>gsl_matrix</code> to another. That is, all data is duplicated. Unlike <code>gsl_matrix_memcpy</code>, this function allocates and returns the destination, so you can use it like this:</p>
<div class="fragment"><pre class="fragment">gsl_matrix *a_copy = <a class="code" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a>(original);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill. If <code>gsl_matrix_alloc</code> fails, returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga040b9e9fea1abe105de86081bf396d40"></a><!-- doxytag: member="apop_stats.c::apop_matrix_mean" ref="ga040b9e9fea1abe105de86081bf396d40" args="(const gsl_matrix *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the mean of all elements of a matrix.</p>
<p>Calculated with an eye toward avoiding overflow errors.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. If <code>NULL</code>, return zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf794cc2491ef147e0c67eb05feed7a87"></a><!-- doxytag: member="apop_stats.c::apop_matrix_mean_and_var" ref="gaf794cc2491ef147e0c67eb05feed7a87" args="(const gsl_matrix *data, double *mean, double *var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the mean and population variance of all elements of a matrix.</p>
<ul>
<li>If you want sample variance, multiply the result returned by <code>(data-&gt;size1*data-&gt;size2)/(data-&gt;size1*data-&gt;size2-1.0)</code>.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. </td></tr>
    <tr><td class="paramname">mean</td><td>where to put the mean to be calculated. </td></tr>
    <tr><td class="paramname">var</td><td>where to put the variance to be calculated.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If <code>NULL</code>, return (zero, NaN). </li>
</ul>

</div>
</div>
<a class="anchor" id="gae50bc918e0d8b6ee913596f68ab731a8"></a><!-- doxytag: member="apop_linear_algebra.c::apop_matrix_stack" ref="gae50bc918e0d8b6ee913596f68ab731a8" args="(gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first matrix either on top of or to the right of the second matrix. The fn returns a new matrix, meaning that at the end of this function, until you gsl_matrix_free() the original matrices, you will be taking up twice as much memory. Plan accordingly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost matrix (default=<code>NULL</code>, in which case this basically copies <code>m2</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix (default = <code>NULL</code>, in which case <code>m1</code> is returned) </td></tr>
    <tr><td class="paramname">posn</td><td>if 'r', stack rows on top of other rows, else, e.g. 'c' stack columns next to columns. (default ='r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'y', use <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> to modify <code>m1</code> in place; see the caveats on that function. Otherwise, allocate a new matrix, leaving <code>m1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stacked data, either in a new matrix or a pointer to <code>m1</code>.</dd></dl>
<p>For example, here is a little function to merge four matrices into a single two-part-by-two-part matrix. The original matrices are unchanged. </p>
<div class="fragment"><pre class="fragment">gsl_matrix *apop_stack_two_by_two(gsl_matrix *ul, gsl_matrix *ur, gsl_matrix *dl, gsl_matrix *dr){
  gsl_matrix *output, *t;
    output = <a class="code" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a>(ul, ur, <span class="charliteral">&#39;c&#39;</span>);
    t = <a class="code" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a>(dl, dr, <span class="charliteral">&#39;c&#39;</span>);
    <a class="code" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a>(output, t, <span class="charliteral">&#39;r&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);
    gsl_matrix_free(t);
    <span class="keywordflow">return</span> output;
}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga369c774aac917e56d8e32f9c66d9c2a0"></a><!-- doxytag: member="apop_stats.c::apop_matrix_sum" ref="ga369c774aac917e56d8e32f9c66d9c2a0" args="(const gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sum of the elements of a matrix. Occasionally convenient.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to be summed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada044cf02135422a9f9292b6054c86dd"></a><!-- doxytag: member="apop_bootstrap.c::apop_rng_alloc" ref="gada044cf02135422a9f9292b6054c86dd" args="(int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_rng* <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a <code>gsl_rng</code>.</p>
<p>Uses the Tausworth routine.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed. No need to get funny with it: 0, 1, and 2 will produce wholly different streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The RNG ready for your use.</dd></dl>
<ul>
<li>If you are confident that your code is debugged and would like a new stream of values every time your program runs (provided your runs are more than a second apart), seed with the time:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>

<span class="keywordtype">int</span> main(){
    <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.rng_seed = time(NULL);
    <a class="code" href="group__apop__print.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(
            <a class="code" href="apop_8h.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(
                <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1), 
                .count=10, 
            )
    );
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ga136ded2b6d190739deca064701cf5ca1"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_bounded" ref="ga136ded2b6d190739deca064701cf5ca1" args="(const gsl_vector *in, long double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__convenience__fns.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test for a situation when a vector is diverging, so you can preempt a procedure that is about to break on infinite values.</p>
<p>Alternatively, set <code>max</code> to <code>INFINITY</code> (or <code>GSL_INF</code>) to just test whether all of the matrix's elements are finite.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> </td></tr>
    <tr><td class="paramname">max</td><td>An upper and lower bound to the elements of the vector. (default: GSL_POSINF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if everything is bounded: not Inf, -Inf, or NaN, and <img class="formulaInl" alt="$-\max < x < \max$" src="form_22.png"/>; zero otherwise.</dd></dl>
<ul>
<li>A <code>NULL</code> vector has no unbounded elements, so <code>NULL</code> input returns 1. You get a warning if <code>apop_opts.verbosity &gt;=1</code>. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5baf0e8717a30fdcfba350da904c1825"></a><!-- doxytag: member="apop_conversions.c::apop_vector_copy" ref="ga5baf0e8717a30fdcfba350da904c1825" args="(const gsl_vector *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <code>gsl_vector</code> to another. That is, all data is duplicated. Unlike <code>gsl_vector_memcpy</code>, this function allocates and returns the destination, so you can use it like this:</p>
<div class="fragment"><pre class="fragment"> gsl_vector *a_copy = <a class="code" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a>(original);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill. If <code>gsl_vector_alloc</code> fails, returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44a77f5e6867c627fd313f3f6e252ff8"></a><!-- doxytag: member="apop_stats.c::apop_vector_distance" ref="ga44a77f5e6867c627fd313f3f6e252ff8" args="(const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>ina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>inb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the distance between two vectors, where distance is defined based on the third (optional) parameter:</p>
<ul>
<li>'e' or 'E' (the default): scalar distance (standard Euclidean metric) between two vectors. Simply <img class="formulaInl" alt="$\sqrt{\sum_i{(a_i - b_i)^2}},$" src="form_64.png"/> where <img class="formulaInl" alt="$i$" src="form_65.png"/> iterates over dimensions.</li>
<li>'m' or 'M' Returns the Manhattan metric distance between two vectors: <img class="formulaInl" alt="$\sum_i{|a_i - b_i|},$" src="form_66.png"/> where <img class="formulaInl" alt="$i$" src="form_65.png"/> iterates over dimensions.</li>
<li>'d' or 'D' The discrete norm: if <img class="formulaInl" alt="$a = b$" src="form_67.png"/>, return zero, else return one.</li>
<li>'s' or 'S' The sup norm: find the dimension where <img class="formulaInl" alt="$|a_i - b_i|$" src="form_68.png"/> is largest, return the distance along that one dimension.</li>
<li>'l' or 'L' The <img class="formulaInl" alt="$L_p$" src="form_69.png"/> norm, <img class="formulaInl" alt="$\left(\sum_i{(a_i - b_i)^2}\right)^{1/p},$" src="form_70.png"/>. The value of <img class="formulaInl" alt="$p$" src="form_19.png"/> is set by the fourth (optional) argument.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ina</td><td>First vector (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">inb</td><td>Second vector (Default = zero) </td></tr>
    <tr><td class="paramname">metric</td><td>The type of metric, as above. </td></tr>
    <tr><td class="paramname">norm</td><td>If you are using an <img class="formulaInl" alt="$L_p$" src="form_69.png"/> norm, this is <img class="formulaInl" alt="$p$" src="form_19.png"/>. Must be strictly greater than zero. (default = 2)</td></tr>
  </table>
  </dd>
</dl>
<p>Notice that the defaults are such that </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v);
 <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v, .metric = <span class="charliteral">&#39;s&#39;</span>);
</pre></div><p> gives you the standard Euclidean length of <code>v</code> and its longest element.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="comment">/* Test distance calculations using a 3-4-5 triangle */</span>
<span class="keywordtype">int</span> main(){
    gsl_vector *v1 = gsl_vector_alloc(2);
    gsl_vector *v2 = gsl_vector_alloc(2);
    gsl_vector_set(v1, 0,2);
    gsl_vector_set(v1, 1,2);
    gsl_vector_set(v2, 0,5);
    gsl_vector_set(v2, 1,6);
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v1, <span class="charliteral">&#39;d&#39;</span>) == 0);     <span class="comment">//discrete: if vectors are equal d==0;</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v2, <span class="charliteral">&#39;d&#39;</span>) == 1);     <span class="comment">//          if vectors differ d ==1</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, NULL, <span class="charliteral">&#39;m&#39;</span>) == 4.);  <span class="comment">//length of v1, Manhattan metric</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2) == 5.);          <span class="comment">//the hypotenuse of the 3-4-5 triangle</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v2, NULL, <span class="charliteral">&#39;s&#39;</span>) == 6);   <span class="comment">//length of v2, sup norm</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;m&#39;</span>) == 7.);     <span class="comment">//distance v1 to v2 in Manhattan</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;L&#39;</span>, 2) == 5.);  <span class="comment">//L_2 norm == Euclidean</span>
}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga032dcecb67155c527c884dd2c1cc6a6e"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_exp" ref="ga032dcecb67155c527c884dd2c1cc6a6e" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__convenience__fns.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace every vector element <img class="formulaInl" alt="$v_i$" src="form_21.png"/> with exp( <img class="formulaInl" alt="$v_i$" src="form_21.png"/>).</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5a622b8360eba63795a6049c30ac54a2"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_log" ref="ga5a622b8360eba63795a6049c30ac54a2" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__convenience__fns.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take the natural log of every element in a vector.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1a4a67e0b0bec8205cfe75bd3786c30e"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_log10" ref="ga1a4a67e0b0bec8205cfe75bd3786c30e" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__convenience__fns.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take the log (base ten) of every element in a vector.</p>
<ul>
<li>If the input vector is <code>NULL</code>, do nothing. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae603a7d511cf40b022f99dc69faa616a"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_stack" ref="gae603a7d511cf40b022f99dc69faa616a" args="(gsl_vector *v1, gsl_vector *v2, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="group__convenience__fns.html#gae603a7d511cf40b022f99dc69faa616a">apop_vector_stack</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first vector on top of the second vector.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the upper vector (default=<code>NULL</code>, in which case this basically copies <code>v2</code>) </td></tr>
    <tr><td class="paramname">v2</td><td>the second vector (default=<code>NULL</code>, in which case nothing is added) </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'y', use <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>v1</code> in place; see the caveats on that function. Otherwise, allocate a new vector, leaving <code>v1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stacked data, either in a new vector or a pointer to <code>v1</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf6182181dd424bc4de98b4bfbd349b4e"></a><!-- doxytag: member="apop_stats.c::apop_vector_sum" ref="gaf6182181dd424bc4de98b4bfbd349b4e" args="(const gsl_vector *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sum of the data in the given vector. </p>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Sep 22 2014.</div></body></html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Implementation of optional arguments </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Optional and named arguments are among the most commonly commented-on features of Apophenia, so this page goes into full detail about the implementation.</p>
<p>To use these features, see the all-you-really-need summary at the <a class="el" href="designated.html">Designated initializers</a> page. For a background and rationale, see the blog entry at <a href="http://modelingwithdata.org/arch/00000022.htm">http://modelingwithdata.org/arch/00000022.htm</a> .</p>
<p>I'll assume you've read both links before continuing.</p>
<p>OK, now that you've read the how-to-use and the discussion of how optional and named arguments can be constructed in C, this page will show how they are done in Apophenia. The level of details should be sufficient to implement them in your own code if you so desire.</p>
<p>There are three components to the process of generating optional arguments as implemented here: </p>
<ul>
<li>Produce a <code>struct</code> whose elements match the arguments to the function. </li>
<li>Write a wrapper function that takes in the struct, unpacks it, and calls the original function. </li>
<li>Write a macro that makes the user think the wrapper function is the real thing.</li>
</ul>
<p>None of these steps are really rocket science, but there is a huge amount of redundancy. Apophenia includes some macros that reduce the boilerplate redundancy significantly. There are two layers: the C-standard code, and the script that produces the C-standard code.</p>
<p>We'll begin with the C-standard header file: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifdef APOP_NO_VARIADIC</span>
<span class="preprocessor"></span> <span class="keywordtype">void</span> apop_vector_increment(gsl_vector * v, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> amt);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span> <span class="keywordtype">void</span> apop_vector_increment_base(gsl_vector * v, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> amt);
 apop_varad_declare(<span class="keywordtype">void</span>, apop_vector_increment, gsl_vector * v; <span class="keywordtype">int</span> i; <span class="keywordtype">double</span> amt);
<span class="preprocessor">#define apop_vector_increment(...) apop_varad_link(apop_vector_increment, __VA_ARGS__)</span>
<span class="preprocessor">#endif</span>
</pre></div><p>First, there is an if/else that allows the system to degrade gracefully if you are sending C code to a parser like swig, whose goals differ too much from straight C compilation for this to work. Just set <code>APOP_NO_VARIADIC</code> to produce a plain function with no variadic support.</p>
<p>Else, we begin the above steps. The <code>apop_varad_declare</code> line expands to the following:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ 
    gsl_vector * v; <span class="keywordtype">int</span> i; <span class="keywordtype">double</span> amt ; 
} variadic_type_apop_vector_increment; 

<span class="keywordtype">void</span> variadic_apop_vector_increment(variadic_type_apop_vector_increment varad_in);
</pre></div><p>So there's the ad-hoc struct and the declaration for the wrapper function. Notice how the arguments to the macro had semicolons, like a struct declaration, rather than commas, because the macro does indeed wrap the arguments into a struct.</p>
<p>Here is what the <code>apop_varad_link</code> would expand to: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define apop_vector_increment(...) variadic_apop_increment_base((variadic_type_apop_vector_increment) {__VA_ARGS__})</span>
</pre></div><p> That gives us part three: a macro that lets the user think that they are making a typical function call with a set of arguments, but wraps what they type into a struct.</p>
<p>Now for the code file where the function is declared. Again, there is is an <code>APOP_NO_VARIADIC</code> wrapper. Inside the interesting part, we find the wrapper function to unpack the struct that comes in.</p>
<div class="fragment"><pre class="fragment">\#ifdef APOP_NO_VARIADIC 
 <span class="keywordtype">void</span> apop_vector_increment(gsl_vector * v, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> amt){
\#<span class="keywordflow">else</span>
apop_varad_head( <span class="keywordtype">void</span> , apop_vector_increment){
    gsl_vector * apop_varad_var(v, NULL);
    Apop_assert(v, <span class="stringliteral">&quot;You sent me a NULL vector.&quot;</span>);
    <span class="keywordtype">int</span> apop_varad_var(i, 0);
    <span class="keywordtype">double</span> apop_varad_var(amt, 1);
    apop_vector_increment_base(v, i, amt);
}

 <span class="keywordtype">void</span> apop_vector_increment_base(gsl_vector * v, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> amt){
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>     v-&gt;data[i * v-&gt;stride]   += amt;
}
</pre></div><p>The <code>apop_varad_head</code> macro just reduces redundancy, and will expand to </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> variadic_apop_vector_increment (variadic_type_variadic_apop_vector_increment varad_in)
</pre></div><p>The function with this header thus takes in a single struct, and for every variable, there is a line like </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> apop_varad_var(amt, 1);
</pre></div><p> which simply expands to: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> amt = varad_in.amt ? varad_in.amt : 1;
</pre></div><p> Thus, the macro declares each not-in-struct variable, and so there will need to be one such declaration line for each argument. Apart from requiring declarations, you can be creative: include sanity checks, post-vary the variables of the inputs, unpack without the macro, and so on. That is, this parent function does all of the bookkeeping, checking, and introductory shunting, so the base function can just do the math. Finally, the introductory section will call the base function.</p>
<p>The setup goes out of its way to leave the <code>_base</code> function in the public namespace, so that those who would prefer speed to bounds-checking can simply call that function directly, using standard notation. You could eliminate this feature by just merging the two functions.</p>
<p><b>The m4 script</b></p>
<p>The above is all you need to make this work: the varad.h file, and the above structures. But there is still a lot of redundancy, which can't be eliminated by the plain C preprocessor.</p>
<p>Thus, in Apophenia's code base (the one you'll get from checking out the git repository, not the gzipped distribution that has already been post-processed) you will find a pre-preprocessing script that converts a few markers to the above form. Here is the code that will expand to the above C-standard code:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//header file</span>
APOP_VAR_DECLARE <span class="keywordtype">void</span> apop_vector_increment(gsl_vector * v, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> amt);

<span class="comment">//code file</span>
APOP_VAR_HEAD <span class="keywordtype">void</span> apop_vector_increment(gsl_vector * v, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> amt){
    gsl_vector * apop_varad_var(v, NULL);
    Apop_assert(v, <span class="stringliteral">&quot;You sent me a NULL vector.&quot;</span>);
    <span class="keywordtype">int</span> apop_varad_var(i, 0);
    <span class="keywordtype">double</span> apop_varad_var(amt, 1);
APOP_VAR_END_HEAD
     v-&gt;data[i * v-&gt;stride]   += amt;
}
</pre></div><p>It is obviously much shorter. The declaration line is actually a C-standard declaration with the <code>APOP_VAR_DECLARE</code> preface, so you don't have to remember when to use semicolons. The function itself looks like a single function, but there is again a marker before the declaration line, and the introductory material is separated from the main matter by the <code>APOP_VAR_END_HEAD</code> line. Done right, drawing a line between the introductory checks or initializations and the main function can really improve readability.</p>
<p>The m4 script inserts a <code>return function_base(...)</code> at the end of the header function, so you don't have to. If you want to call the funtion before the last line, you can do so explicitly, as in the expansion above, and add a bare <code>return;</code> to guarantee that the call to the base function that the m4 script will insert won't ever be reached.</p>
<p>One final detail: it is valid to have types with commas in them---function arguments. Because commas get turned to semicolons, and m4 isn't a real parser, there is an exception built in: you will have to replace commas with exclamation marks in the header file (only). E.g.,</p>
<div class="fragment"><pre class="fragment">APOP_VAR_DECLARE <a class="code" href="structapop__data.html">apop_data</a> * f_of_f(<a class="code" href="structapop__data.html">apop_data</a> *in, <span class="keywordtype">void</span> *param, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> (*fn_d)(<span class="keywordtype">double</span> ! <span class="keywordtype">void</span> * !<span class="keywordtype">int</span>));
</pre></div><p>m4 is POSIX standard, so even if you can't read the script, you have the program needed to run it. For example, if you name it <code>prep_variadics.m4</code>, then run </p>
<div class="fragment"><pre class="fragment">m4 prep_variadics.m4 myfile.m4.c &gt; myfile.c
</pre></div> </div></div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Apr 20 2015.</div></body></html>

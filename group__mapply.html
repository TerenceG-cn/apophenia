<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Map or apply a function to a vector or matrix</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, apop_fn_d *fn_d, apop_fn_v *fn_v, apop_fn_r *fn_r, apop_fn_dp *fn_dp, apop_fn_vp *fn_vp, apop_fn_rp *fn_rp, apop_fn_dpi *fn_dpi, apop_fn_vpi *fn_vpi, apop_fn_rpi *fn_rpi, apop_fn_di *fn_di, apop_fn_vi *fn_vi, apop_fn_ri *fn_ri, void *param, int inplace, char part, int all_pages)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> (const gsl_matrix *m, double(*fn)(gsl_vector *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga5c4ae58b861199bbc1a460719942d98f">apop_matrix_apply</a> (gsl_matrix *m, void(*fn)(gsl_vector *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gaf30eadf8772ecb9a2689ddf104902ea4">apop_vector_map</a> (const gsl_vector *v, double(*fn)(double))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a> (gsl_vector *v, void(*fn)(double *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gab1df9cb7fdd56e48593d99f5122224d7">apop_matrix_map_all</a> (const gsl_matrix *in, double(*fn)(double))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga163589e9f5cb08f88f2032fc1229ec6f">apop_matrix_apply_all</a> (gsl_matrix *in, void(*fn)(double *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gaa1a135fcdd8ea6f9cbc0d518773d6c3c">apop_vector_map_sum</a> (const gsl_vector *in, double(*fn)(double))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gae04bc576579bfb2e14d5004d4af7bb88">apop_matrix_map_all_sum</a> (const gsl_matrix *in, double(*fn)(double))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga4f0c51a046140b563c8e12a6032e9a16">apop_matrix_map_sum</a> (const gsl_matrix *in, double(*fn)(gsl_vector *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, apop_fn_d *fn_d, apop_fn_v *fn_v, apop_fn_r *fn_r, apop_fn_dp *fn_dp, apop_fn_vp *fn_vp, apop_fn_rp *fn_rp, apop_fn_dpi *fn_dpi, apop_fn_vpi *fn_vpi, apop_fn_rpi *fn_rpi, apop_fn_di *fn_di, apop_fn_vi *fn_vi, apop_fn_ri *fn_ri, void *param, char part, int all_pages)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>These functions will pull each element of a vector or matrix, or each row of a matrix, and apply a function to the given element. See the data-&gt;map/apply section of the <a class="el" href="outline.html#outline_mapply">outline</a> for many examples.</p>
<p>There are two types, which were developed at different times. The <a class="el" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> and <a class="el" href="group__mapply.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> functions use variadic function inputs to cover a lot of different types of process depending on the inputs. Other functions with types in their names, like <a class="el" href="group__mapply.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> and <a class="el" href="group__mapply.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a>, may be easier to use in some cases. With one exception, they use the same guts, so use whichever type is convenient.</p>
<p>Here are a few technical details of usage:</p>
<ul>
<li>If <code>apop_opts.thread_count</code> is greater than one, then the matrix will be broken into chunks and each sent to a different thread. Notice that the GSL is generally threadsafe, and SQLite is threadsafe conditional on several commonsense caveats that you'll find in the SQLite documentation.</li>
</ul>
<ul>
<li>Apart from <a class="el" href="group__mapply.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> (which does minimal internal allocation), the <code></code>...sum functions are convenience functions that just call <code></code>...map and then add up the contents. Thus, you will need to have adequate memory for the allocation of the temp matrix/vector. </li>
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaacff3707e418a067104c77c410b43f69"></a><!-- doxytag: member="apop_mapply.c::apop_map" ref="gaacff3707e418a067104c77c410b43f69" args="(apop_data *in, apop_fn_d *fn_d, apop_fn_v *fn_v, apop_fn_r *fn_r, apop_fn_dp *fn_dp, apop_fn_vp *fn_vp, apop_fn_rp *fn_rp, apop_fn_dpi *fn_dpi, apop_fn_vpi *fn_vpi, apop_fn_rpi *fn_rpi, apop_fn_di *fn_di, apop_fn_vi *fn_vi, apop_fn_ri *fn_ri, void *param, int inplace, char part, int all_pages)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_d *&#160;</td>
          <td class="paramname"><em>fn_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_v *&#160;</td>
          <td class="paramname"><em>fn_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_r *&#160;</td>
          <td class="paramname"><em>fn_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dp *&#160;</td>
          <td class="paramname"><em>fn_dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vp *&#160;</td>
          <td class="paramname"><em>fn_vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rp *&#160;</td>
          <td class="paramname"><em>fn_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dpi *&#160;</td>
          <td class="paramname"><em>fn_dpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vpi *&#160;</td>
          <td class="paramname"><em>fn_vpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rpi *&#160;</td>
          <td class="paramname"><em>fn_rpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_di *&#160;</td>
          <td class="paramname"><em>fn_di</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vi *&#160;</td>
          <td class="paramname"><em>fn_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ri *&#160;</td>
          <td class="paramname"><em>fn_ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a function to every element of a data set, matrix or vector; or, apply a vector-taking function to every row or column of a matrix.</p>
<p>There are a lot of options: your function could take any combination of a <code>gsl_vector</code>, a <code>double</code>, an <a class="el" href="gentle.html#apop_data">apop_data</a>, a parameter set, and the position of the element in the vector or matrix. As such, the function takes twelve function inputs, one for each combination of vector/matrix, params/no params, index/no index. Fortunately, because this function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs, you will specify only one.</p>
<p>For example, here is a function that will cut off each element of the input data to between <img class="formulaInl" alt="$(-1, +1)$" src="form_40.png"/>. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">double</span> cutoff(<span class="keywordtype">double</span> in, <span class="keywordtype">void</span> *limit_in){ 
    <span class="keywordtype">double</span> *limit = limit_in;
    <span class="keywordflow">return</span> GSL_MAX(-*limit, GSL_MIN(*limit, in)); 
}

<span class="keywordtype">double</span> param = 1;
<a class="code" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>(your_data, .fn_dp=cutoff, .param=&amp;param, .inplace=<span class="charliteral">&#39;y&#39;</span>);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fn_v</td><td>A function of the form <code>double your_fn(gsl_vector *in)</code> </td></tr>
    <tr><td class="paramname">fn_d</td><td>A function of the form <code>double your_fn(double in)</code> </td></tr>
    <tr><td class="paramname">fn_r</td><td>A function of the form <code>double your_fn(apop_data *in)</code> </td></tr>
    <tr><td class="paramname">fn_vp</td><td>A function of the form <code>double your_fn(gsl_vector *in, void *param)</code> </td></tr>
    <tr><td class="paramname">fn_dp</td><td>A function of the form <code>double your_fn(double in, void *param)</code> </td></tr>
    <tr><td class="paramname">fn_rp</td><td>A function of the form <code>double your_fn(apop_data *in, void *param)</code> </td></tr>
    <tr><td class="paramname">fn_vpi</td><td>A function of the form <code>double your_fn(gsl_vector *in, void *param, int index)</code> </td></tr>
    <tr><td class="paramname">fn_dpi</td><td>A function of the form <code>double your_fn(double in, void *param, int index)</code> </td></tr>
    <tr><td class="paramname">fn_rpi</td><td>A function of the form <code>double your_fn(apop_data *in, void *param, int index)</code> </td></tr>
    <tr><td class="paramname">fn_vi</td><td>A function of the form <code>double your_fn(gsl_vector *in, int index)</code> </td></tr>
    <tr><td class="paramname">fn_di</td><td>A function of the form <code>double your_fn(double in, int index)</code> </td></tr>
    <tr><td class="paramname">fn_ri</td><td>A function of the form <code>double your_fn(apop_data *in, int index)</code></td></tr>
    <tr><td class="paramname">in</td><td>The input data set. If <code>NULL</code>, I'll return <code>NULL</code> immediately. </td></tr>
    <tr><td class="paramname">param</td><td>A pointer to the parameters to be passed to those function forms taking a <code>*param</code>.</td></tr>
    <tr><td class="paramname">part</td><td>Which part of the <code><a class="el" href="structapop__data.html">apop_data</a></code> struct should I use?<br/>
 'v'==Just the vector<br/>
 'm'==Every element of the matrix, in turn<br/>
 'a'==Both 'v' and 'm'<br/>
 'r'==Apply a function <code>gsl_vector</code> <img class="formulaInl" alt="$\to$" src="form_41.png"/> <code>double</code> to each row of the matrix<br/>
 'c'==Apply a function <code>gsl_vector</code> <img class="formulaInl" alt="$\to$" src="form_41.png"/> <code>double</code> to each column of the matrix<br/>
 Default is 'a', but notice that I'll ignore a <code>NULL</code> vector or matrix, so if your data set has only a vector (for example), that's what I'll use.</td></tr>
    <tr><td class="paramname">all_pages</td><td>If <code>'y'</code>, then I follow the <code>more</code> pointer to subsequent pages, else I handle only the first page of data. [I abuse this for an internal semaphore, by the way, so your input must always be nonnegative and less than 1,000. Of course, 'y' and 'n' fit these rules fine.] Default: <code>'n'</code>.</td></tr>
    <tr><td class="paramname">inplace</td><td>If 'n' (the default), generate a new <a class="el" href="gentle.html#apop_data">apop_data</a> set for output, which will contain the mapped values (and the names from the original set).<br/>
 If 'y', modify in place. The <code>double</code> <img class="formulaInl" alt="$\to$" src="form_41.png"/> <code>double</code> versions, <code>'v'</code>, <code>'m'</code>, and <code>'a'</code>, write to exactly the same location as before. The <code>gsl_vector</code> <img class="formulaInl" alt="$\to$" src="form_41.png"/> <code>double</code> versions, <code>'r'</code>, and <code>'c'</code>, will write to the vector. Be careful: if you are writing in place and there is already a vector there, then the original vector is lost.<br/>
 If 'v' (as in void), return <code>NULL</code>. (Default = 'n')</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>The function forms with <code>r</code> in them, like <code>fn_ri</code>, are row-by-row. I'll use <a class="el" href="apop_8h.html#a401dbc60c9915be8e4c4def68b22d755">Apop_r</a> to get each row in turn, and send it to the function. The first implication is that your function should be expecting a <a class="el" href="gentle.html#apop_data">apop_data</a> set with exactly one row in it. The second is that <code>part</code> is ignored: it only makes sense to go row-by-row.</li>
</ul>
<ul>
<li>If you set <code>inplace='y'</code>, then you will be modifying your input data set, row by row; if you set <code>inplace='n'</code>, then I will return an <a class="el" href="gentle.html#apop_data">apop_data</a> set whose <code>vector</code> element is as long as your data set (i.e., as long as the longest of your text, vector, or matrix parts).</li>
</ul>
<ul>
<li>If you set <code>apop_opts.thread_count</code> to a value greater than one, I will split the data set into as many chunks as you specify, and process them simultaneously. You need to watch out for the usual hang-ups about multithreaded programming, but if your data is iid, and each row's processing is independent of the others, you should have no problems. Bear in mind that generating threads takes some small overhead, so simple cases like adding a few hundred numbers will actually be slower when threading.</li>
</ul>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='p'</td><td>missing or mismatched parts error, such as <code>NULL</code> matrix when you sent a function acting on the matrix element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30601e357a1e21648f8d8db3c9ed6f3a"></a><!-- doxytag: member="apop_mapply.c::apop_map_sum" ref="ga30601e357a1e21648f8d8db3c9ed6f3a" args="(apop_data *in, apop_fn_d *fn_d, apop_fn_v *fn_v, apop_fn_r *fn_r, apop_fn_dp *fn_dp, apop_fn_vp *fn_vp, apop_fn_rp *fn_rp, apop_fn_dpi *fn_dpi, apop_fn_vpi *fn_vpi, apop_fn_rpi *fn_rpi, apop_fn_di *fn_di, apop_fn_vi *fn_vi, apop_fn_ri *fn_ri, void *param, char part, int all_pages)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__mapply.html#ga30601e357a1e21648f8d8db3c9ed6f3a">apop_map_sum</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_d *&#160;</td>
          <td class="paramname"><em>fn_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_v *&#160;</td>
          <td class="paramname"><em>fn_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_r *&#160;</td>
          <td class="paramname"><em>fn_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dp *&#160;</td>
          <td class="paramname"><em>fn_dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vp *&#160;</td>
          <td class="paramname"><em>fn_vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rp *&#160;</td>
          <td class="paramname"><em>fn_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_dpi *&#160;</td>
          <td class="paramname"><em>fn_dpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vpi *&#160;</td>
          <td class="paramname"><em>fn_vpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_rpi *&#160;</td>
          <td class="paramname"><em>fn_rpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_di *&#160;</td>
          <td class="paramname"><em>fn_di</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_vi *&#160;</td>
          <td class="paramname"><em>fn_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ri *&#160;</td>
          <td class="paramname"><em>fn_ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function that effectively calls <a class="el" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> and returns the sum of the resulting elements. Thus, this function returns a single <code>double</code>. See the <a class="el" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> page for details of the inputs, which are the same here, except that <code>inplace</code> doesn't make sense---this function will always just add up the input function outputs.</p>
<p>See also the <a class="el" href="group__mapply.html">map/apply page</a> for details.</p>
<ul>
<li>I don't copy the input data to send to your input function. Therefore, if your function modifies its inputs as a side-effect, your data set will be modified as this function runs.</li>
</ul>
<ul>
<li>The sum of zero elements is zero, so that is what is returned if the input <a class="el" href="gentle.html#apop_data">apop_data</a> set is <code>NULL</code>. If <code>apop_opts.verbose &gt;= 2</code> I print a warning. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5c4ae58b861199bbc1a460719942d98f"></a><!-- doxytag: member="apop_mapply.c::apop_matrix_apply" ref="ga5c4ae58b861199bbc1a460719942d98f" args="(gsl_matrix *m, void(*fn)(gsl_vector *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mapply.html#ga5c4ae58b861199bbc1a460719942d98f">apop_matrix_apply</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(gsl_vector *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a function to every row of a matrix. The function that you input takes in a gsl_vector and returns nothing. <code>apop_matrix_apply</code> will produce a vector view of each row, and send each row to your function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>void fn(gsl_vector* in)</code></td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the matrix is <code>NULL</code>, this is a no-op and returns immediately. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga163589e9f5cb08f88f2032fc1229ec6f"></a><!-- doxytag: member="apop_mapply.c::apop_matrix_apply_all" ref="ga163589e9f5cb08f88f2032fc1229ec6f" args="(gsl_matrix *in, void(*fn)(double *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mapply.html#ga163589e9f5cb08f88f2032fc1229ec6f">apop_matrix_apply_all</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies a function to every element in a matrix (as opposed to every row)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix whose elements will be inputs to the function </td></tr>
    <tr><td class="paramname">fn</td><td>A function with a form like <code>void f(double *in)</code> which will modify the data at the in-pointer in place.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the matrix is <code>NULL</code>, this is a no-op and returns immediately. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga5da5091a11c37d3501d678b8ecec466f"></a><!-- doxytag: member="apop_mapply.c::apop_matrix_map" ref="ga5da5091a11c37d3501d678b8ecec466f" args="(const gsl_matrix *m, double(*fn)(gsl_vector *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="group__mapply.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(gsl_vector *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Map a function onto every row of a matrix. The function that you input takes in a gsl_vector and returns a <code>double</code>. <code>apop_matrix_map</code> will produce a vector view of each row, and send each row to your function. It will output a <code>gsl_vector</code> holding your function's output for each row.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>double fn(gsl_vector* in)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>gsl_vector</code> with the corresponding value for each row.</dd></dl>
<ul>
<li>If you input a <code>NULL</code> matrix, I return <code>NULL</code>. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="gab1df9cb7fdd56e48593d99f5122224d7"></a><!-- doxytag: member="apop_mapply.c::apop_matrix_map_all" ref="gab1df9cb7fdd56e48593d99f5122224d7" args="(const gsl_matrix *in, double(*fn)(double))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="group__mapply.html#gab1df9cb7fdd56e48593d99f5122224d7">apop_matrix_map_all</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maps a function to every element in a matrix (as opposed to every row)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix whose elements will be inputs to the function </td></tr>
    <tr><td class="paramname">fn</td><td>A function with a form like <code>double f(double in)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a matrix of the same size as the original, with the function applied.</dd></dl>
<ul>
<li>If you input a <code>NULL</code> matrix, I return <code>NULL</code>. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae04bc576579bfb2e14d5004d4af7bb88"></a><!-- doxytag: member="apop_mapply.c::apop_matrix_map_all_sum" ref="gae04bc576579bfb2e14d5004d4af7bb88" args="(const gsl_matrix *in, double(*fn)(double))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__mapply.html#gae04bc576579bfb2e14d5004d4af7bb88">apop_matrix_map_all_sum</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <code>apop_matrix_map_all</code>, but returns the sum of the resulting mapped function. For example, <code>apop_matrix_map_all_sum(v, isnan)</code> returns the number of elements of <code>m</code> that are <code>NaN</code>.</p>
<ul>
<li>If you input a <code>NULL</code> matrix, I return the sum of zero items: zero. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga4f0c51a046140b563c8e12a6032e9a16"></a><!-- doxytag: member="apop_mapply.c::apop_matrix_map_sum" ref="ga4f0c51a046140b563c8e12a6032e9a16" args="(const gsl_matrix *in, double(*fn)(gsl_vector *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__mapply.html#ga4f0c51a046140b563c8e12a6032e9a16">apop_matrix_map_sum</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(gsl_vector *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <code>apop_matrix_map</code>, but returns the sum of the resulting mapped vector. For example, let <code>log_like</code> be a function that returns the log likelihood of an input vector; then <code>apop_matrix_map_sum(m, log_like)</code> returns the total log likelihood of the rows of <code>m</code>.</p>
<ul>
<li>If you input a <code>NULL</code> matrix, I return the sum of zero items: zero. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga51964750c64d327e52e2230019e44f66"></a><!-- doxytag: member="apop_mapply.c::apop_vector_apply" ref="ga51964750c64d327e52e2230019e44f66" args="(gsl_vector *v, void(*fn)(double *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mapply.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double *)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a function to every row of a matrix. The function that you input takes in a gsl_vector and returns nothing. <code>apop_apply</code> will send a pointer to each element of your vector to your function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>void fn(double in)</code></td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the vector is <code>NULL</code>, this is a no-op and returns immediately. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaf30eadf8772ecb9a2689ddf104902ea4"></a><!-- doxytag: member="apop_mapply.c::apop_vector_map" ref="gaf30eadf8772ecb9a2689ddf104902ea4" args="(const gsl_vector *v, double(*fn)(double))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="group__mapply.html#gaf30eadf8772ecb9a2689ddf104902ea4">apop_vector_map</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Map a function onto every element of a vector. The function that you input takes in a <code>double</code> and returns a <code>double</code>. <code>apop_apply</code> will send each element to your function, and will output a <code>gsl_vector</code> holding your function's output for each row.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector </td></tr>
    <tr><td class="paramname">fn</td><td>A function of the form <code>double fn(double in)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>gsl_vector</code> (allocated by this function) with the corresponding value for each row.</dd></dl>
<ul>
<li>If you input a <code>NULL</code> vector, I return <code>NULL</code>. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
<a class="anchor" id="gaa1a135fcdd8ea6f9cbc0d518773d6c3c"></a><!-- doxytag: member="apop_mapply.c::apop_vector_map_sum" ref="gaa1a135fcdd8ea6f9cbc0d518773d6c3c" args="(const gsl_vector *in, double(*fn)(double))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__mapply.html#gaa1a135fcdd8ea6f9cbc0d518773d6c3c">apop_vector_map_sum</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <code>apop_vector_map</code>, but returns the sum of the resulting mapped function. For example, <code>apop_vector_map_sum(v, isnan)</code> returns the number of elements of <code>v</code> that are <code>NaN</code>.</p>
<ul>
<li>If you input a <code>NULL</code> vector, I return the sum of zero items: zero. </li>
<li>See <a class="el" href="group__mapply.html">the map/apply page</a> for details. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Sun Sep 7 2014.</div></body></html>

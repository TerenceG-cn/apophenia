<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Maximum likelihood estimation</div>  </div>
</div><!--header-->
<div class="contents">
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>void <a class="el" href="group__mle.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *dist)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> (<a class="el" href="structapop__model.html">apop_model</a> *e, <a class="el" href="structapop__model.html">apop_model</a> *copy, char *starting_pt, double boundary)
</ul>


<h3><a class="anchor" id="simanneal"></a>Notes on simulated annealing</h3><div class="textblock"><p>Simulated annealing is a controlled random walk. As with the other methods, the system tries a new point, and if it is better, switches. Initially, the system is allowed to make large jumps, and then with each iteration, the jumps get smaller, eventually converging. Also, there is some decreasing probability that if the new point is {<em>less}</em> likely, it will still be chosen. Simulated annealing is best for situations where there may be multiple local optima. Early in the random walk, the system can readily jump from one to another; later it will fine-tune its way toward the optimum. The number of points tested is basically not dependent on the function: if you give it a 4,000 step program, that is basically how many steps it will take. If you know your function is globally convex (as are most standard probability functions), then this method is overkill.</p>
<p>The GSL's simulated annealing system doesn't actually do very much. It basically provides a for loop that calls a half-dozen functions that we the users get to write. So, the file <a class="el" href="apop__mle_8c.html">apop_mle.c</a> handles all of this for you. The likelihood function is taken from the model, the metric is the Manhattan metric, the copy/destroy functions are just the usual vector-handling fns., et cetera. The reader who wants further control is welcome to override these functions.</p>
<p>Verbosity: if ep-&gt;verbose==1, show likelihood, temp, &amp;c. in a table; if ep-&gt;verbose&gt;1, show that plus the vector of params. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6d5e39c00012de5b51cd49ce1ffd31fe"></a><!-- doxytag: member="apop_mle.c::apop_estimate_restart" ref="ga6d5e39c00012de5b51cd49ce1ffd31fe" args="(apop_model *e, apop_model *copy, char *starting_pt, double boundary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>starting_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The simplest use of this function is to restart a model at the latest parameter estimates.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__model.html">apop_model</a> *m = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(data, model_using_an_MLE_search);
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; 10; i++)
    m = <a class="code" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a>(m);
<a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(m);
</pre></div><p>By adding a line to reduce the tolerance each round [e.g., <code>Apop_settings_set(m, apop_mle, tolerance, pow(10,-i))</code>], you can start broad and hone in on a precise optimum.</p>
<p>You may have a new estimation method, such as first doing a coarse simulated annealing search, then a fine conjugate gradient search. When reading this example, recall that the form for adding a new settings group differs from the form for modifying existing settings: </p>
<div class="fragment"><pre class="fragment">Apop_model_add_settings(your_base_model, apop_mle, .method=APOP_SIMAN);
<a class="code" href="structapop__model.html">apop_model</a> *m = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(data, your_base_model);
<a class="code" href="group__settings.html#ga8659282b6003f7c2adac6f4baad5fae4">Apop_settings_set</a>(m, apop_mle, method, APOP_CG_PR);
m = <a class="code" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a>(m);
<a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(m);
</pre></div><p>Only one estimate is returned, either the one you sent in or a new one. The loser (which may be the one you sent in) is freed. That is, there is no memory leak in the above loop.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An <a class="el" href="structapop__model.html">apop_model</a> that is the output from a prior MLE estimation. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">copy</td><td>Another not-yet-parametrized model that will be re-estimated with (1) the same data and (2) a <code>starting_pt</code> as per the next setting (probably to the parameters of <code>e</code>). If this is <code>NULL</code>, then copy <code>e</code>. (Default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">starting_pt</td><td>"ep"=last estimate of the first model (i.e., its current parameter estimates); "es"= starting point originally used by the first model; "np"=current parameters of the new (second) model; "ns"=starting point specified by the new model's MLE settings. (default = "ep") </td></tr>
    <tr><td class="paramname">boundary</td><td>I test whether the starting point you give me is outside this certain bound, so I can warn you if there's divergence in your sequence of re-estimations. (default: 1e8)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>At the end of this procedure, we'll have two <a class="el" href="structapop__model.html">apop_model</a> structs: the one you sent in, and the one produced using the new method/scale. If the new estimate includes any NaNs/Infs, then the old estimate is returned (even if the old estimate included NaNs/Infs). Otherwise, the estimate with the largest log likelihood is returned.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="gae9f092d1786034dd2ab22c63de5c955c"></a><!-- doxytag: member="apop_mle.c::apop_maximum_likelihood" ref="gae9f092d1786034dd2ab22c63de5c955c" args="(apop_data *data, apop_model *dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mle.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The maximum likelihood calculations.</p>
<ul>
<li>I assume that <code>apop_prep</code> has been called on your model. The easiest way to guarantee this is to use <a class="el" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>, which calls this function if the input model has no <code>estimate</code> method.</li>
</ul>
<ul>
<li>All of the settings are specified by adding a <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> struct to your model, so see the many notes there. Notably, the default method is the Fletcher-Reeves conjugate gradient method, and if your model does not have a dlog likelihood function, then a numeric gradient will be calculated via <a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a>. Add a <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> group to your model for other methods, including the Nelder-Mead simplex and simulated annealing.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set.</td></tr>
    <tr><td class="paramname">dist</td><td>The <a class="el" href="structapop__model.html">apop_model</a> object: <a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">apop_gamma</a>, <a class="el" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a>, <a class="el" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, &amp;c. You can add an <code><a class="el" href="structapop__mle__settings.html">apop_mle_settings</a></code> struct to it (<code>Apop_model_add_group(your_model, apop_mle, .verbose=1, .method="PR cg", and_so_on)</code>). So, see the <code><a class="el" href="structapop__mle__settings.html">apop_mle_settings</a></code> documentation for the many options, such as choice of method and tuning parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None, but the input model is modified to include the parameter estimates, &amp;c.</dd></dl>
<ul>
<li>There is auxiliary info in the <code>-&gt;info</code> element of the post-estimation struct. Get elements via, e.g.: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__model.html">apop_model</a> *est = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(your_data, <a class="code" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a>);
<span class="keywordtype">int</span> status = <a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(est-&gt;<a class="code" href="structapop__model.html#aeba2b05a99d67db4ba658115ee5f9780">info</a>, .rowname=<span class="stringliteral">&quot;status&quot;</span>);
<span class="keywordflow">if</span> (status)
    <span class="comment">//trouble</span>
<span class="keywordflow">else</span>
    <span class="comment">//optimum found</span>
</pre></div></li>
</ul>
<ul>
<li>During the search for an optimum, ctrl-C (SIGINT) will halt the search, and the function will return whatever parameters the search was on at the time. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Fri Jun 6 2014.</div></body></html>
